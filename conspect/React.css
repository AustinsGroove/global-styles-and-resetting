/**
  |============================
  | Веб-застосунки
  |============================
*/
/* 
У сучасній веб-розробці змінилися не тільки техніки, що дозволяють веб-сайтам виглядати краще, завантажуватися швидше і бути 
приємнішими у використанні. Насамперед змінилися фундаментальні речі - те, як ми проектуємо та створюємо веб-застосунки.

Візьмемо довільний веб-сайт, наприклад, для роботи з колекцією рецептів, розкладом тренувань тощо. Завжди є набір сторінок: 
домашня, профіль, сторінка колекції та сторінка одного елемента колекції.


--- Multiple-page Application ---

Кілька років тому ми використовували б підхід, який включає декілька окремих HTML-сторінок.
- Архітектура клієнт-сервер
- Вся логіка живе на сервері
- На кожен запит сервер надсилає готовий HTML-документ
- Перезавантаження сторінки при кожному запиті
- Погана інтерактивність
- Відмінне SEO


--- Single-page Application ---

Сучасний підхід - сайт, на якому користувач ніколи не переходить на інші HTML-сторінки. 
Інтерфейс, замість запиту HTML-документів з сервера, перемальовується на клієнті, на одній і тій самій сторінці, 
без перезавантаження.
- Архітектура клієнт-сервер
- При завантаженні сайту сервер завжди віддає стартову HTML-сторінку index.html
- Кожен наступний запит на сервер отримує лише дані у JSON-форматі
- Оновлення інтерфейсу відбувається динамічно на клієнті
- Завантаження першої сторінки може бути досить повільним (лікується)
- Логіка, не пов'язана із безпекою, живе на клієнті
- Слабке SEO (лікується)
- Складність коду та його підтримки масштабується з кількістю функціоналу застосунку
*/

/**
  |============================
  | Бібліотека React
  |============================
*/

/* 
React - це бібліотека для створення елементів інтерфейсу користувача. У React немає вбудованої маршрутизації, 
HTTP-модуля тощо. Проте є багата екосистема, яка дозволить вирішити будь-яке завдання.
При створенні застосунку з використанням React розробник не взаємодіє безпосередньо з DOM-деревом. 
Його завдання - описати інтерфейс за допомогою компонентів (шаблон) та керувати зміною даних (модель). 

React, при зміні даних моделі, сам оновить інтерфейс за шаблоном.

React - мультиплатформний, розмітку можна рендерити на сервері (Next.js), писати нативні (React Native) або 
десктопні (Electron) застосунки.

--- Browser DOM ---
Browser DOM - деревоподібне представлення HTML-документа, де кожен елемент документа представлений у вигляді DOM-вузла. 
Зберігається в браузері і безпосередньо пов'язаний з тим, що ми бачимо на сторінці.

З кожною зміною DOM браузер виконує кілька трудомістких операцій. Часті операції оновлення такого дерева негативно 
впливають на продуктивність та реакцію інтерфейсу. Тому він повільний, та оновлювати його необхідно ефективно.

--- Virtual DOM --- 
Virtual DOM - абстракція, легковагова копія реального DOM-дерева у вигляді JSON-документа.

- Існує тільки в пам'яті і не рендериться в браузері
- Не залежить від внутрішньої імплементації браузера
- Використовує найкращі практики оновлення реального DOM
- Збирає оновлення в групи для оптимізації рендеру (batching)

--- Алгоритм оновлення DOM ---
У React кожен елемент інтерфейсу - це компонент (кастомний або вбудований), який залежить від пропсів або стану, 
і представлений вузлами віртуального DOM-дерева. Взаємодія користувача з інтерфейсом змінює стан застосунку.

У разі зміни компонента створюється нове віртуальне DOM-дерево. Далі, використовуючи breadth-first алгоритм, 
відбувається порівняння (диференціювання, diffing) двох віртуальних дерев - до та після оновлення.

https://s3.eu-north-1.amazonaws.com/lms.goit.files/f367ae64-ce26-49b3-b818-8b8cb775972aimage.png

Обчислюється різниця між попередньою та новою версією віртуального DOM-дерева. Застосовується оптимальний варіант 
внесення змін до реального DOM. Це гарантує, що в реальному DOM-дереві провадиться мінімальна кількість оновлень, 
тим самим підвищуючи продуктивність інтерфейсу.
*/

/**
  |============================
  | Інструменти
  |============================
*/
/* 
Для створення React-застосунку необхідні Node.js, Webpack, Babel, React і DevTools. 
Можна написати свою Webpack-збірку або взяти будь-яку хорошу з GitHub.

--- Create React App ---

Для навчання та маленьких/середніх проектів рекомендується використовувати утиліту від авторів React.

- Абстрагує всю конфігурацію, дозволяючи зосередитись на написанні коду
- Включає необхідні інструменти: Webpack, Babel, ESLint тощо.
- Розширюється додатковими пакетами з екосистеми React
- Має функцію вилучення, яка видаляє абстракцію і відкриває конфігурацію

npx create-react-app ім'я_папки_проекту

ІНФОРМАЦІЯ
Щоб створити застосунок у поточній папці, замість імені проекту ставиться крапка. Наприклад npx create-react-app .. 
Це можна використовувати, коли був склонований репозиторій, і в його локальній версії ініціалізується застосунок.

npx — інструмент, призначений для того, щоб допомогти стандартизувати використання npm-пакетів. 
Постачається з npm версії 5.2.0 та вище. npm спрощує встановлення та керування залежностями, розміщеними в реєстрі, 
a npx спрощує використання CLI-утиліт та інших файлів, що виконуються, без необхідності їх встановлення в систему або проект.

Документація Create React App:
https://create-react-app.dev/

--- React DevTools ---
В інструментах розробника можна подивитися на дерево компонентів, їх стан та пропси. 
Профайлер корисний під час оптимізації застосунку.

Devtools в Chrome Web Store
https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en
Introducing the New React DevTools
https://reactjs.org/blog/2019/08/15/new-react-devtools.html
*/

/**
  |============================
  | JSX
  |============================
*/
/* 
const link = <a href="<https://reactjs.org/>">React website</a>;

Це не рядок і не HTML, цей XML-образний синтаксис називається JSX (JavaScript Syntax Extension) - розширення 
синтаксису JavaScript, за допомогою якого зручно описувати розмітку того, що ми хочемо побачити на екрані.
- Дозволяє використовувати XML-образний синтаксис прямо у JavaScript
- Спрощує код, робить його декларативним та читабельним
- Описує об'єкти - елементи Virtual DOM
- Це не HTML, Babel трансформує JSX у виклики функцій
- У JSX можна використовувати всі можливості JavaScript

--- REACT ЕЛЕМЕНТИ ---
JSX створює елементи - найменші будівельні блоки React. 
Елементи Virtual DOM це звичайні JavaScript об'єкти, тому створювати їх дуже швидко.

Використовуючи JSX, розмітка стає схожою на звичні HTML-шаблони.

src/index.js

const imageUrl = "https://images.pexels.com/photos/461198/pexels-photo-461198.jpeg?dpr=2&h=480&w=640";

const productPrice = 10.99;

const product = (
  <div>
    <img src={imageUrl} alt="Tacos With Lime" width="640" />
    <h2>Tacos With Lime</h2>
    <p>Price: {productPrice}$</p>
    <button type="button">Add to cart</button>
  </div>
);

- Усередині JSX можна використовувати будь-який валідний вираз, обертаючи його в фігурні дужки.
- Значення атрибутів вказуються в подвійних лапках, якщо це звичайний рядок, та у фігурних дужках, якщо значення 
обчислюється, або тип відрізняється від рядка.
- Всі атрибути React-елементів іменуються в camelCase нотації.
- JSX-теги можуть бути батьками інших JSX-тегів. Якщо тег порожній або самозакривається, його обов'язково 
необхідно закрити використовуючи />.

--- Рендер елементів у DOM-дерево ---
Для того, щоб відрендерувати елемент у DOM-дерево, у пакеті react-dom є методи createRoot(container) та render(element), 
які працюють разом.

- createRoot(container) приймає посилання на існуючий DOM-елемент, наприклад div#root з index.html і створює корінь, 
в який буде рендеруватись вся програма.
- render(element) чекає на посилання на React-елемент або компонент (що рендерити).

src/index.js

import ReactDOM from "react-dom/client";

const imageUrl = "https://images.pexels.com/photos/461198/pexels-photo-461198.jpeg?dpr=2&h=480&w=640";

const productPrice = 10.99;

const product = (
  <div>
    <img src={imageUrl} alt="Tacos With Lime" width="640" />
    <h2>Tacos With Lime</h2>
    <p>Price: {productPrice}$</p>
    <button type="button">Add to cart</button>
  </div>
);

ReactDOM.createRoot(document.getElementById("root")).render(product);

--- ОДИН render() НА ПРОГРАМУ ---
React використовує модель відносин предок - нащадок, тому достатньо використовувати лише один виклик render() в програмі. 
Рендер найвищого елемента в ієрархії потягне за собою рендер всього піддерева.

--- Правило спільного батька ---
Права частина висловлювання присвоювання має повертати одне значення. Розберемо наступний код із невалідною JSX-розміткою.

const post = (
  <h2>Post Header</h2>
  <p>Post text</p>
);

Вираз це одне значення, результат деяких обчислень, звідси випливає правило спільного батька.

const post = (
  <div>
    <h2>Post Header</h2>
    <p>Post text</p>
  </div>
);

Якщо в розмітці зайвий тег-обгортка не потрібний, використовуються фрагменти, схожі на DocumentFragment. 
Цей вбудований компонент при рендері розчиняється, підставляючи свій вміст.

import { Fragment } from "react";

const post = (
  <Fragment>
    <h2>Post Header</h2>
    <p>Post text</p>
  </Fragment>
);

Синтаксис фрагментів можна скоротити та не додавати імпорт Fragment. Babel зробить всі необхідні трансформації, 
замінивши порожні JSX-теги на React.Fragment.

const post = (
  <>
    <h2>Post Header</h2>
    <p>Post text</p>
  </>
);


--- Додаткові матеріали ---
Знайомство з JSX
https://react.dev/learn/writing-markup-with-jsx
*/

/**
  |============================
  | Компоненти
  |============================
*/
/* 
Компоненти - основні будівельні блоки React-застосунків, за допомогою яких інтерфейс розділяється на незалежні частини.

Розробник створює невеликі компоненти, які можна поєднувати, щоб сформувати більші, або використовувати їх як самостійні 
елементи інтерфейсу. Найголовніше в цій концепції те, що і великі, і маленькі компоненти можна використовувати повторно 
і в поточному, і в новому проекті.

React-застосунок можна уявити як дерево компонентів. 
На верхньому рівні стоїть кореневий компонент, у якому вкладена довільна кількість інших компонентів. 
Кожен компонент повинен повернути JSX-розмітку, тим самим вказуючи, який HTML ми хочемо відрендерити в DOM.

--- Компоненти-функції ---
У найпростішій формі компонент - це JavaScript-функція з дуже простим контрактом: функція отримує об'єкт 
властивостей, який називається props і повертає дерево React-елементів.

ІНФОРМАЦІЯ
Ім'я компонента обов'язково повинно починатися з великої літери. 
Назви компонентів з маленької літери зарезервовані для HTML-елементів. Якщо ви спробуєте назвати компонент card, 
а не Card, під час рендеру React проігнорує його та відрендерить тег <card></card>.

const MyFunctionalComponent = props => <div>Functional Component</div>;

Компоненти-функції складають більшу частину React-застосунку.
- Менше boilerplate-коду
- Легше сприймати
- Легше тестувати
- Немає контексту (this)

Зробимо картку продукту компонентом-функцією.

const Product = props => (
  <div>
    <img
      src="<https://images.pexels.com/photos/461198/pexels-photo-461198.jpeg?dpr=2&h=480&w=640>"
      alt="Tacos With Lime"
      width="640"
    />
    <h2>Tacos With Lime</h2>
    <p>Price: 10.99$</p>
    <button type="button">Add to cart</button>
  </div>
);

// У розмітці компонент записується як JSX-тег
ReactDOM.createRoot(document.getElementById("root")).render(<Product />);

--- Властивості компонента (props) ---
Властивості (пропси) - це одна із основних концепцій React. Компоненти приймають довільні властивості і повертають 
React-елементи, що описують, що потрібно відрендерити в DOM.
- Пропси використовуються для передачі даних від батька до дитини.
- Пропси передаються лише вниз по дереву від батьківського компонента.
- При зміні пропсів React ререндерить компонент і, можливо, оновлює DOM.
- Пропси доступні лише для читання, у дитині їх не можна змінити.

Пропсом може бути текст кнопки, зображення, url, будь-які дані для компонента. 
Пропси можуть бути рядками або результатом JS-виразу. Якщо передане лише ім'я пропса - це буль, за замовчуванням true.

const App = () => (
  <>
    <h1>Best selling products</h1>
    <Product name="Tacos With Lime" />
  </>
);

Компонент <Product> оголошує параметр props, це завжди буде об'єкт, що містить усі передані пропси.
const Product = props => (
  <div>
    <h2>{props.name}</h2>
  </div>
);

Додамо компоненту <Products> кілька інших властивостей.
const Product = props => (
  <div>
    <img src={props.imgUrl} alt={props.name} width="640" />
    <h2>{props.name}</h2>
    <p>Price: {props.price}$</p>
    <button type="button">Add to cart</button>
  </div>
);

Відразу будемо використовувати простий патерн під час роботи з props. 
Оскільки props - це об'єкт, ми можемо деструктуризувати його у підписі функції. Це зробить код чистішим і читабельнішим.
const Product = ({ imgUrl, name, price }) => (
  <div>
    <img src={imgUrl} alt={name} width="640" />
    <h2>{name}</h2>
    <p>Price: {price}$</p>
    <button type="button">Add to cart</button>
  </div>
);

const App = () => (
  <div>
    <h1>Best selling products</h1>
    <Product
      imgUrl="<https://images.pexels.com/photos/461198/pexels-photo-461198.jpeg?dpr=2&h=480&w=640>"
      name="Tacos With Lime"
      price={10.99}
    />
    <Product
      imgUrl="<https://images.pexels.com/photos/70497/pexels-photo-70497.jpeg?dpr=2&h=480&w=640>"
      name="Fries and Burger"
      price={14.29}
    />
  </div>
);

В підсумку ми створили компонент, що налаштовується, і який можна використовувати для відображення товару. 
Ми передаємо йому дані як пропси, а у відповідь отримуємо дерево React-елементів з підставленими значеннями.
Компоненти:
https://react.dev/learn/your-first-component#components-ui-building-blocks
Пропси:
https://react.dev/learn/passing-props-to-a-component

--- Значення пропсів за замовчуванням ---
Що якщо компонент очікує якесь значення, а його не передали? - під час звернення до властивості об'єкта props 
отримаємо undefined.
Для того щоб вказати значення властивостей за замовчуванням, використовується синтаксис значень за замовчуванням 
під час деструктуризації пропсів.

const Product = ({
  imgUrl = "<https://dummyimage.com/640x480/2a2a2a/ffffff&text=Product+image+placeholder>",
  name,
  price,
}) => (
  <div>
    <img src={imgUrl} alt={name} width="640" />
    <h2>{name}</h2>
    <p>Price: {price}$</p>
    <button type="button">Add to cart</button>
  </div>
);

* Визначення defaultProps гарантує, що props.imgUrl матиме значення, навіть якщо воно не було вказане  під час виклику 
компонента у батька.

ReactDOM.createRoot(document.getElementById("root")).render(
  <Product name="Tacos With Lime" price={10.99} />
);

--- Властивість props.children --- 
Концепція дочірніх елементів дозволяє дуже просто робити композицію компонентів. У вигляді дітей можна передавати 
компоненти як вбудовані, так і кастомні. Це дуже зручно під час роботи зі складними складеними компонентами.

Властивість children автоматично доступна в кожному компоненті, її вмістом є те, що знаходиться між відкриваючим 
та закриваючим JSX-тегом.
У функціональних компонентах звертаємось як props.children.
Значенням props.children може бути практично все, що завгодно.

Наприклад, у нас є компонент профілю <Profile> та оформлювальний компонент <Panel>, в який ми можемо поміщати 
довільний контент.

const Profile = ({ name, email }) => (
  <div>
    <p>Name: {name}</p>
    <p>Email: {email}</p>
  </div>
);

const Panel = ({ title, children }) => (
  <section>
    <h2>{title}</h2>
    {children}
  </section>
);

const App = () => (
  <div>
    <Panel title="User profile">
      <Profile name="Mango" email="mango@mail.com" />
    </Panel>
  </div>
);

В іншому разі нам би довелося прокинути пропи для <Profile> через <Panel>, що тісніше пов'язує компоненти та 
ускладнює повторне використання.

--- Властивість propTypes ---
https://www.npmjs.com/package/prop-types
Перевірка типів одержуваних пропсів дозволить відловити багато помилок. Це економить час на дебаг, допомагає 
у разі неуважності та рятує з ростом застосунку. У майбутньому потрібно буде приділити час і познайомитися з 
Flow або TypeScript, а для старту вистачить невеликої бібліотеки.

Пакет prop-types надає ряд валідаторів для перевірки коректності отриманих типів даних під час виконання коду, 
повідомляючи про невідповідності в консолі. Все що необхідно зробити - це описати типи пропсів, що отримуються 
компонентом у спеціальній статичній властивості propTypes. Перевірка пропсів за допомогою prop-types відбувається 
лише під час розробки, у продакшені в ній немає потреби.

npm install --save-dev prop-types

Використаємо prop-types та опишемо пропси компонента Product.

import PropTypes from "prop-types";

const Product = ({
  imgUrl = "<https://dummyimage.com/640x480/2a2a2a/ffffff&text=Product+image+placeholder>",
  name,
  price,
}) => (
  <div>
    <img src={imgUrl} alt={name} width="640" />
    <h2>{name}</h2>
    <p>Price: {price}$</p>
    <button type="button">Add to cart</button>
  </div>
);

Product.propTypes = {
  imgUrl: PropTypes.string,
  name: PropTypes.string.isRequired,
  price: PropTypes.number.isRequired,
};

Спочатку застосовуються значення за замовчуванням, задані в defaultProps. 
Після цього запускається перевірка типів за допомогою propTypes. 
Отже, перевірка типів поширюється і на значення за замовчуванням.
 */

/**
   |============================
   | Рендер за умовою
   |============================
 */
/* 
Для рендеру розмітки за умовою використовуються оператори розгалужень та умов. 
Умови можна перевіряти перед поверненням розмітки або прямо в JSX.

ІНФОРМАЦІЯ
Якщо за умовою нічого не повинно бути відрендерено, можна повернути null, undefined або false, вони не рендеряться.

--- if за допомогою логічного оператора && ---
Читається як: якщо умова приводиться до true, то рендерим розмітку.

const Mailbox = ({ unreadMessages }) => {
  return (
    <div>
      <h1>Hello!</h1>
      {unreadMessages.length > 0 && (
        <p>You have {unreadMessages.length} unread messages.</p>
      )}
    </div>
  );
};

--- if...else за допомогою тернарного оператора ---
Читається як: якщо умова приводиться до true, рендерим розмітку після ?, інакше - рендерим розмітку після :.

const Mailbox = ({ username, unreadMessages }) => {
  return (
    <div>
      <h1>Hello {username}</h1>
      {unreadMessages.length > 0 ? (
        <p>You have {unreadMessages.length} unread messages.</p>
      ) : (
        <p>No unread messages.</p>
      )}
    </div>
  );
};

Останній приклад можна записати по-іншому, результат буде однаковий.

const Mailbox = ({ name, unreadMessages }) => {
  return (
    <div>
      <h1>Hello {name}</h1>
      <p>
        {unreadMessages.length > 0
          ? `You have ${unreadMessages.length} unread messages.`
          : "No unread messages."}
      </p>
    </div>
  );
};

Нехай у компоненті продукту ще є його доступна кількість.

const Product = ({ imgUrl, name, price, quantity }) => (
  <div>
    <img src={imgUrl} alt={name} width="640" />
    <h2>{name}</h2>
    <p>Price: {price}$</p>
    <h1>Quantity: {quantity < 20 ? "Few left" : "In stock"}</h1>
    <button type="button">Add to cart</button>
  </div>
);

Додаткові матеріали
Умовний рендеринг
https://react.dev/learn/conditional-rendering
All the Conditional Renderings in React
https://www.robinwieruch.de/conditional-rendering-react/
 */

/**
   |============================
   | Колекції
   |============================
 */
/* 
Для того щоб відрендерити колекцію однотипних елементів, використовується метод Array.prototype.map(), 
callback-функція якого, для кожного елемента колекції повертає JSX-розмітку. Отже, отримуємо масив React-елементів, 
який можна рендерити.

const favouriteBooks = [
  { id: "id-1", name: "JS for beginners" },
  { id: "id-2", name: "React basics" },
  { id: "id-3", name: "React Router overview" },
  { id: "id-4", name: "Redux in depth" },
];

const BookList = ({ books }) => {
  return (
    <ul>
      {books.map(book => (
        <li>{book.name}</li>
      ))}
    </ul>
  );
};

const App = () => {
  return (
    <div>
      <BookList books={favouriteBooks} />
    </div>
  );
};

Ключі
Під час виконання коду з прикладу вище спливе попередження про те, що для елементів списку потрібен ключ. 
React не може відрізнити елементи в колекції, таким чином, перемальовуючи всю колекцію повністю у разі будь-яких змін.

Ключ (key) — це спеціальний рядковий проп, який потрібно задати під час створення елементів колекції.
Елементи всередині колекції повинні бути забезпечені ключами, щоб мати стабільну ідентичність. 
React використовує ключі, щоб визначити, які з елементів в колекції необхідно створити і відрендерити знову, 
а не використовувати елементи з попереднього рендеру. Таким чином ми уникаємо перестворення всіх елементів 
колекції щоразу, коли щось змінюється.

Ключі повинні бути:
Унікальні - ключ елемента повинен бути унікальним лише серед його сусідів. Немає сенсу у глобально унікальних ключах.
Стабільні - ключ елемента не повинен змінюватися з часом, зі зміною порядку елементів або після оновлення сторінки.

ІНФОРМАЦІЯ
Індекси масиву унікальні, проте вони не стабільні - при перетасовуванні колекції ключі змінюються. 
Дата і час - унікальні, але не стабільні, оскільки постійно збільшуються. Таким чином, під час кожного рендеру 
створюються нові ключі. Використання випадкового числа рівносильно тому, що ключі взагалі не використовуються, 
оскільки випадкові числа не є унікальними або стабільними.

Найкращий спосіб задати ключ - використовувати статичний рядок, який однозначно ідентифікує елемент списку серед інших. 
Найчастіше як ключі використовуються ідентифікатори об'єктів, створених базою даних, - постійне, незмінне значення. 
Але також підійде будь-яке унікальне значення якоїсь властивості об'єкта.

const favouriteBooks = [
  { id: "id-1", name: "JS for beginners" },
  { id: "id-2", name: "React basics" },
  { id: "id-3", name: "React Router overview" },
  { id: "id-4", name: "Redux in depth" },
];

const BookList = ({ books }) => (
  <ul>
    {books.map(book => (
      <li key={book.id}>{book.name}</li>
    ))}
  </ul>
);

Якщо об'єкти масиву не мають унікальних значень властивостей і колекція не редагується, тобто у користувача немає 
можливості видалити або ще якось змінити порядок елементів, крім додавання нових, можна використовувати індекси масиву.

const favouriteBooks = [
  { name: "JS for beginners" },
  { name: "React basics" },
  { name: "React Router overview" },
  { name: "Redux in depth" },
];

const BookList = ({ books }) => (
  <ul>
    {books.map((book, index) => (
      <li key={index}>{book.name}</li>
    ))}
  </ul>
);

ІНДЕКСИ ЯК КЛЮЧІ
Використання індексів для ключів - це крайній випадок. В переважній більшості даних будуть унікальні ідентифікатори 
або будь-які інші властивості.

Додаткові матеріали

Списки і ключі
https://react.dev/learn/rendering-lists
*/

/**
  |============================
  | Вбудовані стилі
  |============================
*/
/* 
Існує кілька способів стилізації компонентів, найпростіший, але в той же час найбільш обмежений - це вбудовані стилі. 
Для цього використовується атрибут style, який у React приймає не рядок, а об'єкт стилів.

src/components/App.js

const App = () => {
  return (
    <p
      style={{
        margin: 8,
        padding: "12px 16px",
        borderRadius: 4,
        backgroundColor: "gray",
        color: "white",
      }}
    >
      Please update your email!
    </p>
  );
};

З прикладу можна виділити кілька обов'язкових правил вбудованих стилів:
Імена властивостей, що складаються з двох і більше слів, наприклад background-color, обов'язково повинні бути записані 
в camelCase нотації (backgroundColor), як при зверненні до властивостей об'єкта style у DOM-елемента.
До числових значень більшості властивостей буде автоматично додано суфікс px. 
Якщо необхідно використовувати одиниці відмінні від px, або значення складається з кількох частин, воно вказується як рядок.

Винесемо об'єкт стилів у змінну, щоб підвищити читабельність JSX розмітки.

src/components/App.js

const alertStyles = {
  margin: 8,
  padding: "12px 16px",
  borderRadius: 4,
  backgroundColor: "gray",
  color: "white",
};

const App = () => {
  return (
    <>
      <p style={alertStyles}>Please update your email!</p>
      <p style={alertStyles}>There was an error during transaction!</p>
      <p style={alertStyles}>Payment received, thank you for your purchase!</p>
    </>
  );
};

Створимо компонент Alert який буде рендерувати абзац тексту та приховає у собі майбутню логіку вибору кольору фону.
src/components/Alert.js

const alertStyles = {
  margin: 8,
  padding: "12px 16px",
  borderRadius: 4,
  backgroundColor: "gray",
  color: "white",
};

export const Alert = ({ children }) => {
  return <p style={alertStyles}>{children}</p>;
};

Використовуємо компонент Alert для рендеру декількох повідомлень.
src/components/App.js

import { Alert } from "./Alert";

const App = () => {
  return (
    <>
      <Alert>Please update your email!</Alert>
      <Alert>There was an error during transaction!</Alert>
      <Alert>Payment received, thank you for your purchase!</Alert>
    </>
  );
};

Зробимо так, щоб залежно від типу оповіщення, у компоненті Alert змінювався колір фону абзацу. 
Для цього додамо йому обов'язковий пропс variant з кількома можливими значеннями.
src/components/App.js

import { Alert } from "./Alert";

const App = () => {
  return (
    <>
      <Alert variant="info">
        Would you like to browse our recommended products?
      </Alert>
      <Alert variant="error">
        There was an error during your last transaction
      </Alert>
      <Alert variant="success">
        Payment received, thank you for your purchase
      </Alert>
      <Alert variant="warning">
        Please update your profile contact information
      </Alert>
    </>
  );
};

Логіку вибору кольору винесемо у функцію getBgColor(variant), яка буде повертати рядок із назвою кольору 
залежно від значення параметра variant.

src/components/Alert.js

const alertStyles = {
  margin: 8,
  padding: "12px 16px",
  borderRadius: 4,
  color: "white",
};

const getBgColor = variant => {
  switch (variant) {
    case "info":
      return "blue";
    case "success":
      return "green";
    case "error":
      return "red";
    case "warning":
      return "orange";
    default:
      throw new Error(`Unsupported variant prop value - ${variant}`);
  }
};


export const Alert = ({ variant, children }) => {
  return (
    <p style={{ ...alertStyles, backgroundColor: getBgColor(variant) }}>
      {children}
    </p>
  );
};

ДИНАМІЧНІ СТИЛІ
Відбувається створення фінального значення атрибуту style - базові стилі з alertStyles та динамічне значення 
backgroundColor залежно від пропсу variant. Такий підхід застосовується у разі коли значення однієї і більше 
властивостей залежить від пропсів. Наприклад, якщо посилання на зображення для background-image передається як пропс.

Вбудовані стилі можуть видаватися зручними через простоту використання, але вони мають ряд істотних недоліків.
- Дуже слабка масштабованість та повторне використання стилів
- Обмежені можливості (псевдокласи, псевдоелементи, адаптивні властивості)
- Погана продуктивність при відмальовуванні досить великої кількості елементів
- Відсутність зручних інструментів розробника
- Немає підтримки в популярних інструментах, наприклад autoprefixer

ВИСНОВОК
На практиці вбудовані стилі використовуються тільки для динамічно обчислюваних значень властивостей, у парі із 
зовнішніми таблицями стилів. В якості основного способу стилізації компонентів вбудовані стилі не використовуються в 
проектах та тому не рекомендуються.
*/

/**
  |============================
  | Ванільний CSS
  |============================
*/
/* 
Оформлення компонента можна винести до таблиці стилів. У цьому випадку стилі кожного компонента оголошуються 
в окремому CSS-файлі з розширенням .css. Ім'я файлу складається з імені компонента та розширення. 
Наприклад, для компонента Alert, файл стилів буде називатися Alert.css.

src/components/Alert.css
.alert {
  margin: 8px;
  padding: 12px 16px;
  border-radius: 4px;
  background-color: gray;
  color: white;
}

ЦЕ ЗВИЧАЙНИЙ CSS
Всередині файлу стилів можна написати будь-який валідний CSS код. 
Хорошою практикою буде писати CSS тільки для HTML-розмітки компонента до якого належить цей файл стилів.

Стилі компонента імпортуються у файл оголошення, після чого CSS-класи описані у таблиці стилів доступні для використання. 

У React HTML-атрибуту class відповідає JSX-атрибут className, куди можна передати рядок з перерахуванням 
усіх класів елемента.

src/components/Alert.js

import "./Alert.css";

const Alert = ({ children }) => {
  return <p className="alert">{children}</p>;
};

АВТОМАТИЗАЦІЯ
На стадії збирання проекту Create React App мінімізує CSS та автоматично додає вендорні префікси використовуючи 
Autoprefixer. Сучасний синтаксис та можливості CSS покриваються поліфілами для можливості підтримки старих браузерів. 
Тому розробнику не потрібно турбуватися про це.

Композиція класів
Додамо CSS класи для кожного типу оповіщення, щоб контролювати колір фону абзацу в залежності від значення пропсу variant. 
Для зручності назвемо класи аналогічно варіантам значення пропсу.

src/components/Alert.css

.alert {
  margin: 8px;
  padding: 12px 16px;
  border-radius: 4px;
  color: white;
}

.alert.info {
  background-color: blue;
}

.alert.success {
  background-color: green;
}

.alert.error {
  background-color: red;
}

.alert.warning {
  background-color: orange;
}

Додамо компоненту Alert два необов'язкові пропси outlined та elevated. Їх значеннями можуть бути тільки true, 
false або undefined. Якщо значення цих пропсів true, будемо додавати елементу <p> класи is-outlined та is-elevated.

src/components/Alert.css
// Весь попередній CSS код

.alert.is-outlined {
  outline: 1px solid black;
}

.alert.is-elevated {
  box-shadow: rgb(0 0 0 / 20%) 0px 3px 3px -2px, rgb(0 0 0 / 14%) 0px 3px 4px 0px,
    rgb(0 0 0 / 12%) 0px 1px 8px 0px;
}

Процес обчислення фінального значення атрибуту className залежить від розробника та поточного завдання. 
Наприклад, використовуємо масив рядків та блок if. Класи alert і якийсь із варіантів буде завжди, а класи 
для пропсів elevated та outlined додаємо тільки за потребою.

src/components/Alert.js

import "./Alert.css";
const Alert = ({ variant, outlined, elevated, children }) => {
  const classNames = ["alert", variant];
  if (outlined) classNames.push("is-outlined");
  if (elevated) classNames.push("is-elevated");
  return <p className={classNames.join(" ")}>{children}</p>;
};

СТАНДАРТУ НЕМАЄ
Для обчислення фінального значення атрибуту className можна було використати блок if...else, інструкцію switch, 
тернарний оператор або будь-який інший синтаксис JavaScript, який дасть нам той же результат. Головне, щоб рядок 
з класами був складений правильно і не мав зайвих чи невалідних значень.

--- Бібліотека clsx ---
Для вирішення більшості завдань, пов'язаних з безліччю класів, що задаються згідно з певними умовами, використовують 
бібліотеку clsx. Звичайно, JavaScript надає багатий синтаксис, але здебільшого пишуться непродуктивні рішення або код, 
що погано читається. Бібліотека стандартизує цей процес і робить його більш зручним за рахунок продуманого синтаксису.

npm install clsx

Функції clsx можна передати список виразів як набір аргументів. Вирази що приводяться до true, результат яких це 
рядок або число, буде додано у фінальний рядок класів.

import clsx from "clsx";
const className = clsx(
  "first",
  10,
  undefined && "second",
  true && "third",
  false ? "fourth" : "fifth"
);

console.log(className); // "first 10 third fifth"

Ось як виглядатиме код компонента Alert використовуючи бібліотеку clsx. Навіть у такому, відносно простому випадку, 
код виходить простіше і читабельніше.

src/components/Alert.js

import clsx from "clsx";
import "./Alert.css";

const Alert = ({ variant, outlined, elevated, children }) => {
  return (
    <p
      className={clsx(
        "alert",
        variant,
        outlined && "is-outlined",
        elevated && "is-elevated"
      )}
    >
      {children}
    </p>
  );
};

Можна комбінувати варіативну та об'єктну форму функції clsx. Спочатку передаються класи, які будуть завжди, після чого 
в об'єкті налаштувань перераховуємо динамічні значення класів залежно від якихось обчислень.

src/components/Alert.js

import clsx from "clsx";
import "./Alert.css";

const Alert = ({ variant, outlined, elevated, children }) => {
  return (
    <p
      className={clsx("alert", variant, {
        "is-outlined": outlined,
        "is-elevated": elevated,
      })}
    >
      {children}
    </p>
  );
};

--- Глобальний простір імен ---

Імпорт стилів компонента саме у файл його оголошення це просто гарна практика. Наприклад, якщо зробити імпорт 
стилів Alert.css у компоненті App, то нічого не зламається. В результаті імпорту весь оголошений CSS код файлу 
просто додається в одну загальну таблицю стилів, разом з усім іншим CSS кодом проекту з інших компонентів.

У коді прикладу буде проблема конфлікту CSS правил із селектором класу .text. Залежно від порядку імпорту 
цих двох CSS файлів у додатку фінальні стилі класу text можуть виглядати по-різному.

FirstComponent.css
.text {
  color: red;
  font-size: 24px;
}

SecondComponent.css
.text {
  color: blue;
}

УНІКАЛЬНІСТЬ ІМЕН
Імена селекторів класу повинні бути унікальними у всьому додатку, щоб не було конфліктів CSS правил з однаковими 
селекторами у різних компонентах.

--- Препроцесори ---
Використовувати препроцесори можна, але можливість композиції компонентів робить їх менш корисними, оскільки 
замінює такі концепції як домішки, функції, вкладеність та інші. Не рекомендується використовувати одні й ті самі 
CSS-класи в різних компонентах, для цього є композиція компонентів.

Наприклад, замість використання базового CSS-класу .button у компонентах <LoginButton> та <FollowButton>, 
краще створити компонент <Button> зі своїми власними стилями, які можуть відображатись у кількох варіантах. 
Тоді компоненти <LoginButton> та <FollowButton> можуть використовувати компонент <Button>, а не просто CSS-клас.

// Button.js
const Button = ({ variant, children }) => {
// Базові стилі кнопки з кількома варіантами відображення
  return <button className={clsx("button", variant)}>{children}</button>;
};

// LoginButton.js
const LoginButton = () => {
// Унікальна логіка кнопки логіна
  return <Button variant="primary">Login</Button>;
};

// FollowButton.js
const FollowButton = () => {
// Унікальна логіка кнопки підписки
  return <Button variant="secondary">Follow</Button>;
};

Правила іменування файлів такі ж, як і для ванільного CSS, відрізняється тільки розширення, наприклад .scss для SASS. 
В іншому у препроцесорів ті ж можливості, концепції та недоліки, що і у ванільного CSS. Для того щоб додати можливість 
використання SASS, встановіть його компілятор у проект.

npm install sass

Висновок
Використання ванільного CSS теж не найкращий підхід і має ряд недоліків, особливо у великих проектах.
- Слабка масштабованість
- Обмежене повторне використання стилів
- Для динамічних значень необхідно використовувати вбудовані стилі
- Проблема глобального простору імен
- Необхідність використовувати якусь конвенцію іменування селекторів класу
- Відсутність автоматичного видалення коду, що не використовується.
*/

/**
  |============================
  | CSS-модулі
  |============================
*/
/* 
CSS-модулі - це не офіційна специфікація, вони не імплементовані в браузери. 
Це процес, що запускається на стадії складання проекту (наприклад, за допомогою Webpack), в результаті виконання якого 
імена класів замінюються на унікальні. Це дозволяє використовувати одне і те ж ім'я класу в різних CSS-файлах, 
не турбуючись про конфлікти імен. Цей підхід був розроблений, щоб вирішити проблему глобальної області видимості в CSS.

Create React App за замовчуванням підтримує CSS-модулі, все, що необхідно зробити це створювати файли стилів з розширенням 
.module.css, наприклад Alert.module.css. Всередині модуля CSS можна використовувати будь-який валідний CSS.

src/components/Alert.module.css

.alert {
  margin: 8px;
  padding: 12px 16px;
  border-radius: 4px;
  background-color: gray;
  color: white;
}

ТРОХИ ГЛИБШЕ
Хоча CSS-модуль виглядає як звичайний CSS, насправді він компілюється у формат, що називається ICSS (Interoperable CSS), 
який призначений для розробників інструментів на зразок Webpack, а не для кінцевих користувачів.

Синтаксис імпорту CSS-модуля нагадує імпорт файлу JavaScript модуля. 
У CSS-модулі є експорт за замовчуванням - об'єкт відповідності оригінального та згенерованих імен класів. 
У фінальному файлі стилів буде унікальне ім'я класу у форматі [filename]_[classname]__[hash].

src/components/Alert.js

// Синтаксис імпорту CSS-модуля
import css from "./Alert.module.css";

// Отримуємо об'єкт відповідності імен класів
console.log(css); // { alert: "Alert_alert_ax7yz" }

const Alert = ({ children }) => {
  // Звертаємось до властивості об'єкта на ім'я класу з файлу модуля
  return <p className={css.alert}>{children}</p>;
};



ГЛОБАЛЬНІ СТИЛІ
Селектори тегів за замовчуванням будуть у глобальній області видимості, CSS-модулі генерують лише унікальні 
імена селекторів класу.


Властивість composes
Композиція селекторів це одна з ключових можливостей CSS-модулів, яка дозволяє створювати клас, наслідуючи стилі 
іншого класу, але не дублюючи їх. Використовуємо композицію класів та виконаємо рефакторинг стилів компонента Alert. 
Наслідуємо стилі базового класу .alert у всіх класах варіантів. Властивість composes має передувати іншим правилам, 
щоб можна було перевизначити стилі, якщо це необхідно.

src/components/Alert.module.css

.alert {
  margin: 8px;
  padding: 12px 16px;
  border-radius: 4px;
  background-color: gray;
  color: white;
}

.info {
  composes: alert;
  background-color: blue;
}

.success {
  composes: alert;
  background-color: green;
}

.error {
  composes: alert;
  background-color: red;
}

.warning {
  composes: alert;
  background-color: orange;
}

При композиції у простих випадках можна обійтися без бібліотеки clsx. 
Не задаємо базовий клас alert, тому що від нього виконано композицію класів варіантів. 
В результаті на елементі <p> будуть два класи, базовий alert і клас варіанта, у якому перевизначається 
значення кольору фону.

src/components/Alert.js

import css from "./Alert.module.css";

const Alert = ({ variant, children }) => {
  return <p className={css[variant]}>{children}</p>;
};

ДОСТУП ДО ВЛАСТИВОСТЕЙ
До властивостей об'єкта зазвичай звертаються як css.alert, але можна використовувати квадратні дужки, 
наприклад css["alert"]. Це корисно у випадку коли ім'я властивості зберігається у змінній, як у нас у пропсі variant.


Бібліотека clsx
Додамо CSS класи для вже знайомих нам пропсів outlined та elevated. 
Імена класи, що складаються з декількох слів записують у верблюжій нотації. В протилежному випадку, 
оскільки вони стають властивостями об'єкта, звертатися до них доведеться через квадратні дужки, 
наприклад css["is-outlined"], що менш зручно.

src/components/Alert.module.css

Весь попередній CSS код

.alert.isOutlined {
  outline: 1px solid black;
}

.alert.isElevated {
  box-shadow: rgb(0 0 0 / 20%) 0px 3px 3px -2px, rgb(0 0 0 / 14%) 0px 3px 4px 0px,
    rgb(0 0 0 / 12%) 0px 1px 8px 0px;
}


Тепер ми знову використовуємо бібліотеку clsx для складання фінального значення властивості className.

src/components/Alert.js

import clsx from "clsx";
import css from "./Alert.module.css";

const Alert = ({ variant, outlined, elevated, children }) => {
  return (
    <p
      className={clsx(css[variant], {
        [css.isOutlined]: outlined,
        [css.isElevated]: elevated,
      })}
    >
      {children}
    </p>
  );
};
*/

/**
  |============================
  | Нормалізація стилів
  |============================
*/
/* 
Стилі елементів можуть відрізнятись між браузерами. Для того, щоб привести їх до стандартного вигляду, 
необхідно додати набір правил, що виправляє відмінності у стилях елементів між браузерами, наскільки це можливо.

У Create React App вбудована можливість використовувати PostCSS Normalize - суміш кількох популярних таблиць 
стилів (normalize.css та sanitize.css) з найкращими практиками нормалізації. Все, що необхідно зробити - 
це додати директиву @import-normalize; у будь-якому місці файлу стилів або CSS-модуля. 
Повторюючі імпорти будуть автоматично видалені, тому достатньо додати директиву до одного файлу стилів, наприклад index.css.

src/index.css

@import-normalize;

Решта стилів файлів

НАЛАШТУВАННЯ VSCODE
Якщо у VSCode ви бачите попередження «Unknown at rule @import-normalize css(unknownAtRules)», змініть у редакторі 
значення налаштування css.lint.unknownAtRules на ignore.

Залишилось імпортувати файл стилів index.css з підключеною нормалізацією в JavaScript модуль, наприклад в кореневий 
файл програми index.js або у файл компонента App.js.

src/index.js

import "./index.css";

Крім стандартизації зовнішнього вигляду елементів може бути корисно скинути або додати деякі глобальні стилі елементів. 
Наприклад, відступи списків та заголовків, стилі зображень, стилі елемента <body> і тому подібне. Буде логічно зробити 
це в тому ж файлі, в якому додавалася нормалізація.

src/index.css

@import-normalize;

body {
 font-family: sans-serif;
 line-height: 1.5;
}

h1,
h2,
h3,
h4,
h5,
h6,
p {
 margin: 0;
}

ul,
ol {
 margin: 0;
 padding: 0;
}

img {
 display: block;
 max-width: 100%;
 height: auto;
}
*/
/**
  |============================
  | Cтилізовані компоненти
  |============================
*/
/* 
Ще один спосіб стилізації компонентів - використання бібліотек стилізації компонетів.
import styled from 'styled-components'

Варіанти іикористання:

styled.js


export const Container = styled('div')(({ id }) => {
	const isOnline = id % 2 === 0
	return {
		textAlign: 'center',
		h1: {
			color: isOnline ? 'green' : 'red',
		},
	}
})


const Container = styled.div`
background-color: black;
text-align: center;
& > h1 {
color: ${({ id }) => (id % 2 === 0 ? 'green' : 'red')};
color: ${({ id }) => (id % 2 === 0 ? 'green' : 'red')};
}
`

SCSS (SASS) підтримується.

*/

/**
  |============================
  | Компоненти-класи
  |============================
*/
/* 
Якщо необхідно додати динаміки, компоненти створюються як класи, тому що компоненти-функції (до хуків) обмежені можливістю 
створення розмітки за отриманими пропсами.

- Звичайний ES6 клас, тому застосовуються правила: конструктор, методи, контекст (this).
- Обов'язково розширює базовий клас React.Component.
- Діє як функція, яка отримує props, але також реалізує приватний внутрішній стан.
- Необхідно оголосити обов'язковий метод render(), який викликається за замовчуванням і повертає JSX-розмітку.
- Щоразу під час використання компонента-класу, React буде створювати екземпляр компонента (класу), тому доступ до 
пропсів відбувається через this.props.
- Можна визначити кастомні методи класу і використовувати їх в будь-якому місці, зокрема всередині JSX, викликати або передавати 
дітям як пропси.
- Коли змінюється стан або пропcи компонента, відбувається його ререндер.

// Відокремлюйте іменовані імпорти, це підвищує читабельність коду
import React, { Component } from "react";


class MyClassComponent extends Component {
  static defaultProps = {};


  static propTypes = {};


  render() {
    return <div>Class Component</div>;
  }
}

*/

/**
  |============================
  | Події
  |============================
*/
/* 
Для нативної події браузера в React створюється об'єкт-обгортка SyntheticEvent Object з ідентичним інтерфейсом. 
Це необхідно, щоб забезпечити крос-браузерність та оптимізувати продуктивність.

<button onClick={event => console.log(event)}>Click me!</button>

- Додавання обробника подій з EventTarget.addEventListener() майже не використовується, за рідкісним винятком.
- Пропси подій - не виняток та іменуються за допомогою camelCase. Наприклад onClick, onChange, onSubmit, onMouseEnter.
- У проп події передається посилання на callback-функцію, яка буде викликана під час настання події.
- Обробники подій отримують екземпляр SyntheticEvent Object.

В React "під капотом" реалізовано делегування подій. Слухачі не додаються безпосередньо до DOM-елементів. 
Передача колбека - це просто реєстрація функції, яка буде викликана внутрішніми механізмами реакта під час настання події.



Лічильник

Створимо компонент-лічильник з можливістю збільшення і зменшення значення.

import React, { Component } from "react";
import ReactDOM from "react-dom";

class Counter extends Component {
  static defaultProps = {
    step: 1,
  };

  render() {
    const { step } = this.props;

    return (
      <div>
        <span>0</span>
        <button type="button">Increment by {step}</button>
        <button type="button">Decrement by {step}</button>
      </div>
    );
  }
}

ReactDOM.render(<Counter step={5} />, document.getElementById("root"));



Анонімні колбеки

Інлайн колбеки вважаються антипатерном. 
Щоразу, коли компонент ререндериться, буде створена нова callback-функція. 
У багатьох випадках це нормально. Але, якщо callback передається як проп компонентам нижче у дереві, вони будуть знову 
відрендерені, оскільки прийдуть нові пропи посилального типу (функція). До того ж великі інлайн функції в JSX заважають 
читабельності розмітки компонента.



class Counter extends Component {
...

  render() {
    const { step } = this.props;

    return (
      <div>
        <span>0</span>
        <button
          type="button"
          onClick={evt => {
            console.log("Increment button was clicked!", evt);// працює
            console.log("this.props: ", this.props);// працює
          }}
        >
          > Increment by {step}
        </button>
        <button
          type="button"
          onClick={evt => {
            console.log("Decrement button was clicked!", evt);// працює
            console.log("this.props: ", this.props);// працює
          }}
        >
          Decrement by {step}
        </button>
      </div>
    );
  }
}


Кастомні методи
Найчастіше обробники подій оголошуються як методи класу, після чого jsx-атрибуту передається посилання на метод.


class Counter extends Component {
...

  handleIncrement(evt) {
    console.log("Increment button was clicked!", evt);// працює
    console.log("this.props: ", this.props);// Error: cannot read props of undefined
  }

  handleDecrement(evt) {
    console.log("Decrement button was clicked!", evt);// працює
    console.log("this.props: ", this.props);// Error: cannot read props of undefined
  }

  render() {
    const { step } = this.props;

    return (
      <div>
        <span>0</span>
        <button type="button" onClick={this.handleIncrement}>
          Increment by {step}
        </button>
        <button type="button" onClick={this.handleDecrement}>
          Decrement by {step}
        </button>
      </div>
    );
  }
}


Прив'язка контексту

Потрібно завжди пам'ятати про значення this у методах, що використовуються як callback-функції. 
В JavaScript контекст у методах класу не прив'язується за замовчуванням. Якщо забути прив'язати контекст, і передати метод 
як callback-функцію обробнику події, під час виклику функції this буде невизначений (undefined).


Прив'язка під час передачі колбека

Уникайте прив'язки контексту у методі render(). Щоразу, коли компонент ререндериться, Function.prototype.bind() 
повертає нову функцію і передає її вниз по дереву компонентів, що призводить до повторного рендеру дочірніх компонентів. 
За достатньої кількості це істотно впливає на продуктивність.

// ❌ Погано
class Counter extends Component {
...

  handleIncrement(evt) {
// ...
  }

  handleDecrement(evt) {
// ...
  }

  render() {
    const { step } = this.props;

    return (
      <div>
        <span>0</span>
        <button type="button" onClick={this.handleIncrement.bind(this)}>
          Increment by {step}
        </button>
        <button type="button" onClick={this.handleDecrement.bind(this)}>
          Decrement by {step}
        </button>
      </div>
    );
  }
}


Прив'язка в конструкторі
Ще один спосіб прив'язати контекст - зробити це у конструкторі класу. Якщо callback-функцій багато, можете уявити, 
наскільки великий може вийти конструктор.

Конструктор виконується один раз, тому bind викликається один раз
Методи класу записуються у властивість prototype функції-конструктора

// ✅ Непогано
class Counter extends Component {
...

  constructor() {
    super();
    this.handleIncrement = this.handleIncrement.bind(this);
    this.handleDecrement = this.handleDecrement.bind(this);
  }

  handleIncrement(evt) {
// ...
  }

  handleDecrement(evt) {
// ...
  }

  render() {
    const { step } = this.props;

    return (
      <div>
        <span>0</span>
        <button type="button" onClick={this.handleIncrement}>
          Increment by {step}
        </button>
        <button type="button" onClick={this.handleDecrement}>
          Decrement by {step}
        </button>
      </div>
    );
  }
}


Публічні властивості класу
Незважаючи на те, що це рекомендований спосіб прив'язки контексту, синтаксис публічних полів класу ще не стандартизовано. 
Але вони вже настільки широко використовуються, що навіть якщо будуть синтаксичні зміни, транспайлер Babel все зробить за нас.

Під час оголошення публічних полів класу, вони записуються не у властивість prototype функції-конструктора, а в об'єкт екземпляра.

// ✅ Добре
class Counter extends Component {
...

  handleIncrement = evt => {
    console.log("Increment button was clicked!", evt); // працює
    console.log("this.props: ", this.props); // працює
  };


  handleDecrement = evt => {
    console.log("Decrement button was clicked!", evt); // працює
    console.log("this.props: ", this.props); // працює
  };


  render() {
    const { step } = this.props;


    return (
      <div>
        <span>0</span>
        <button type="button" onClick={this.handleIncrement}>
          Increment by {step}
        </button>
        <button type="button" onClick={this.handleDecrement}>
          Decrement by {step}
        </button>
      </div>
    );
  }
}
*/

/**
  |============================
  | Внутрішній стан компонента
  |============================
*/
/* 
Об'єкт-стану state - це властивість класу, яка не повинна безпосередньо змінюватися розробником.

- Дані в state контролюють те, що відображається в інтерфейсі.
- Дані, що зберігаються у стані, повинні бути інформацією, яка буде оновлюватися методами компонента.
- Не потрібно дублювати дані з props у стані.
- Щоразу, коли змінюється стан компонента (або пропси), викликається метод render().

У стані зберігають мінімально необхідний набір даних, на підставі яких можна обчислити все необхідне для рендеру інтерфейсу. 
Це робиться викликом селекторів (функцій, які складають дані для інтерфейсу на підставі стану) у методі render(). 
Таким чином ми отримуємо дані, що обчислюються.

- Інтерфейс залежить від стану компонента.
- Стан може змінитися як реакція на дії користувача.
- Під час зміни стану дані передаються вниз по дереву компонентів.
- Компоненти повертають оновлену розмітку і змінюється інтерфейс.

Стан належить компоненту і змінюється тільки його методами. Зміна стану компонента ніколи не вплине на його батька, 
сусідів або будь-який інший компонент у застосунку - тільки на його дочірні елементи. За такої моделі дані у застосунку 
передаються тільки одним, жорстко обмеженим чином. Це називається односпрямований потік даних.


Стан оголошується в конструкторі, оскільки це перше, що відбувається, коли створюється екземпляр класу.

class Counter extends Component {
  constructor() {
    super();

    this.state = {
      value: 0,
    };
  }

...

  render() {
    return (
      <div>
        <span>{this.state.value}</span>
        ...
      </div>
    );
  }
}


Початковий стан від props
Іноді початковий стан залежить від переданих пропсів, наприклад, початкове значення нашого лічильника. У цьому разі 
необхідно явно оголосити параметр props у конструкторі і передати його у виклик super(props). Тоді в конструкторі буде 
доступно this.props.

class Counter extends Component {
  static defaultProps = {
    step: 1,
    initialValue: 0,
  };

  constructor(props) {
    super(props);

    this.state = {
      value: this.props.initialValue,
    };
  }

...
}

ReactDOM.render(<Counter initialValue={10} />, document.getElementById("root"));


Оскільки під капотом використовується Babel, можна пропустити стомлююче оголошення конструктора і вказати стан як публічну 
властивість класу, все інше транспайлер зробить за нас.

class Counter extends Component {
  static defaultProps = {
    step: 1,
    initialValue: 0,
  };

  state = {
    value: this.props.initialValue,
  };

...
}

*/

/**
  |============================
  | Зміна стану компонента
  |============================
*/
/* 
Для оновлення стану використовується вбудований метод setState().

setState(updater, callback)

Першим, обов'язковим аргументом, передається об'єкт з полями, які вказують, яку частину стану необхідно змінити.
Другим, необов'язковим аргументом, можна передати callback-функцію, яка виконається після зміни стану.


НЕБЕЗПЕКА
Не можна змінювати стан безпосередньо за посиланням. 
Будьте дуже уважні, особливо під час роботи з посилальними типами (масив, об'єкт).


state = { fullName: "Poly" };

// ❌ Погано - зміна за посиланням
this.state.fullName = "Mango";

// ✅ Добре
this.setState({
  fullName: "Mango",
});

Цей підхід використовується, коли новий стан не розраховується на підставі попереднього. Тобто, коли у стан записується 
щось нове, перезаписуючи вже існуюче. 

Зробимо компонент з перемикачем, методи якого перезаписуватимуть значення isOpen у стані.

class Toggle extends Component {
  state = { isOpen: false };

  show = () => this.setState({ isOpen: true });

  hide = () => this.setState({ isOpen: false });

  render() {
    const { isOpen } = this.state;
    const { children } = this.props;

    return (
      <>
        <button onClick={this.show}>Show</button>
        <button onClick={this.hide}>Hide</button>
        {isOpen && children}
      </>
    );
  }
}


Як оновлюється стан
Під час виклику setState() не потрібно передавати всі властивості, що зберігаються у стані. Достатньо вказати лише ту частину 
(зріз) стану, яку ми хочемо змінити у цій операції. React потім бере поточний стан і об'єкт, який був переданий у setState(), 
об'єднуючи їх наступним чином.

// стан до об'єднання
const currentState = { a: 2, b: 3, c: 7, d: 9 };

// об'єкт, переданий в setState
const updateSlice = { b: 5, d: 4 };

// нове значення this.state після об'єднання
const nextState = { ...currentState, ...updateSlice };// {a: 2, b: 5, c: 7, d: 4}


Асинхронність оновлення стану !!!
Метод setState() реєструє асинхронну операцію оновлення стану, яка ставиться в чергу оновлень. 
React змінює стан не для кожного виклику setState(), а може об'єднувати кілька викликів в одне оновлення 
для підвищення продуктивності. 

Внаслідок цього, доступ до this.state у синхронному коді після виклику цього методу поверне значення до оновлення.

Уявіть, що при зміні стану ви покладаєтеся на поточне значення стану в обчисленні наступного. 
Використовуємо цикл for для створення (реєстрації) кількох оновлень.

// Припустимо, що є такий стан
state = { value: 0 };

// Запустимо цикл і створимо 3 операції оновлення
for (let i = 0; i < 3; i += 1) {
// Якщо переглянути стан, на всіх ітераціях буде 0
// Тому що це синхронний код та оновлення стану ще не відбулося
  console.log(this.state.value);

  this.setState({ value: this.state.value + 1 });
}

Значення властивості this.state.value запам'ятовується під час створення об'єкта, що передається в setState(), 
а не під час оновлення стану. Тобто, якщо в момент створення об'єкта this.state.value містило 0, у функцію setState() 
передається об'єкт {value: 0 + 1}.

В результаті виконання циклу отримуємо чергу з 3-х об'єктів {value: 0 + 1}, {value: 0 + 1}, {value: 0 + 1} та оригінальний 
стан на момент оновлення {value: 0}}. Після всіх оновлень отримуємо стан {value: 1}.

!!!
Тому не можна покладатися на поточний стан в обчисленні наступного, що залежить від попереднього на момент оновлення. 
Це може призвести до помилок. Тому існує другий спосіб оновити стан.


setState з функцією
Цей підхід використовується, коли нове значення обчислюється на підставі попереднього стану. Метод setState() першим 
аргументом може приймати не об'єкт, а функцію, яка повинна повертати об'єкт, яким ми хочемо оновити стан.

setState((state, props) => {
  return {};
}, callback);

Актуальний стан і пропси на момент асинхронного виконання функції, переданої в setState(), будуть передані в неї 
аргументами state і props. Таким чином, можна бути впевненими у коректному значенні попереднього стану під час створення наступного.

// Припустимо, що є такий стан
state = { value: 0 };

// Запустимо цикл і створимо 3 операції оновлення
for (let i = 0; i < 3; i += 1) {
// Якщо переглянути стан, на всіх ітераціях буде 0
// Тому що це синхронний код та оновлення стану ще не відбулося
  console.log(this.state.value);// 0

  this.setState(prevState => {
// Якщо переглянути стан, переданий callback-функції під час її виклику,
// отримаємо актуальний стан на момент оновлення.
    console.log(prevState.value);// буде різний на кожній ітерації

    return { value: prevState.value + 1 };
  });
}

Щоразу під час виклику функції, переданої в setState(), в параметр prevState буде передане посилання на актуальний стан 
в момент оновлення. Отримаємо об'єкти оновлень {value: 0 + 1}, {value: 1 + 1}, {value: 2 + 1}, і, в результаті, 
this.state.value буде містити 3 .


Тепер можемо замінити функціонал відкрити/закрити у компоненті <Toggle>.

class Toggle extends Component {
  state = { isOpen: false };

  toggle = () => {
    this.setState(state => ({ isOpen: !state.isOpen }));
  };

  render() {
    const { isOpen } = this.state;
    const { children } = this.props;

    return (
      <div>
        <button onClick={this.toggle}>{isOpen ? "Hide" : "Show"}</button>
        {isOpen && children}
      </div>
    );
  }
}


А лічильник виглядатиме так.

class Counter extends Component {
...

  handleIncrement = () => {
    this.setState((state, props) => ({
      value: state.value + props.step,
    }));
  };

  handleDecrement = () => {
    this.setState((state, props) => ({
      value: state.value - props.step,
    }));
  };

...
}



Підіймання стану
Оскільки React використовує односпрямований потік даних зверху вниз, для того щоб змінити стан батька під час події в дитині, 
використовується наступний патерн з callback-функцією.

- У батька є стан і метод, який його змінює.
- Дочірньому елементу у формі пропу передається метод батька, що змінює стан батька.
- У дочірньому елементі відбувається виклик переданого йому методу. 
- Під час виклику цього методу змінюється стан батька.
- Відбувається рендер піддерева компонентів батька.


Розглянемо простий, але наочний приклад.

// Button отримує функцію changeMessage (ім'я пропа), яка викликається під час події onClick

const Button = ({ changeMessage, label }) => (
  <button type="button" onClick={changeMessage}>
    {label}
  </button>
);

class App extends Component {
  state = {
    message: new Date().toLocaleTimeString(),
  };

// Метод, який будемо передавати в Button для виклику під час кліку
  updateMessage = evt => {
    console.log(evt);// Доступний об'єкт події
    this.setState({
      message: new Date().toLocaleTimeString(),
    });
  };

  render() {
    return (
      <>
        <span>{this.state.message}</span>
        <Button label="Change message" changeMessage={this.updateMessage} />
      </>
    );
  }
}

Під час кліку на кнопці стан App оновлюється за допомогою callback-функції, контекст якої прив'язаний до App. 
Цей патерн встановлює чітку межу між "розумними" та "дурними" компонентами.

Патерн підіймання стану може мати будь-яку вкладеність.
*/

/**
  |============================
  | Типи внутрішніх даних компонента-класу
  |============================
*/
/* 

static data - статичні властивості і методи, до яких необхідно отримувати доступ без екземпляра.
this.state.data - динамічні дані, що змінюються методами компонента, стан.
this.data - дані, які будуть різні для кожного екземпляра.
const DATA - константи, дані, які не змінюються, та однакові для всіх екземплярів.
*/

/**
  |============================
  | Приклад модалки
  |============================
*/
/* 
Створимо модальне вікно.

src/App.jsx

import Header from './components/Header/Header'
import Modal from './components/Modal/Modal'
import { Component } from 'react'

class App extends Component {
	state = {
		isShowModal: false,
	}

	toggleModal = () => {
		this.setState((prev) => ({

			isShowModal: !prev.isShowModal,
		}))
	}
	render() {
		return (
			<>
				<Header showModal={this.toggleModal} />
				{this.state.isShowModal && (
					<Modal hideModal={this.toggleModal}>zxmczmxc</Modal>
				)}
			</>
		)
	}
}

export default App

src/components/Header/Header.jsx

const Header = ({ showModal }) => {
	console.log(10 < 12 && 'component')
	return (
		<nav className='navbar bg-dark mb-3'>
			<div className='container-fluid'>
				<span className='navbar-brand mb-0 h1 text-success'>Navbar</span>
				<button className='btn btn-outline-success' onClick={showModal}>
					Open Modal
				</button>
			</div>
		</nav>
	)
}

export default Header

src/components/Modal/Modal.jsx
const Modal = ({ children, hideModal }) => {
	return (
		<div
			className='modal fade show'
			style={{ display: 'block', backdropFilter: 'blur(5px)' }}
		>
			<div className='modal-dialog'>
				<div className='modal-content'>
					<div className='modal-header'>
						<h5 className='modal-title'> Modal</h5>
						<button
							type='button'
							className='btn-close'
							aria-label='Close'
							onClick={hideModal}
						></button>
					</div>
					<div className='modal-body'>{children}</div>
				</div>
			</div>
		</div>
	)
}

export default Modal

*/

/**
  |============================
  | Форми
  |============================
*/
/* 
Неконтрольовані елементи

Основна мета будь-якої форми - отримати дані користувача. Для цього під час сабміту можна отримати значення полів з її 
властивості elements або, використовуючи FormData. Такий прийом доречно використовувати, коли дані полів форми потрібні 
тільки під час її сабміту.

class LoginForm extends Component {
  handleSubmit = evt => {
    evt.preventDefault();
    const form = evt.currentTarget;
    const login = form.elements.login.value;
    const password = form.elements.password.value;
    console.log(login, password);
    this.props.onSubmit({ login, password });
    form.reset();
  };

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <input type="text" name="login" />
        <input type="password" name="password" />
        <button type="submit">Login</button>
      </form>
    );
  }
}

ReactDOM.render(
  <LoginForm onSubmit={values => console.log(values)} />,
  document.getElementById("root")
);



Контрольовані елементи

Якщо значення елементів форм необхідно отримати в момент зміни поля і зробити щось динамічно, вони повинні бути контрольовані. 
Тобто значення всіх полів повинні бути в state. Цей прийом роботи з елементами форм - досить простий.

- Поле в state визначає значення атрибуту value поля
- Події onChange передається метод, що змінює поле в стані
Отримуємо замкнене коло.
- Під час події onChange метод класу оновлює поле в стані
- Під час зміни стану відбувається ререндер
- Інпут відображається з оновленими даними

Недолік у тому, що вся форма буде повторно рендеритися під час кожної зміни будь-якого поля, але для невеликих форм - це не проблема.

class App extends Component {
  state = {
    inputValue: "",
  };

  handleChange = evt => {
    this.setState({ inputValue: evt.target.value });
  };

  render() {
    const { inputValue } = this.state;
    return (
      <input type="text" value={inputValue} onChange={this.handleChange} />
    );
  }
}

Виходить, що не інтерфейс визначає, які у нас дані, а навпаки, - дані визначають те, що бачить користувач, 
оновлюючи DOM під час зміни стану компонента.




Складні форми

Створимо форму реєстрації.

class SignUpForm extends Component {
  state = {
    login: "",
  };

// Відповідає за оновлення стану
  handleChange = e => {
    this.setState({ login: e.target.value });
  };

// Викликається під час відправлення форми
  handleSubmit = evt => {
    evt.preventDefault();
    console.log(`Signed up as: ${this.state.login}`);

// Проп, який передається формі для виклику під час сабміту
    this.props.onSubmit({ ...this.state });
  };

  render() {
    const { login } = this.state;

    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Name
          <input
            type="text"
            placeholder="Enter login"
            value={login}
            onChange={this.handleChange}
          />
        </label>

        <button type="submit">Sign up as {login}</button>
      </form>
    );
  }
}

ReactDOM.render(
  <SignUpForm onSubmit={values => console.log(values)} />,
  document.getElementById("root")
);

Додамо поля для email і password, а заразом використаємо дуже корисний патерн для callback-функції, що передається в onChange.

// Виносимо об'єкт із примітивами в константу, щоб було зручно скидати.
// Не можна використовувати, якщо в якійсь властивості стану зберігається складний тип.
const INITIAL_STATE = {
  login: "",
  email: "",
  password: "",
};

class SignUpForm extends React.Component {
  state = { ...INITIAL_STATE };

// Для всіх інпутів створюємо один обробник
// Розрізняти інпути будемо за атрибутом name
  handleChange = evt => {
    const { name, value } = evt.target;
    this.setState({ [name]: value });
  };

  handleSubmit = evt => {
    evt.preventDefault();
    const { login, email, password } = this.state;
    console.log(`Login: ${login}, Email: ${email}, Password: ${password}`);
    this.props.onSubmit({ ...this.state });
    this.reset();
  };

  reset = () => {
    this.setState({ ...INITIAL_STATE });
  };

  render() {
    const { login, email, password } = this.state;

    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Name
          <input
            type="text"
            placeholder="Enter login"
            name="login"
            value={login}
            onChange={this.handleChange}
          />
        </label>
        <label>
          Email
          <input
            type="email"
            placeholder="Enter email"
            name="email"
            value={email}
            onChange={this.handleChange}
          />
        </label>
        <label>
          Password
          <input
            type="password"
            placeholder="Enter password"
            name="password"
            value={password}
            onChange={this.handleChange}
          />
        </label>

        <button type="submit">Sign up as {login}</button>
      </form>
    );
  }
}





Генерація Id елементів форми

Доступність (accessibility, a11y) - дуже важлива тема в сучасному вебі. HTML-атрибут for тегу label допомагає 
асистивним технологіям та іншим допоміжним інструментам. В React він представлений jsx-атрибутом htmlFor.

Для генерації унікальних ідентифікаторів елементів форм використовується наступний підхід: для кожного екземпляра компонента, 
під час його ініціалізації, створюється набір унікальних ідентифікаторів, що зберігаються на екземплярі. 
Таким чином, між різними формами одержуємо унікальні id.

// Можна використовувати будь-який пакет для генерації унікальних рядків
import { nanoid } from "nanoid";

class Form extends React.Component {
  loginInputId = nanoid();

  render() {
    return (
      <form>
        <label htmlFor={this.loginInputId}>Login</label>
        <input type="text" name="login" id={this.loginInputId} />
      </form>
    );
  }
}



Чекбокси
Робота з чекбоксами - проста та зрозуміла. Чекбокс може бути всього у 2-х станах: true або false.

Особливості чекбоксів:
- Ім'я атрибута, якому передається поточне значення зі state. Для чекбоксів - це checked, і передаємо туди буль
- Під час обробки події onChange, для отримання значення, в об'єкті події звертаємось до властивості event.target.checked
- Якщо чекбокс повинен зберігати значення, його можна повісити на атрибут value і прочитати з об'єкта події

Додамо до нашої форми реєстрації чекбокс для підтвердження згоди користувача, і зробимо кнопку сабміту неактивною, 
доки неактивний чекбокс.

const INITIAL_STATE = {
  login: "",
  email: "",
  password: "",
  agreed: false,
};

class SignUpForm extends React.Component {
  state = {
    ...INITIAL_STATE,
  };

  handleChange = evt => {
    const { name, value, type, checked } = evt.target;
// Якщо тип елемента - checkbox, беремо значення checked, в іншому випадку - value
    this.setState({ [name]: type === "checkbox" ? checked : value });
  };

  handleSubmit = e => {
    e.preventDefault();
    const { login, email, password, agreed } = this.state;
    console.log(
      `Login: ${login}, Email: ${email}, Password: ${password}, Agreed: ${agreed}`
    );

...
  };

  render() {
    const { login, email, password, agreed } = this.state;

    return (
      <form onSubmit={this.handleSubmit}>
       ...
        <label>
          Agree to terms
          <input
            type="checkbox"
            checked={agreed}
            onChange={this.handleChange}
          />
        </label>

        <button type="submit" disabled={!agreed}>
          Sign up as {login}
        </button>
      </form>
    );
  }
}



Радіокнопки

На відміну від звичного групування за значенням атрибуту name, в React радіокнопка - це лише елемент інтерфейсу, який:
- Знає, чи він вибраний
- Може попросити форму змінити виділення

Зазвичай у радіокнопок є і атрибут checked і value. Наприклад, радіокнопка, що відповідає за вибір статі користувача.

<input
  type="radio"
  checked={this.state.gender === "male"}
  value="male"
  onChage={this.handleGenderChage}
/>

Додамо групу радіокнопок у нашу форму.
// Використовуємо Enumerable, щоб не створювати антипатерн "магічні рядки"

const Gender = {
  MALE: "male",
  FEMALE: "female",
};

const INITIAL_STATE = {
  login: "",
  email: "",
  password: "",
  agreed: false,
  gender: null,
};

class SignUpForm extends React.Component {
  state = {
    ...INITIAL_STATE,
  };

...

  render() {
    const { login, email, password, agreed, gender } = this.state;

    return (
      <form onSubmit={this.handleSubmit}>
        ...

        <section>
          <h2>Choose your gender</h2>
          <label>
            Male
            <input
              type="radio"
              checked={gender === Gender.MALE}
              name="gender"
              value={Gender.MALE}
              onChange={this.handleChange}
            />
          </label>
          <label>
            Female
            <input
              type="radio"
              checked={gender === Gender.FEMALE}
              name="gender"
              value={Gender.FEMALE}
              onChange={this.handleChange}
            />
          </label>
        </section>

        <button type="submit" disabled={!agreed}>
          Sign up as {login}
        </button>
      </form>
    );
  }
}

Селект

Все просто - є селект, є опції, у селекта є value та onChange. Додаємо вибір вікової категорії.

const INITIAL_STATE = {
  login: "",
  email: "",
  password: "",
  agreed: false,
  gender: null,
  age: "",
};

class SignUpForm extends React.Component {
  state = {
    ...INITIAL_STATE,
  };

...

  render() {
    const { login, email, password, agreed, gender, age } = this.state;

    return (
      <form onSubmit={this.handleSubmit}>
        ...

        <label>
          Choose your age
          <select name="age" value={age} onChange={this.handleChange}>
            <option value="" disabled>
              ...
            </option>
            <option value="18-25">18-25</option>
            <option value="26-35">26-35</option>
            <option value="36+">36+</option>
          </select>
        </label>

        <button type="submit" disabled={!agreed}>
          Sign up as {login}
        </button>
      </form>
    );
  }
}
*/
/**
  |============================
  | Життєвий цикл
  |============================
*/
/* 
Існує кілька стадій життєвого циклу - монтування, оновлення та розмонтування. Під час кожної з них у компонента-класу 
викликаються методи, що наслідуються від React.Component. Ми можемо перевизначити їхню поведінку, додавши необхідний 
функціонал в рамках встановлених правил.

Всього є сім методів життєвого циклу, якщо не рахувати render і constructor. На практиці, в більшості повсякденних завдань 
використовують три: 
- componentDidMount, 
- componentDidUpdate,
- componentWillUnmount

https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/



--- Стадія монтування ---
Наступні методи викликаються у такому порядку, коли створюється екземпляр компонента і додається в DOM.

constructor() {}
Викликається в момент створення екземпляра компонента, перш ніж компонент буде розміщений у DOM.
- Ініціалізує початковий стан компонента
- Прив'язує контекст в методах
- Не можна викликати setState()
- У більшості випадків явне зазначення конструктора - зайве

static getDerivedStateFromProps(nextProps, prevState) {}
- На практиці цей метод використовується вкрай рідко
- Викликається перед render() під час монтування та перед усіма наступними викликами render, тобто після оновлення state або props
- Можна використовувати для того, щоб встановити state, залежно від props під час кожної їх зміни
- Повинен повернути об'єкт, яким буде оновлений стан, або null, якщо нічого оновлювати не потрібно
- Немає доступу до this

render() {}

- Дозволяє декларативно описати інтерфейс
- Повертає результат JSX-виразів, піддерево Virtual DOM
- Не можна викликати setState()

componentDidMount() {}

- Викликається відразу після монтування компонента в DOM
- Робимо HTTP-запити, вішаємо кастомні слухачі подій та виконуємо операції з DOM деревом
- Виклик setState() у цьому методі викличе повторний рендер - це нормально



--- Стадія оновлення ---

Оновлення може бути викликано зміною state самого компонента або props, що йому передаються. Під час оновлення необхідно 
перерендерити компонент, що призводить до виклику наступних методів.

shouldComponentUpdate(nextProps, nextState) {}

- Не викликається під час ініціалізації компонента
- Викликається перед ререндером вже змонтованого компонента
- Необхідний виключно для оптимізації процесу рендеру
- За замовчуванням render відбувається щоразу з новими props або state
- Дозволяє порівняти поточні та попередні state і props, повернувши true або false, вказуючи React, чи є необхідність 
оновлювати компонент
- Якщо поверне false, то не станеться render() і componentDidUpdate()
- Не можна викликати setState()
- Використовувати необхідно дуже обережно, тільки після вимірів продуктивності, інакше може призвести до зворотного ефекту.
- Можливо, варто замінити на React.PureComponent, який робитиме поверхове порівняння props. Але лише після вимірів продуктивності

getSnapshotBeforeUpdate(prevProps, prevState) {}

- На практиці цей метод використовується дуже рідко
- Викликається перед тим, як усі зміни готові до додавання в DOM
- Можна використовувати для отримання DOM-значень перед оновленням, наприклад, поточну позицію скрола або розмір 
елемента до оновлення
- Те, що поверне цей метод, буде передане як третій параметр snapshot в componentDidUpdate()

componentDidUpdate(prevProps, prevState, snapshot) {}

- Викликається відразу після оновлення компонента в DOM
- Не викликається при початковому рендері компонента
- Можна викликати setState(), обов'язково обгорнувши його в умову перевірки зміни попередніх і наступних props або state, 
щоб не виник нескінченний цикл ререндера (вкладка зависне або впаде).
- Можна робити HTTP-запити
- Якщо в компоненті є getSnapshotBeforeUpdate(), то значення, що повертається їм, буде передане третім аргументом snapshot, 
в іншому випадку його значенням буде undefined



--- Стадія розмонтування ---
У якийсь момент компонент буде видалений з DOM. При цьому викликається наступний метод.

componentWillUnmount() {}

- Викликається перед розмонтуванням та видаленням елемента з DOM
- Добре підходить для прибирання за собою: слухачі, таймери, HTTP-запити. В іншому випадку будуть витоки пам'яті
- Викликати setState() немає сенсу, компонент ніколи не перерендериться



--- Обробка помилок рендеру ---

React дуже любить класти весь застосунок за будь-якої помилки. Метод componentDidCatch спрацьовує у разі помилки 
у дочірньому компоненті та дозволяє батьківським компонентам відловлювати помилки у дітей, відображаючи запасний 
інтерфейс. В результаті, у разі помилки, інтерфейс не падає.

componentDidCatch(error, info) {}

- Використовується для контролю помилок
- Ловить помилки лише у дітей, але не в самому батьку
- error - результат toString() об'єкта помилки
- info - об'єкт, що описує stack trace


class ErrorBoundary extends React.Component {
 state = { hasError: false };

 componentDidCatch(error, info) {
  // Якщо метод був викликаний, отже, є помилка!
  // Встановлюємо стан
  this.setState({ hasError: true });
  // Також можна надіслати звіт про помилку вашому аналітичному сервісу
  // logErrorToMyService(error, info);
 }

 render() {
  // Якщо є помилка...
  if (this.state.hasError) {
   // Рендеримо fallback UI
   return <h1>Something went wrong, please try again later :(</h1>;
  }

  // Якщо все ок, рендеримо дітей
  return this.props.children;
 }
}
*/
/**
  |============================
  | HTTP-запити
  |============================
*/
/* 
Припустимо, що вже є дерево компонентів, яке має кілька рівнів ієрархії, і необхідно отримати колекцію елементів від API. 
Який саме компонент в ієрархії повинен відповідати за HTTP-запити і зберігання результату відповіді? 
Якщо не використовуємо бібліотеку управління станом, то це залежить від трьох критеріїв.

- Яким компонентам будуть необхідні отримані дані?
- Де буде рендеритися індикатор завантаження, доки виконується HTTP-запит?
- Де буде рендеритися повідомлення у разі помилки HTTP-запиту?

Методи життєвого циклу componentDidMount та componentDidUpdate ідеально підходять для HTTP-запитів. 

- Коли викликається componentDidMount(), компонент вже був відрендерений у DOM і готовий до подальшого оновлення стану. 
- Коли викликається componentDidUpdate(), пропи або стан компонента змінилися, і, можливо, необхідно зробити новий запит, 
попередньо порівнявши їх, щоб не зациклити рендер компонента.

Для HTTP-запиту можна використовувати будь-що: XMLHTTPRequest, fetch, axios, superagent тощо. 
Ми будемо використовувати бібліотеку axios.

npm install axios

Запити будемо робити на Hacker News API. 
Після завершення HTTP-запиту зберігаємо результат у стані компонента. 
У методі render використовуємо стан.

import React, { Component } from "react";
import axios from "axios";

axios.defaults.baseURL = "<https://hn.algolia.com/api/v1>";

const ArticleList = ({ articles }) => (
  <ul>
    {articles.map(({ objectID, url, title }) => (
      <li key={objectID}>
        <a href={url} target="_blank" rel="noreferrer noopener">
          {title}
        </a>
      </li>
    ))}
  </ul>
);

class App extends Component {
  state = {
    articles: [],
  };

  async componentDidMount() {
    const response = await axios.get("/search?query=react");
    this.setState({ articles: response.data.hits });
  }

  render() {
    const { articles } = this.state;
    return (
      <div>
        articles.length > 0 ? <ArticleList articles={articles} /> : null
      </div>
    );
  }
}

Крім поля зберігання даних, можна додати поле для зберігання прапорця індикатора завантаження і помилки. 
Це дозволить зробити використання інтерфейсу приємнішим для користувача.




--- Індикатор завантаження ---

Доки чекаємо на відповідь на HTTP-запит, показуємо індикатор завантаження. Щойно надійшла відповідь, ховаємо індикатор. 
Для цього, на старті запиту ставимо isLoading - true, а у разі успішної відповіді або помилки - false.

...+




class App extends Component {
  state = {
    articles: [],
    isLoading: false,
  };

  async componentDidMount() {
    this.setState({ isLoading: true });
    const response = await axios.get("/search?query=react");
    this.setState({
      articles: response.data.hits,
      isLoading: false,
    });
  }

...
}


В методі render за умовою повертаємо розмітку. Якщо дані завантажуються, показуємо лоадер, в іншому випадку - список з результатами.

...

class App extends Component {
...

  render() {
    const { articles, isLoading } = this.state;
    return (
      <div>
        isLoading ? <p>Loading...</p> : <ArticleList articles={articles} />
      </div>
    );
  }
}

Індикатор завантаження може бути будь-чим: від простого тексту або спінера до кастомного компонента, наприклад react-content-loader.
https://www.edu.goit.global/ru/learn/11043835/31183/31220/training?blockId=20747206




--- Обробка помилки ---

HTTP-запит не завжди виконується без помилок, тому користувачеві обов'язково потрібно дати зрозуміти, якщо щось пішло не так. 
Для цього у стан додаємо властивість зберігання помилки.

При використанні промісів для обробки помилок використовується блок catch, якщо він виконається, значить, сталася помилка. 
Встановлення індикатора завантаження переносимо в блок finally, щоб не дублювати код, який буде виконаний в будь-якому випадку.

...

class App extends Component {
  state = {
    articles: [],
    isLoading: false,
    error: null,
  };

  async componentDidMount() {
    this.setState({ isLoading: true });

    try {
      const response = await axios.get("/search?query=react");
      this.setState({ articles: response.data.hits });
    } catch (error) {
      this.setState({ error });
    } finally {
      this.setState({ isLoading: false });
    }
  }

...
}

Залишилось доповнити метод render.

...
class App extends Component {
...
  render() {
    const { articles, isLoading, error } = this.state;

    return (
      <div>
        {error && <p>Whoops, something went wrong: {error.message}</p>}
        {isLoading && <p>Loading...</p>}
        {articles.length > 0 && <ArticleList articles={articles} />}
      </div>
    );
  }
}


--- Поділ відповідальності ---

Зберігати код, пов'язаний з HTTP-запитом, безпосередньо в компоненті - не найкраща практика. 
У застосунку буде багато різних запитів до API і вони будуть використовуватися у різних компонентах. 
До того ж код HTTP-запитів може бути складним та громіздким. Для зручності рефакторингу будемо все зберігати в одному місці.

Створимо додаткову папку всередині src. Назва папки довільна, але логічна, наприклад helpers, api, services тощо. 
У цій папці будемо зберігати файл з функціями для HTTP-запитів.

// services/api.js
import axios from "axios";

export const fetchArticlesWithQuery = async searchQuery => {
  const response = axios.get(`/search?query=${searchQuery}`);
  return response.data.hits;
};

export default {
  fetchArticlesWithQuery,
};


Імпортуємо сервіс у файлі компонента та викликаємо потрібний метод.

...
import api from "./path/to/services/api";


class App extends Component {
  state = {
    articles: [],
    isLoading: false,
    error: null,
  };

  async componentDidMount() {
    this.setState({ isLoading: true });
    try {
      const articles = api.fetchArticlesWithQuery("react");
      this.setState({ articles });
    } catch (error) {
      this.setState({ error });
    } finally {
      this.setState({ isLoading: false });
    }
  }


  ...
}
*/

/**
  |============================
  | Хуки
  |============================
*/
/* 
Раніше компоненти-функції використовувалися тільки для рендеру HTML-розмітки по отриманим пропсам та шаблону. 
У них не було ні стану, ні методів життєвого циклу. Вони були дуже прості. Часто, у процесі розробки проекту, 
виникає ситуація, коли компоненту-функції необхідно було додати стан чи методи життєвого циклу. 
Доводилося переписувати його до компонент-класу, а це займає час, тому що окрім додавання нового функціоналу, 
розробнику доводилося рефакторити вже написаний код.

Необхідність стандартизувати написання компонентів в одному стилі, а також розширення можливостей повторного 
використання коду, підштовхнули розробників React до створення хуків. Це розширило можливості компонентів-функцій. 
Хуки виявилися настільки зручними, що стали основою React-розробки.

Хуки вирішують безліч проблем у React, з якими розробники стикалися з моменту виходу бібліотеки.
- Складність повторного використання логіки із станом між компонентами. Для цього можна створювати власні хуки.
- Використання незручних патернів «рендер-пропс» (render props) та «компонент вищого порядку» (higher order component), 
які сильно змінюють структуру компонентів і роблять код громіздким.
- Підтримка незв'язаної логіки у методах життєвого циклу та навпаки поділ пов'язаної логіки на кілька методів. Наприклад, 
підписка на подію в componentDidMount та відписка в componentWillUnmount.
- Неможливість розбити великий компонент на дрібніші через логіку зав'язаної на синтаксис класу.
Особливості пов'язані з поведінкою ключового слова this при прив'язці контексту та передачі методу класу як пропсу.

ЗВОРОТНЯ СУМІСТНІСТЬ
Хуки повністю зворотно сумісні з класами. У більш старих проектах, новий функціонал можна писати на хуках, не змінюючи 
вже написаний код у класах. Хуки не містять змін, які можуть поламати існуючий код. Хуки не вимагають нових знань про 
концепції у React. Натомість, хуки надають більш прямий доступ до API вже знайомих понять: пропсів, стану, контексту, 
рефів, та життєвого циклу.

*/

/**
  |============================
  | Хук useState
  |============================
*/
/* 
Перший, простий і найважливіший хук. З назви зрозуміло, що він пов'язаний з станом компонента. 
Саме завдяки йому у функціональних компонентів з'явився внутрішній стан.

import { useState } from "react";

const App = () => {
  const [value, setValue] = useState(0);

  return (
    <div>
      {value}
      <button type="button" onClick={() => setValue(value + 1)}>
        Increment value by 1
      </button>
    </div>
  );
};

Виклик хука useState створює стан і метод, який змінюватиме його значення. У якості параметра хук приймає початковий стан, 
в нашому випадку число 0. У стані може зберігатися будь-який тип даних.

Хук useState повертає масив із двох елементів: перший - поточне значення стану, другий - функцію для його зміни, яку можна 
використовувати де завгодно, наприклад, в обробнику подій. React буде зберігати цей стан між рендерами. 
Використовуючи деструктуризацію, можна задати будь-які імена змінних.

ЩО Ж ТАКЕ ХУКИ?
Хуки - це просто функції, за допомогою яких можна «підчепитися» до стану та методів життєвого циклу з компонентів-функцій 
та використовувати React без класів.

Відмінність із класами
Функція оновлення стану схожа з this.setState у класах, але не зшиває новий і старий стан разом у разі якщо у стані зберігається 
об'єкт. У решті все як зі звичайним станом компонента. Основна відмінність: у класовому компоненті ми можемо створити лише 
один загальний стан, а у функціональному - скільки завгодно, і вони будуть незалежні один від одного.

// ❌ Погано
const App = () => {
  const [state, setState] = useState({
    username: "",
    todos: [{ text: "Learn hooks" }],
    isModalOpen: false,
  });
};

// ✅ Добре
const App = () => {
  const [username, setUsername] = useState("");
  const [todos, setTodos] = useState([{ text: "Learn hooks" }]);
  const [isModalOpen, setIsModalOpen] = useState(false);
};

КРАЩІ ПРАКТИКИ
Не зберігайте об'єкт з кількома непов'язаними властивостями. Краще зробити кілька незалежних станів та оновлювати їх 
атомарно, як у прикладі вище. Це не впливає на продуктивність.

Обмеження хуків
Будь-які хуки можна викликати лише на верхньому рівні компонента функції. Тобто, поза циклами, умовами, вкладеними функціями 
і т.п. Це означає, що хук або є в компоненті, або його немає. Такі, можливо, дивні обмеження стандартизують написання логіки 
компонента та роблять код менш заплутаним.

// ❌ Буде помилка
const App = () => {
  if (isLoggedIn) {
    const [username, setUsername] = useState("");
  }
  // ...
};


// ✅ Так правильно використовувати хуки
const App = () => {
  const [username, setUsername] = useState("");
};
*/

/**
  |============================
  | Хук useEffect
  |============================
*/
/* 
Методи життєвого циклу служать для того, щоб здійснювати якісь операції на різних стадіях життя компонента. 
Наприклад, запитувати дані з бекенда, додавати підписки подій тощо. Усе це називається «побічні ефекти». 
За допомогою хука useEffect у компонентах-функціях можна виконувати всі ці «ефекти», змоделювавши роботу трьох методів 
життєвого циклу - componentDidMount, componentDidUpdate, componentWillUnmount, об'єднавши їх в один API.


import { useState, useEffect } from "react";

const App = () => {
  const [value, setValue] = useState(0);

  useEffect(() => {
    document.title = `You clicked ${value} times`;
  });

  return (
    <div>
      <p>You clicked {value} times</p>
      <button onClick={() => setValue(value + 1)}>Click me</button>
    </div>
  );
};

useEffect(callback, deps) приймає два аргументи:
- callback - функція, усередині якої виконується вся логіка ефекту. Наприклад, запити на сервер, завдання обробників 
подій на документ і т.п.
- залежності - масив змінних, при зміні будь-якого з яких, буде запускатися ефект і виконуватися callback. 
Це може бути стан, пропси або будь-яке локальне значення всередині компонента.

ЗАЛЕЖНОСТІ
Якщо не передати масив залежностей, ефект виконуватиметься на кожному рендері компонента. Саме завдяки масиву залежностей 
ми можемо імітувати методи життєвого циклу.

--- Аналог componentDidMount ---
Хук useEffect запускається не тільки при зміні елементів масиву залежностей, але і відразу після монтування компонента. 
Якщо ми вкажемо в якості другого аргументу порожній масив, callback запуститься на стадії монтування компонента, і більше ніколи.

const App = () => {
  const [value, setValue] = useState(0);

  useEffect(() => {
    console.log("Mouting phase: same when componentDidMount runs");
  }, []);

  return <button onClick={() => setValue(value + 1)}>{value}</button>;
};

--- Аналог componentDidUpdate ---
У масиві потрібно перерахувати всі залежності ефекту. Так отримуємо більш гнучкий аналог методу componentDidUpdate, 
який запускається тільки за зміні певних значень. При цьому важливо враховувати, що такий ефект запускається і на стадії 
монтування, що абсолютно нормально у більшості випадків.

const App = () => {
  const [value, setValue] = useState(0);

  useEffect(() => {
    console.log(value);
    console.log("Updating phase: same when componentDidUpdate runs");
  }, [value]);

  return <button onClick={() => setValue(value + 1)}>{value}</button>;
};

Список залежностей
У програмі створеній за допомогою утиліти Create React App налаштування ESLint містять у собі правило 
react-hooks/exhaustive-deps, перевіряюче обов'язкову наявність всіх зовнішніх змінних (стану, пропсів і т.п.) 
у масиві залежностей. Якщо ви написали ефект та лінтер вказує на проблеми зі списком залежностей - ваш ефект працює 
нестабільно і непередбачувано. Додайте усі необхідні залежності ефекту.

const App = () => {
  const [firstValue, setFirstValue] = useState(0);
  const [secondValue, setSecondValue] = useState(0);

// ❌ Погано. ESLint покаже попередження
  useEffect(() => {
    console.log(firstValue + secondValue);
  }, [firstValue]);

// ✅ Добре. Вказані всі залежності, що використовуються всередині ефекту
  useEffect(() => {
    console.log(firstValue + secondValue);
  }, [firstValue, secondValue]);

  return (
    <>
      <button onClick={() => setFirstValue(value + 1)}>First: {value}</button>
      <button onClick={() => setSecondValue(value + 1)}>Second: {value}</button>
    </>
  );
};

--- Аналог componentWillUnmount ---
Для того, щоб виконати код при розмонтуванні компонента, або взагалі перед кожним викликом ефекту, повертаємо з useEffect 
функцію очищення з необхідним кодом. Це і є аналог componentWillUnmount. Так можна знімати обробники подій, зупиняти таймери
та скасовувати HTTP-запити.

const App = () => {
  useEffect(() => {
    console.log("Mounting phase: same when componentDidMount runs");

    return () => {
      console.log("Unmounting phase: same when componentWillUnmount runs");
    };
  }, []);

  return null;
};

--- Декілька ефектів ---
Хуки дозволяють розділити та згрупувати логіку, створивши «ефект» під кожну незалежну операцію.

class App extends Component {
  handleKeyDown = e => {
    console.log("keydown event: ", e);
  };

  componentDidMount() {
    initThirdPartyLibrary();
    document.addEventListener("keydown", this.handleKeyDown);
  }

  componentDidUpdate(prevProps, prevState) {
    if (prevProps.value !== this.props.value) {
// Do stuff when value prop changes
    }

    if (prevState.isLoggedIn !== this.state.isLoggedIn) {
// Do stuff when isLoggedIn state changes
    }

    if (prevProps.username !== this.props.username) {
// Fetch user when username prop changes
      fetchUser(this.props.username);
    }
  }

  componentWillUnmount() {
    document.removeEventListener("keydown", this.handleKeyDown);
  }
}

const App = () => {
 // 1. Run effect only on mount to init some library
 useEffect(() => {
  initThirdPartyLibrary();
 }, []);

 // 2. Run effect only when username prop changes
 useEffect(() => {
  fetchUser(username);
 }, [username]);

 // 3. Run effect on value prop change
 useEffect(() => {
  // Do stuff when value prop changes
 }, [value]);

 // 4. Run effect on isLoggedIn state change
 useEffect(() => {
  // Do stuff when isLoggedIn state changes
 }, [isLoggedIn]);

 // 5. Run effect on mount and clean up on unmount
 useEffect(() => {
  const handleKeyDown = e => console.log("keydown event: ", e);
  document.addEventListener("keydown", handleKeyDown);
  return () => {
   document.removeEventListener("keydown", handleKeyDown);
  };
 }, []);
};
*/
/**
  |============================
  | Власні хуки
  |============================
*/
/* 
УВАГА
Створення власних хуків потребує досвіду роботи з хуками та React загалом. 
Не варто спеціально прагнути зробити у проекті власні хуки. 
Якщо ви явно бачите можливість повторного використання коду - добре, зробіть свій хук. 
В іншому випадку краще сконцентруватися на вивченні основного матеріалу та використання вбудованих React-хуків або 
готових хуків із бібліотек на кшталт react-use.

Першочергове завдання хуків - спростити повторне використання коду (логіки) для розробників. 
Створення власних хуків це процес отримання логіки компонентів у повторно використовувані функції. 
Це зробить код проекту чистішим і легше у підтримці.

Хук це просто функція, ім'я якої обов'язково починається з приставки use. 
Саме по ній React визначатиме це звичайна функція чи хук. Наприклад: useState, useEffect, useToggle, useDevice, useImages і так далі. 
Власні хуки створюються поза тілом компонента, часто навіть в окремих файлах, та можуть викликати інші хуки, так досягається просте 
повторне використання коду.

Хук useToggle
Розглянемо приклад де у двох компонентах необхідна логіка відкриття, закриття та перемикання елемента інтерфейсу, 
наприклад модального вікна.

// ComponentA.jsx
const ComponentA = () => {
  const [isModalOpen, setIsModalOpen] = useState(false);
  const openModal = () => setIsModalOpen(true);
  const closeModal = () => setIsModalOpen(false);

  return (
    <>
      <button onClick={openModal}>Open modal</button>
      <ModalA isOpen={isModalOpen} onClose={closeModal} />
    </>
  );
};

// ComponentB.jsx
const ComponentB = () => {
  const [isModalOpen, setIsModalOpen] = useState(false);
  const openModal = () => setIsModalOpen(true);
  const closeModal = () => setIsModalOpen(false);

  return (
    <>
      <button onClick={openModal}>Open modal</button>
      <ModalB isOpen={isModalOpen} onClose={closeModal} />
    </>
  );
};


Створення стану та методів для відкриття/закриття модального вікна ідентично в кожному компоненті, 
тобто відбувається дублювання коду. Уявіть, що буде в проекті, де модальні вікна відкриваються десятки чи сотні разів. 
Створимо власний хук useToggle в якому приховаємо створення стану та методів роботи з ним.

src/hooks/useToggle.js

export const useToggle = () => {
  const [isOpen, setIsOpen] = useState(false);
  const open = () => setIsOpen(true);
  const close = () => setIsOpen(false);
  const toggle = () => setIsOpen(isOpen => !isOpen);

  return { isOpen, open, close, toggle };
};

СИГНАТУРА ХУКА
Власний хук може приймати будь-які аргументи і повертати будь-що, правил немає, залежить від реалізації. 
У нашому випадку це об'єкт із чотирма властивостями.

Тоді код із попереднього прикладу буде виглядати наступним чином.

// ComponentA.jsx
import { useToggle } from "path/to/hooks/useToggle.js";

const ComponentA = () => {
  const { isOpen, open, close } = useToggle();

  return (
    <>
      <button onClick={open}>Open modal</button>
      <ModalA isOpen={isOpen} onClose={close} />
    </>
  );
};

// ComponentB.jsx
import { useToggle } from "path/to/hooks/useToggle.js";

const ComponentB = () => {
  const { isOpen, open, close } = useToggle();

  return (
    <>
      <button onClick={open}>Open modal</button>
      <ModalB isOpen={isOpen} onClose={close} />
    </>
  );
};

РЕЗУЛЬТАТ
Навіть у такому простому випадку ми значно скоротили дублювання коду, структурували файли проекту, зробили компоненти
чистішими та спростили майбутній рефактор компоннетів та логіки хука.

Так як хуки це звичайні функції, їм можна передавати аргументи, наприклад для початкового значення стану. 
Розширимо хук useToggle так, щоб можна було зробити модальне вікно спочатку відкритим. За замовчуванням робимо його закритим.

// src/hooks/useToggle.js
export const useToggle = (initialState = false) => {
  const [isOpen, setIsOpen] = useState(initialState);
  const open = () => setIsOpen(true);
  const close = () => setIsOpen(false);
  const toggle = () => setIsOpen(isOpen => !isOpen);

  return { isOpen, open, close, toggle };
};

// MyComponent.jsx
import { useToggle } from "path/to/hooks/useToggle.js";

const MyComponent = () => {
  const { isOpen, open, close } = useToggle(true);

  return (
    <>
      <button onClick={open}>Open modal</button>
      <Modal isOpen={isOpen} onClose={close} />
    </>
  );
};
*/

/**
  |============================
  | Контекст та useContext
  |============================
*/
/* 
Дані передаються зверху вниз через пропси, але це може бути незручно для певних глобальних даних, 
які потрібні багатьом компонентам на різних рівнях у додатку (локалізація, тема оформлення, стан авторизації та ін.).

Контекст забезпечує спосіб передачі даних глибоко по дереву компонентів без необхідності явно передавати пропси в 
проміжні компоненти вручну на кожному рівні.

УВАГА
Не використовуйте контекст, щоб уникнути передачі пропсів на кілька рівнів вниз. 
Цей механізм призначений для вузького спектра завдань.


Функція createContext()
import { createContext } from "react";
const MyContext = createContext(defaultValue);

Створює об'єкт контексту, що містить пару компонентів: <Context.Provider> (постачальник) та <Context.Consumer> (споживач).
Під час рендеру, споживач прочитає поточне значення контексту з найближчого відповідного постачальника вище у дереві компонентів.
Аргумент defaultValue використовується споживачем, якщо в нього немає відповідного постачальника над ним у дереві. На практиці 
можна не вказувати, тому що немає сенсу намагатися отримати доступ до контексту якого немає.

Компонент <Provider>
Дозволяє споживачам підписуватись на зміни контексту. Використовується для створення та передачі контексту.

import { createContext } from "react";
import ReactDOM from "react-dom/client";

const MyContext = createContext(defaultValue);

ReactDOM.createRoot(document.getElementById("root")).render(
  <MyContext.Provider value={/... context value .../}>
    <App />
  </MyContext.Provider>
);

- Приймає проп value - значення контексту, яке буде передано нащадкам-споживачам цього контексту.
- Дозволяє споживачам підписуватись на зміни контексту незалежно від глибини вкладеності.
- Один провайдер може бути пов'язаний із багатьма споживачами.
- Провайдери можуть бути вкладені один в одного.

Хук useContext()
Дозволяє отримати доступ до поточного значення контексту. Отримує поточний контекст із найближчого порівнянного 
<Provider> вище у дереві.

import { createContext, useContext } from "react";
const MyContext = createContext();

const contextValue = useContext(MyContext);
- Очікує єдиний аргумент - посилання на створений контекст.
- Поверне значення контексту найближчого провайдера для цього контексту вище дереві.
- Щоразу, коли оновиться значення контексту, залежний компонент ре-рендерується з новим значенням.

Кастомний хук контексту
Щоразу імпортувати посилання на об'єкт контексту не зручно. Тому робиться кастомний хук для доступу до контексту.

import { createContext, useContext } from "react";
const MyContext = createContext();

// Імпортуємо та використовуємо цей хук у компонентах
export const useMyContext = () => useContext(MyContext);

Контекст користувача
Напишемо контекст для зберігання інформації про поточний стан користувача - статусу логіну та особистої інформації.

userContext.js
import { createContext, useContext } from "react";
export const UserContext = createContext();
export const useUser = () => useContext(UserContext);

Обертаємо провайдером все дерево компонентів. Це можна зробити у компоненті App або прямо в головному файлі index.js.

index.js
import { UserContext } from "path/to/userContext.js";

ReactDOM.createRoot(document.getElementById("root")).render(
  <UserContext.Provider value={{ username: "Mango" }}>
    <App />
  </UserContext.Provider>
);

Додамо компонент меню користувача вкладений у <App>, у ньому будемо отримувати значення контексту та відображати ім'я користувача.

App.jsx
import { UserMenu } from "path/to/UserMenu";

const App = () => {
  return (
    <div>
      <UserMenu />
    </div>
  );
};

Використовуємо наш кастомний хук useUser для доступу до значення контексту.
UserMenu.jsx
import { useUser } from "path/to/userContext.js";

export const UserMenu = () => {
  const { username } = useUser();

  return (
    <div>
      <p>{username}</p>
    </div>
  );
};

Кастомний компонент провайдера
Нині значення контексту не динамічне. Користувач може зареєструватися і розлогінітися, зберігатимемо це в стані компонента. 
Крім цього необхідні методи його зміни. Створимо кастомний компонент провайдера <UserProvider> в якому закриємо логіку 
роботи зі станом.

userContext.jsx

import { createContext, useContext, useState } from "react";
const UserContext = createContext();

export const useUser = () => useContext(UserContext);

export const UserProvider = ({ children }) => {
  const [isLoggedIn, setIsLoggedIn] = useState(false);
  const [username, setUsername] = useState(null);

  const logIn = () => {
    setIsLoggedIn(true);
    setUsername("Mango");
  };

  const logOut = () => {
    setIsLoggedIn(false);
    setUsername(null);
  };

  return (
    <UserContext.Provider value={{ isLoggedIn, username, logIn, logOut }}>
      {children}
    </UserContext.Provider>
  );
};


Обертаємо все дерево компонентів кастомним провайдером. Це можна зробити в компоненті App або прямо в головному файлі index.js.

index.js
import { UserProvider } from "path/to/userContext";
ReactDOM.createRoot(document.getElementById("root")).render(
  <UserProvider>
    <App />
  </UserProvider>
);

У компоненті <App> все також рендерується компонент меню користувача.

App.jsx

import { UserMenu } from "path/to/UserMenu";

const App = () => {
  return (
    <div>
      <UserMenu />
    </div>
  );
};

Використовуємо useUser для доступу до значення контексту користувача.

UserMenu.jsx

import { useUser } from "path/to/userContext";

export const UserMenu = () => {
  const { isLoggedIn, username, logIn, logOut } = useUser();

  return (
    <div>
      {isLoggedIn && <p>{username}</p>}
      {isLoggedIn ? (
        <button onClick={logOut}>Log out</button>
      ) : (
        <button onClick={logIn}>Log in</button>
      )}
    </div>
  );
};

*/

/**
  |============================
  | Хук useRef
  |============================
*/
/* 
Рефи дозволяють отримати прямий доступ до DOM-вузлів або React-елементів із шаблону компонента. 
Вони використовуються якщо необхідно звернутися до імперативних методів та властивостям елемента.
- Фокус елемент під час події, виділення тексту
- Контроль програвання медіаконтенту
- Інтеграція з DOM-бібліотеками
- Доступ до DOM-властивостей, значення яких неможливо отримати по-іншому - розміри елемента, значення скрола тощо.

Створення
Рефи створюються хуком useRef() та прив'язані до React-елементів за допомогою атрибуту ref (скорочення від reference), 
який зберігатиме посилання на DOM-елемент.

import { useRef } from "react";

const App = () => {
  const btnRef = useRef();

  return <button ref={btnRef}>Button with ref</button>;
};

Життєвий цикл рефа
React надає властивості current посилання на DOM-елемент коли компонент монтується та null при розмонтуванні, 
тому значення рефа доступне тільки після монтування.

import { useState, useRef } from "react";

const App = () => {
  const [value, setValue] = useState(0);
  const btnRef = useRef();

// Буде null на першому рендері
// і посиланням на DOM-елемент всі наступні
  console.log(btnRef.current);

  useEffect(() => {
// Ефект виконується після монтування,
// тому завжди буде посиланням на DOM-елемент
    console.log(btnRef.current);
  });

  const handleClick = () => {
// Кліки будуть після монтування,
// тому завжди буде посиланням на DOM-елемент
    console.log(btnRef.current);
  };

  return (
    <>
      <button onClick={() => setValue(value + 1)}>
        Update value to trigger re-render
      </button>
      <button ref={btnRef} onClick={handleClick}>
        Button with ref
      </button>
    </>
  );
};

Відсутність реактивності
Рефи це не стан, тобто вони не реактивні, тому зміна значення рефа не впливає на оновлення компонента і не викликає ре-рендер.

import { useEffect, useRef } from "react";

const App = () => {
  const valueRef = useRef(0);

  useEffect(() => {
// Виконається лише один раз під час монтування. Наступні оновлення значення рефа не викличуть оновлення компонента
    console.log(valueRef.current);
  });

  const handleClick = () => {
    valueRef.current += 1;
  };

  return <button onClick={handleClick}>Click to update ref value</button>;
};

ПОЧАТКОВЕ ЗНАЧЕННЯ
Рефи також можна використовувати як сховище довільних значень, які не змінюються між рендерами компонента та
на нього не впливають. Тому в прикладі хуку useRef передано початкове значення якості current - число 0. 
Ця можливість використовується для класу завдань при створенні складніших компонентів.

const valueRef = useRef(0);

Простий відеоплеєр
Створимо компонент Player для програвання відео, використовуючи нативний тег <video>. 
Щоб запустити та зупинити програвання необхідно викликати методи HTMLMediaElement.play() та HTMLMediaElement.pause(), 
де HTMLMediaElement це елемент <video>. Використовуємо реф для отримання доступу до DOM-елементу та його методам.

import { useRef } from "react";

const Player = ({ source }) => {
  const playerRef = useRef();
  const play = () => playerRef.current.play();
  const pause = () => playerRef.current.pause();

  return (
    <div>
      <video ref={playerRef} src={source}>
        Sorry, your browser does not support embedded videos.
      </video>
      <div>
        <button onClick={play}>Play</button>
        <button onClick={pause}>Pause</button>
      </div>
    </div>
  );
};

const App = () => {
  return <Player source="<http://media.w3.org/2010/05/sintel/trailer.mp4>" />;
};


Перенаправлення рефів
При використанні рефів на компоненті, проп ref не передається автоматично. 
Це створює проблеми у випадку коли ми хочемо отримати ref на елемент усередині самого компонента, 
а не на сам компонент. Функція forwardRef автоматично передає пропси, отримані батьківським компонентом його дочірнім елементам.

import { forwardRef, useRef, useEffect } from "react";

const CustomButton = forwardRef((props, ref) => (
  <button ref={ref}>{props.children}</button>
));

const App = () => {
  const btnRef = useRef();

  useEffect(() => btnRef.current.focus(), []);

  return <CustomButton ref={btnRef}>Button with forwarded ref</CustomButton>;
};

Такий підхід дозволяє отримати посилання у батьківському компоненті на DOM-елемент усередині іншого компонента. 
Наприклад, ви створюєте галерею, так можна отримати посилання на DOM-елементи поза них і працювати з їх властивостями, 
наприклад використовувати метод Element.getBoundingClientRect() і тому подібне.
*/

/**
  |============================
  | Хук useMemo
  |============================
*/
/* 
Іноді компонентам доводиться виконувати дорогі обчислення. Наприклад, при роботі з великим списком співробітників 
компанії та пошуковим запитом, компонент повинен фільтрувати імена співробітників на запит. У таких випадках можна 
спробувати покращити продуктивність компонента за допомогою мемоізації.

МЕМОІЗАЦІЯ
Метод оптимізації, який використовується для прискорення комп'ютерних програм шляхом збереження результатів викликів 
функції та повернення кешованого результату при повторенні тих самих вхідних даних. Мемоізована функція «запам'ятовує» 
результат обчислень відповідний набору аргументів. Наступні виклики з такими самими значеннями аргументів повертають 
запам'ятаний результат, а не перераховують його.

Хук useMemo() використовує концепцію мемоізації, тобто повертає пам'ятний (кешований) результат обчислень. 
Це може покращити продуктивність програми, якщо використовується для запобігання дорогим обчисленням на кожному рендері.

const memoizedValue = React.useMemo(
// compute
  () => computeExpensiveValue(a, b),
// deps
  [a, b]
);

Хук приймає два аругменти - анонімну функцію, яка має повернути значення (compute), саме вона буде мемоізована, 
і масив залежностей (deps). Якщо масив залежностей не вказаний, значення обчислюватиметься на кожному рендері, 
що повністю анулює зміст використання useMemo().

При першому рендері компонента викликається функція (compute), запам'ятовується її результат та повертається як 
результат роботи хука. Якщо за наступних рендерів залежності не змінюються, то хук не викликає функції, 
а просто повертає збережений результат роботи. Якщо будь-яка залежність змінилася, то хук викликає функцію заново, 
запам'ятовує нове значення та повертає його.

ПІДВЕДЕМО ПІДСУМКИ
1. Мемоізація це кешування значення, щоб його не потрібно було перераховувати.
2. Мемоізацію варто використовувати лише для дорогих обчислень.
3. useMemo() виконує обчислення значення хоча б один раз.
4. useMemo() повертає запам'ятоване значення.
5. useMemo() запускає повторне обчислення тільки при оновленні якоїсь із залежностей.
6. Обов'язково необхідно передати залежності, інакше немає сенсу використовувати useMemo().

Є дві проблеми, які useMemo() допомагає вирішити:
- Посилальна ідентичність
- Дорогі обчислення

Розберіть код наступного прикладу, де може зберігатися масив рядків і значення пошукового запиту Опустимо код додавання 
елементів до масиву та змінення значення запиту.

const App = () => {
  const [planets, setPlanets] = useState(["Earth", "Mars", "Jupiter", "Venus"]);
  const [query, setQuery] = useState("");

  const filteredPlanets = planets.filter(planet => planet.includes(query));

  return (
    <div>
      {filteredPlanets.map(planet => (
        <div key={planet}>{planet}</div>
      ))}
    </div>
  );
};


Щоразу коли зміниться значення planets або query компонент буде відрендерен заново, а значить буде перераховано значення 
filteredPlanets. І це абсолютно нормально! У такому разі не потрібна жодна мемоізація.

А тепер уявіть, що компонент <App> містить додатковий стан або отримує якийсь пропс, який ніяк не впливає на планети.

const App = ({ someProp }) => {
  const [planets, setPlanets] = useState(["Earth", "Mars", "Jupiter", "Venus"]);
  const [query, setQuery] = useState("");
  const [clicks, setClicks] = useState(0);

  const filteredPlanets = planets.filter(planet => planet.includes(query));

  return (
    <div>
      <div>Some prop: {someProp}</div>
      <button onClick={() => setClicks(clicks + 1)}>
        Number of clicks: {clicks}
      </button>
      <div>
        {filteredPlanets.map(planet => (
          <div key={planet}>{planet}</div>
        ))}
      </div>
    </div>
  );
};

Щоразу коли зміниться стан clicks або проп someProp, компонент буде відрендерен повторно, що призведе до обчислення 
filteredPlanets, хоча значення planets та query не змінилися! Оскільки метод filter поверне посилання на новий масив, 
React сприйме це як абсолютно нові дані та список планет буде відмальовано заново. У такому разі варто мемоізувати 
обчислення filteredPlanets.

import { useMemo } from "react";

const App = ({ someProp }) => {
  const [planets, setPlanets] = useState(["Earth", "Mars", "Jupiter", "Venus"]);
  const [query, setQuery] = useState("");
  const [clicks, setClicks] = useState(0);

  const filteredPlanets = useMemo(
    () => planets.filter(planet => planet.includes(query)),
    [planets, query]
  );

  return (
    <div>
      <div>Some prop: {someProp}</div>
      <button onClick={() => setClicks(clicks + 1)}>
        Number of clicks: {clicks}
      </button>
      <div>
        {filteredPlanets.map(planet => (
          <div key={planet}>{planet}</div>
        ))}
      </div>
    </div>
  );
};

Те ж саме з дорогими операціями, наприклад, використання довгого циклу for. Дорогі обчислення можуть бути витратними 
за часом, що гарантовано призведе до погіршення роботи інтерфейсу.

БІЛЬШЕ НЕ ОЗНАЧАЄ КРАЩЕ
Не потрібно мемоізувати все поспіль, це може призвести до втрати продуктивності, оскільки мемоізація теж займає 
обчислювальні ресурси. Найчастіше повторні прості обчислення обійдуться дешевше ніж їхня мемоїзація. Використовуйте 
useMemo() точково, в першу чергу при роботі з масивами та для дорогих обчислень.
*/
/**
  |============================
  | Маршрутизація
  |============================
*/
/* 
Відмінна перевага веб-застосунку від десктопного це наявність URL при переході по якому користувач опиняється у певної 
частини програми. Так можна зберегти закладку або надіслати посилання іншому користувачеві, при цьому йому буде відображено 
той самий інтерфейс (за винятком приватних даних).

В ПЕРШУ ЧЕРГУ
Маршрутизація це не побічний ефект при написанні програми, навпаки, структуру навігації та набір сторінок необхідно 
продумувати в першу чергу.

Структура URL-рядка
Аналогією URL-рядка може бути адреса за якою ви проживаєте: вулиця, будинок, квартири. 
Кожен стан інтерфейсу повинен мати свою адресу, свій URL. Те, що бачить користувач, стан інтерфейсу, має бути описано в URL.

Розберемо з яких частин може складатися будь-який URL.

https:// - протокол
mysite.com/ - хост
books/e3q76gm9lzk - шлях, то, де ми знаходимося у додатку
e3q76gm9lzk - url-параметр. Параметри бувають динамічними або статичними
? - символ початку рядка запиту
?category=adventure&status=unread - рядок запиту
category=adventure - пара параметр=значення
& - символ "І", розділяє параметри рядка запиту
#comments - якір (хеш), визначає положення на сторінці


Історія навігації
Історія навігації описує, як ми переходимо по маршрутах (посиланням) додатків в поточній вкладці браузера, і, як ці 
переходи зберігаються та обробляються. Уявіть стопку листів, щоразу коли ми переходимо за посиланням, на верх стопки 
додається ще один лист з інформацією. Це називається стек історії. Використовуючи властивості та методи HTML5 History API, 
ми можемо переходити назад і вперед з історії користувача та маніпулювати її вмістом.

HTML5 HISTORY API
Якщо ви хочете глибше зрозуміти React Router, після знайомства з основними концепціями рекомендуємо повернутися та 
розібрати статтю A Little Bit of History.

Маршрутизація в React
У React немає вбудованого модуля маршрутизації, тому використовується React Router - Бібліотека маршрутизації для React. 
Так само, як React надає нам набір примітивів для створення інтерфейсу користувача та роботи зі станом, React Router надає 
набір компонентів та хуків для створення маршрутизації, управління історією навігації користувача та відображення різних 
компонетів в залежності від поточного значення URL в адресному рядку браузера.

npm install react-router-dom
*/
/**
  |============================
  | Компонент <BrowserRouter>
  |============================
*/
/* 
Компонент <BrowserRouter>

- Командний центр управління маршрутизацією, який приховує в собі всю логіку взаємодії із історією браузера. 
- Створює маршуртизатор та об'єкт історії навігації, щоб синхронізувати інтерфейс із URL-адресою. 
- Використовуючи React контекст передає інформацію про поточний стан історії навігації всім нащадкам. 
- Все, що необхідно зробити, це обернути компонентом <BrowserRouter> всі програми.

index.js
import { BrowserRouter } from "react-router-dom";

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>
);
*/
/**
  |============================
  | Компоненти <Route> та <Routes>
  |============================
*/
/* 
Компонент <Route> дозволяє пов'язати певний URL з деяким компонентом. 
Наприклад, якщо ми хочемо відображати компонент <About> коли користувач переходить шляхом /about, 
необхідно буде описати такий маршрут.

<Route path="/about" element={<About />} />

Значенням пропсу element може бути будь-який валідний JSX, але на практиці використовують лише компоненти.

ЯК ЦЕ ПРАЦЮЄ
Компонент <Route> завжди щось рендерить. Те, що зазначено у пропсі element якщо його path збігається з поточним 
значенням сегмента pathname в адресному рядку браузера, або null, якщо не збігається.

Маршрутів може бути довільна кількість, як мінімум по одному на кожну сторінку програми. 
Припустимо ми створюємо додаток магазину одягу, тому опишемо маршрути трьох сторінок.

App.jsx

import { Routes, Route } from "react-router-dom";
import Home from "path/to/pages/Home";
import About from "path/to/pages/About";
import Products from "path/to/pages/Products";

export const App = () => {
  return (
    <div>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/products" element={<Products />} />
      </Routes>
    </div>
  );
};

Групу маршрутів обов'язково має обертати компонент <Routes>, навіть якщо маршрут лише один. 
Тобто <Route> не може використовуватися без <Routes>. Цей компонент виконує логіку підбору найбільш відповідного 
<Route> для поточного значення URL в адресному рядку браузера.

КОМПОНЕНТИ СТОРІНОК
Ви вже знаєте, що конвенція структури файлів програми передбачає зберігання всіх компонентів у папці src/components. 
Компонент сторінки це звичайнісінький React-компонент, який містить у собі розмітку цілої сторінки вашої програми. 
Для зручності та структурованості такі компоненти зберігаються окремо від усіх, у папці src/pages.

Сторінка помилки навігації
Що буде, якщо користувач перейде за посиланням /non-existing-route або будь-якому іншому, якого немає в нашому додатку? 
Він побачить порожню вкладку браузера, без будь-якого контенту, оскільки жоден з описаних нами <Route> не підійде. 
Для цього до кінця списку маршрутів додамо ще один <Route>, який збігатиметься з будь-яким URL, але він буде обраний 
тільки в тому випадку, якщо жоден інший маршрут не підійде.

import { Routes, Route } from "react-router-dom";
import Home from "path/to/pages/Home";
import About from "path/to/pages/About";
import Products from "path/to/pages/Products";
import NotFound from "path/to/pages/NotFound";

const App = () => {
  return (
    <div>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/products" element={<Products />} />
        <Route path="*" element={<NotFound />} />
      </Routes>
    </div>
  );
};

Символ * у пропсі path буквально вказує на те, що цей маршрут може збігатися з будь-яким значенням URL. 
Тому якщо жоден попередній <Route> не підійде, останній точно відобразить користувачеві сторінку з якимось 
повідомленням про те, що маршруту яким він перейшов, не існує.
*/

/**
  |============================
  | <Link> та <NavLink>
  |============================
*/
/* 
Тепер розглянемо, як створювати посилання на різні сторінки нашої програми. 
Для створення навігації не можна використовувати звичайний тег <a href="/about">. 
При кліку, замість того щоб змінити URL на поточній сторінці, і дозволити маршрутизатору виконати навігацію 
на стороні клієнта, браузер перезавантажить сторінку.

Для створення посилань використовуються компоненти <Link> та <NavLink>. Вони рендерять тег <a>, але стандартна 
поведінка посилання змінена так, що при натисканні просто оновлюється URL в адресному рядку браузера, без 
перезавантаження сторінки.

<nav>
  <Link to="/">Home</Link>
  <Link to="/about">About</Link>
  <Link to="/products">Products</Link>
</nav>

Компонент <NavLink> відрізняється тільки тим, що може мати додаткові стилі, якщо поточний URL збігається зі 
значенням пропcа to. За замовчуванням елементу активного посилання додається клас active. Це можна використовувати 
для її стилізації.

App.jsx

import { Routes, Route, NavLink } from "react-router-dom";
import styled from "styled-components";
import Home from "path/to/pages/Home";
import About from "path/to/pages/About";
import Products from "path/to/pages/Products";

const StyledLink = styled(NavLink)`
  color: black;

  &.active {
    color: orange;
  }
`;

export const App = () => {
  return (
    <div>
      <nav>
        <StyledLink to="/" end>
          Home
        </StyledLink>
        <StyledLink to="/about">About</StyledLink>
        <StyledLink to="/products">Products</StyledLink>
      </nav>

      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/products" element={<Products />} />
      </Routes>
    </div>
  );
};
*/

/**
  |============================
  | URL-параметри
  |============================
*/
/* 
Динамічні параметри схожі на параметри функції - у них завжди одна назва, але можуть бути різні значення. 
Вони дозволяють оголосити шаблон адреси, частини якого можуть мати довільне значення. 
Наприклад, немає сенсу визначати окремий маршрут для кожного посту у блозі, їх можуть бути тисячі. 
За структурою контенту такі сторінки будуть ідентичні, а відрізнятиметься лише назва, зображення, автор, текст тощо. 
Замість того, щоб визначати маршрут для кожної статті, ми можемо оголосити один маршрут з динамічним параметром 
по якому визначатимемо яку посаду необхідно відображати саме зараз. Для того, щоб вказати, що якась частина адреси це 
URL-параметр, використовується двокрапка (:) перед іменем параметра.

<Route path="/blog/:postId" element={<BlogPost />} />

Кожного разу, коли користувач буде відвідувати адресу, що відповідає шаблону /blog/:postId, наприклад 
/blog/react-fundamentals або /blog/top-5-css-tricks, йому відображатиметься сторінка цього поста.

ІМ'Я ПАРАМЕТРА
Ім'я URL-параметра може бути довільним, але воно має значення і має бути зрозумілим та описовим. Далі ми розглянемо, 
як отримувати значення URL-параметра. Спойлер - по його імені.

Додамо до нашої програми маршрут сторінки одного продукту з адресою /products/:productId. Це окрема сторінка, 
ніяк не прив'язана до /products - сторінці відображення всіх продуктів.

App.jsx

import { Routes, Route, Link } from "react-router-dom";
import Home from "path/to/pages/Home";
import About from "path/to/pages/About";
import Products from "path/to/pages/Products";
import NotFound from "path/to/pages/NotFound";
import ProductDetails from "path/to/pages/ProductDetails";

export const App = () => {
  return (
    <div>
      <nav>
        <Link to="/">Home</Link>
        <Link to="/about">About</Link>
        <Link to="/products">Products</Link>
      </nav>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/products" element={<Products />} />
        <Route path="/products/:productId" element={<ProductDetails />} />
        <Route path="*" element={<NotFound />} />
      </Routes>
    </div>
  );
};

УНІКАЛЬНІСТЬ ЗНАЧЕННЯ
Значення URL-параметра має бути унікальним всередині колекції, тому частіше всього використовують ідентифікатори 
об'єктів, які встановлює база даних (числа або рядки). Тому адреса може виглядати, наприклад, як /products/1, 
/proudcts/2 і так далі.

--- Хук useParams ---

Повертає об'єкт з усіма динамічними параметрами, які є в поточному URL. Ім'я параметра буде ім'ям властивості 
в об'єкті, а його поточне значення в адресі - значенням властивості. Наприклад, якщо оголошено наступний маршрут 
/books/:genreId/:authorName, та користувач знаходиться за адресою /books/adventure/herman-melville.

const { genreId, authorName } = useParams();
console.log(genreId, authorName);// adventure, herman-melville

Для того, щоб отримати значення динамічної частини URL, у нашому випадку ідентифікатор продукту, 
використовуємо хук useParams у компоненті сторінки продукту.

src/pages/ProductDetails.jsx

import { useParams } from "react-router-dom";

const ProductDetails = () => {
  const { productId } = useParams();
  return <div>Now showing product with id - {productId}</div>;
};

ЩО ДАЛІ?
Маючи значення параметра можна, наприклад, зробити запит на бекенд та отримати повну інформацію про продукт 
за його ідентифікатором, після чого відрендерити розмітку сторінки.
*/
/**
  |============================
  | Вкладені маршрути
  |============================
*/
/* 
Вкладені маршрути дозволяють описувати логіку «підсторінок», тобто якийсь URL по якому крім батьківського компонента 
цілої сторінки буде відображатися ще якийсь дочірній, вкладений компонент.

Наприклад, нам необхідно щоб на /about/mission, /about/team та /about/reviews крім контенту сторінки «Про нас» 
відображалася ще якась додаткова, більш специфічна інформація. Нехай це буде кілька різноманітних компонентів: 
стаття про місію нашої компанії, галерея з інформацією про співробітників та відгуки користувачів.

// ❌ Неправильно
<Route path="/about" element={<About />} />
<Route path="/about/mission" element={<Mission />} />
<Route path="/about/team" element={<Team />} />
<Route path="/about/reviews" element={<Reviews />} />

Якщо описати маршрути так, то отримаємо чотири незалежні сторінки. На /about буде відображатися лише сторінка інформації, 
а, наприклад, на about/team галерея співробітників, це не те, що нам потрібно. Використовуємо синтаксис оголошення 
вкладеного маршруту, компонент якого відображатиметься всередині батьківської сторінки.

// ✅ Правильно
<Route path="/about" element={<About />}>
  <Route path="mission" element={<Mission />} />
  <Route path="team" element={<Team />} />
  <Route path="reviews" element={<Reviews />} />
</Route>

Зверніть увагу на кілька особливостей:
- Ми декларативно вклали дочірні маршрути всередину батьківського <Route>. Саме такий синтаксис вказує на вкладений 
маршрут, компонент якого буде відображатися десь усередині батьківського компонента.
- Значення пропсу path у вкладеного маршруту вказується відносно батьківського, саме тому ми передали значення path="mission", 
а не повний шлях path="/about/mission".
- Відносні шляхи записуються без провідного символу /, тобто path="mission", а не path="/mission". Якщо додати слеш, 
то ми навпаки створимо окремий маршрут /mission та зламаємо логіку маршрутизації.

Повна конфігурація маршрутів нашої програми виглядатиме так.

App.jsx

import { Routes, Route, Link } from "react-router-dom";
import Home from "path/to/pages/Home";
import About from "path/to/pages/About";
import Products from "path/to/pages/Products";
import NotFound from "path/to/pages/NotFound";
import ProductDetails from "path/to/pages/ProductDetails";
import Mission from "path/to/components/Mission";
import Team from "path/to/components/Team";
import Reviews from "path/to/components/Reviews";

export const App = () => {
  return (
    <div>
      <nav>
        <Link to="/">Home</Link>
        <Link to="/about">About</Link>
        <Link to="/products">Products</Link>
      </nav>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />}>
          <Route path="mission" element={<Mission />} />
          <Route path="team" element={<Team />} />
          <Route path="reviews" element={<Reviews />} />
        </Route>
        <Route path="/products" element={<Products />} />
        <Route path="/products/:productId" element={<ProductDetails />} />
        <Route path="*" element={<NotFound />} />
      </Routes>
    </div>
  );
};

Останнє, що обов'язково необхідно зробити, це вказати де саме в компоненті батьківського маршруту <About> ми хочемо 
рендерувати дочірні маршрути. Для цього у React Router є компонент <Outlet>.

src/pages/About.jsx

import { Link, Outlet } from "react-router-dom";

export const About = () => {
  return (
    <div>
      <h1>About page</h1>
      <ul>
        <li>
          <Link to="mission">Read about our mission</Link>
        </li>
        <li>
          <Link to="team">Get to know the team</Link>
        </li>
        <li>
          <Link to="reviews">Go through the reviews</Link>
        </li>
      </ul>
      <Outlet />
    </div>
  );
};

Якщо поточний URL в адресному рядку браузера збігається зі значенням пропсу path вкладеного маршруту, 
<Outlet> відрендерить його компонент, інакше він рендерить null та не впливає на розмітку батьківського компонента.

ВІДНОСНІ ПОСИЛАННЯ
Зверніть увагу на значення пропсу to компонента <Link>. Так само, як і path вкладеного маршруту, значення пропсу to 
вкладених посилань вказується відносно поточного URL. Компонент <About> рендерується на адресу /about, тому посилання 
з to="mission" буде вести на /about/mission. Якщо необхідно зробити посилання на іншу сторінку, тоді вказуйте шлях повністю, 
наприклад to="/products".
*/

/**
  |============================
  | Індексні маршрути
  |============================
*/
/* 
Розібравшись із вкладеними маршрутами, ми можемо розглянути прийом «shared layout», який полягає в тому, що якась 
загальна HTML-розмітка та стилі всього або частини сторінок програми виносяться в окремий компонент, замість того щоб 
дублюватися на кожній сторінці. У нашому додатку магазину це хедер з логотипом та головною навігацією, а також контейнер, 
що обмежує ширину контенту сторінок.

src/components/App.jsx

// Imports

export const App = () => {
  return (
    <Container>
      <Header>
        <Logo>
          <span role="img" aria-label="computer icon">
            💻
          </span>{" "}
          GoMerch Store
        </Logo>
        <nav>
          <Link to="/">Home</Link>
          <Link to="/about">About</Link>
          <Link to="/products">Products</Link>
        </nav>
      </Header>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />}>
          <Route path="mission" element={<Mission />} />
          <Route path="team" element={<Team />} />
          <Route path="reviews" element={<Reviews />} />
        </Route>
        <Route path="/products" element={<Products />} />
        <Route path="/products/:productId" element={<ProductDetails />} />
      </Routes>
    </Container>
  );
};

Винесемо цю розмітку та її стилі в окремий компонент <SharedLayout>. 
Зверніть увагу на використання та місце розташування <Outlet> - у це місце буде рендетися розмітка компонентів сторінок.

src/components/SharedLayout.jsx

// Imports
import { Outlet } from "react-router-dom";

export const SharedLayout = () => {
  return (
    <Container>
      <Header>
        <Logo>
          <span role="img" aria-label="computer icon">
            💻
          </span>{" "}
          GoMerch Store
        </Logo>
        <nav>
          <Link to="/">Home</Link>
          <Link to="/about">About</Link>
          <Link to="/products">Products</Link>
        </nav>
      </Header>
      <Outlet />
    </Container>
  );
};

Далі використовуємо цей компонент у <App> так щоб він рендерився на будь-який маршрут. Для цього будемо рендерувати його 
на /, а всі інші маршрути робимо вкладеними в нього, тому змінимо path всіх вкладених маршрутів відносно батьківського.

src/components/App.jsx

// Imports
import { SharedLayout } from "path/to/components/SharedLayout";

export const App = () => {
  return (
    <Routes>
      <Route path="/" element={<SharedLayout />}>
        <Route path="about" element={<About />}>
          <Route path="mission" element={<Mission />} />
          <Route path="team" element={<Team />} />
          <Route path="reviews" element={<Reviews />} />
        </Route>
        <Route path="products" element={<Products />} />
        <Route path="products/:productId" element={<ProductDetails />} />
      </Route>
    </Routes>
  );
};

У вас може виникнути справедливе питання, куди зник компонент <Home> який раніше рендерився на path="/".
Проблема в тому, що зараз на /about рендериться <SharedLayout> та <About>, а на / тільки <SharedLayout>. Для того, щоб 
відрендерити компонент <Home> на той же маршрут, на який рендериться його батько, необхідно зробити «індексний маршрут».

src/components/App.jsx

// Imports
import { SharedLayout } from "path/to/components/SharedLayout";

export const App = () => {
  return (
    <Routes>
      <Route path="/" element={<SharedLayout />}>
        <Route index element={<Home />} />
        <Route path="about" element={<About />}>
          <Route path="mission" element={<Mission />} />
          <Route path="team" element={<Team />} />
          <Route path="reviews" element={<Reviews />} />
        </Route>
        <Route path="products" element={<Products />} />
        <Route path="products/:productId" element={<ProductDetails />} />
      </Route>
    </Routes>
  );
};

ЯК ЦЕ ПРАЦЮЄ
Індексним може бути лише вкладений маршрут. В його <Route> не вказується пропс path, тому що він збігається зі значенням 
path батька. Замість цього передається спеціальний пропс index, який вказує React Router, що маршрут індексний і повинен 
бути відрендерений на ту ж адресу, що і його батько.

Індексних маршрутів може бути скільки завгодно, все залежить від завдання. 
Наприклад, якби у нас у додатку були сторінки панелі адміністратора, на яких зовсім інші загальні компоненти інтерфейсу, 
то структуру маршрутів можна було б спроектувати наступним чином.

<Routes>
  <Route path="/" element={<SharedLayout />}>
    <Route index element={<Home />} />
    <Route path="about" element={<About />}>
      <Route path="mission" element={<Mission />} />
      <Route path="team" element={<Team />} />
      <Route path="reviews" element={<Reviews />} />
    </Route>
    <Route path="products" element={<Products />} />
    <Route path="products/:productId" element={<ProductDetails />} />
  </Route>
  <Route path="/admin" element={<AdminLayout />}>
    <Route index element={<Dashboard />} />
    <Route path="sales" element={<Sales />} />
    <Route path="customers" element={<Customers />} />
  </Route>
</Routes>
*/

/**
  |============================
  | Програмна навігація
  |============================
*/

/* 
React Router дозволяє виконати навігацію не тільки при натисканні на Link, але й щодо певної дії користувача, події чи ефекту. 
Наприклад, при натискання на кнопку, після відправлення форми, за результатом HTTP-запиту і тому подібне. 
Наприклад використовуємо процес логіна користувача в додаток. Після надсилання форми на сторінці логіну ми виконуємо 
навігацію на сторінку профілю користувача, але тільки якщо HTTP-запит був успішним.

Перший спосіб це хук useNavigate. Він надає нам функцію navigate якій під час виклику передаємо шлях, куди необхідно 
виконати навігацію. Цей спосіб імперативний, але більш гнучкий і вимагає менше коду.

src/pages/Login.jsx

import { useNavigate } from "react-router-dom";

export const Login = () => {
  const navigate = useNavigate();

  const handleSubmit = async values => {
    const response = await FakeAPI.login(values);
    if (response.success) {
      navigate("/profile", { replace: true });
    }
  };

  return (
    <div>
      <h1>Login page</h1>
      <LoginForm onSubmit={handleSubmit} />
    </div>
  );
};

ОБ'ЄКТ ПАРАМЕТРІВ
Зверніть увагу на другий, необов'язковий аргумент функції navigate - це об'єкт параметрів. Властивість replace, 
за замовчуванням false, контролює як буде додано новий запис на стек історії. Повернемося до аналогії зі стопкою паперів. 
За замовчуванням новий аркуш буде додано на гору стопки, що ніяк не вплине на решту листів. Якщо вказати значення true, 
то новий лист підмінить собою найвищий. Це використовується досить рідко, наприклад при логіні, щоб користувач не зміг 
повернутися кнопкою «назад» на сторінку логіна після входу, адже він уже в системі і робити йому там нічого.

Другий спосіб це компонент Navigate - обгортка над хуком useNavigate. Він виконує навігацію у момент рендеру. 
Шлях для навігації та необов'язкові параметри передаються окремими пропсами. Такий спосіб більш декларативний, але менш 
гнучкий і вимагає більше коду.

src/pages/Login.jsx

import { Navigate, useState } from "react-router-dom";

export const Login = () => {
  const [isLoginSuccess, setIsLoginSuccess] = useState(false);

  const handleSubmit = async values => {
    const response = await FakeAPI.login(values);
    setIsLoginSuccess(response.success);
  };

  if (isLoginSuccess) {
    return <Navigate to="/profile" replace />;
  }

  return (
    <div>
      <h1>Login page</h1>
      <LoginForm onSubmit={handleSubmit} />
    </div>
  );
};

ЩО КРАЩЕ?
Який спосіб використовувати залежить тільки від ваших уподобань та вимог поставленого завдання. 
В одному випадку вам буде зручно використовувати декларативний Navigate, в іншому - імперативний useNavigate.
*/

/**
  |============================
  | Рядок запиту
  |============================
*/
/* 
Рядок запиту та його параметри це фундаментальний аспект Інтернету, оскільки він дозволяє передавати стан програми 
через URL-адресу. Рядок запиту додається до основного URL, починається символом ? і містить один або більше параметрів 
у форматі «ключ-значення» розділених символом &.

<https://gomerch.it/products?name=hoodie&color=orange&maxPrice=500>

Такий рядок запиту містить три параметри та їх значення: назва продукту, колір та максимальну ціну. 
При переході на цю URL, користувач побачить відповідний, фільтрований список продуктів.

Розглянемо роботу з рядком запиту та його параметрами на прикладі каталогу продуктів, за яким користувач може виконати 
пошук за назвою та бачити відфільтрований список збігів.

Використання локального стану через хук useState добре для одного користувача, але погано для спільної роботи з іншими 
користувачами. Якщо стан програми знаходиться в URL, ним можна поділитися з іншими користувачами. Наприклад, коли 
користувач шукає продукти, значення пошуку додається до URL як параметр рядка запиту (/products?name=hoodie). 
Інший користувач, який отримав це посилання, побачить той же фільтрований список продуктів на своїй сторінці, тому що всі 
дані, необхідні додатку для правильного відображення інтерфейсу, що знаходяться прямо в URL.

Вилучення параметрів
Для читання та зміни рядка запиту у React Router є хук useSearchParams, який є невеликою обгорткою над вбудованим 
у браузер класом [URLSearchParams]

const [searchParams, setSearchParams] = useSearchParams();
Він повертає масив із двох значень: об'єкт параметрів рядка запиту (примірник URLSearchParams) для поточного URL та функцію 
оновлення рядка запиту. Для отримання значень параметрів є метод URLSearchParams.get(key), який чекає на ім'я параметра 
і повертає його значення або null якщо у рядку запиту немає такого параметра.

src/pages/Products.jsx

import { useSearchParams } from "react-router-dom";

const Products = () => {
  const [searchParams] = useSearchParams();
  const name = searchParams.get("name");
  const color = searchParams.get("color");
  const maxPrice = searchParams.get("maxPrice");

  return (
    <div>
      <p>Name: {name}</p>
      <p>Color: {color}</p>
      <p>Maximum price: {maxPrice}</p>
    </div>
  );
};

Тип значень
Метод get() завжди поверне рядок незалежно від значення параметра, яке вказано у рядку запиту. 
Наприклад, для такого рядка запиту ?name=hoodie&maxPrice=500&inStock=true ми отримаємо такі значення параметрів.

const [searchParams] = useSearchParams();

const name = searchParams.get("name");
console.log(name, typeof name);// "hoodie", string

const maxPrice = searchParams.get("maxPrice");
console.log(maxPrice, typeof maxPrice);// "500", string

const inStock = searchParams.get("inStock");
console.log(inStock, typeof inStock);// "true", string

ПРИВЕДЕННЯ ТИПІВ
Якщо параметри це числа чи були, для отримання значення правильного типу потрібно виконати приведення типів. 
Це можна зробити вбудованими класами Number(value) та Boolean(value).

Параметри як об'єкт
Якщо рядок запиту містить кілька параметрів, постійно використовувати метод get() може бути незручно. 
Ось простий спосіб перетворити екземпляр класу URLSearchParams у звичайний об'єкт із властивостями.

const [searchParams] = useSearchParams();
const params = useMemo(
  () => Object.fromEntries([...searchParams]),
  [searchParams]
);
const { name, maxPrice, inStock } = params;

МЕМОІЗАЦІЯ
Мемоізуємо операцію перетворення об'єкта параметрів, щоб отримувати посилання на новий об'єкт лише якщо зміняться 
параметри рядка запиту, а не при кожному рендері компоненту.

Зміна рядка запиту
Для зміни параметрів використовуємо функцію, яку useSearchParams повертає другим елементом масиву. 
Їй необхідно передати об'єкт нових параметрів, який повністю замінить поточний рядок запиту.

import { useSearchParams } from "react-router-dom";

export const Products = () => {
  const [searchParams, setSearchParams] = useSearchParams();
  const name = searchParams.get("name");

  return (
    <div>
      <h1>Products</h1>
      <input
        type="text"
        value={name}
        onChange={e => setSearchParams({ name: e.target.value })}
      />
    </div>
  );
};

Відстеження змін
Якщо змінюється рядок запиту, хук useSearchParams повертає нове значення параметрів і компонентів оновлюється, 
тому можна зреагувати на це і запустити ефект.

const App = () => {
  const [user, setUser] = useState(null);
  const [searchParams, setSearchParams] = useSearchParams();
  const username = searchParams.get("username");

  useEffect(() => {
    // Тут виконуємо асинхронну операцію,
    // наприклад HTTP-запит за інформацією про користувача
    if (username === "") return;

    async function fetchUser() {
      const user = await FakeAPI.getUser(username);
      setUser(user);
    }

    fetchUser();
  }, [username]);

  const handleSubmit = e => {
    e.preventDefault();
    const form = e.currentTarget;
    setSearchParams({ username: form.elements.username.value });
    form.reset();
  };

  return (
    <>
      <form onSubmit={handleSubmit}>
        <input type="text" name="username" />
        <button type="submit">Search</button>
      </form>
      {user && <UserInfo user={user} />}
    </>
  );
};

*/

/**
  |============================
  | Об'єкт місцезнаходження
  |============================
*/

/* 
Кожен запис у стеку історії навігації описаний об'єктом розташування (location) зі стандартним набором властивостей, 
які зберігають повну інформацію про URL. Коли користувач натискає на посилання та переміщається за програмою, поточне 
місце розташування змінюється і додається новий запис історії.

{
  pathname: string;
  search: string;
  hash: string;
  state: any;
  key: string;
}

- pathname - рядок, що містить частину URL від початкового / і до символу ?.
- search - містить весь рядок запиту. Якщо параметри відсутні, значенням буде порожній рядок.
- hash - рядок, що містить частину URL від кінця рядка запиту та символу #, за яким слідує ідентифікатор фрагмента URL-адреси. 
Якщо ідентифікатор фрагмента відсутній, значенням буде порожній рядок.
- state - довільне значення, яке містить додаткову інформацію, пов'язану з розташуванням, але не відображається в URL-адресі. 
Задається розробником. Використовується для передачі між маршрутами.
- key - унікальний рядок ідентифікатор, пов'язаний із цим місцезнаходженням. Службова властивість, значення якої 
задається автоматично для кожного нового запису в історії навігації.

Наприклад, для такого URL об'єкт розташування буде виглядати наступним чином.

// <https://gomerch.it/products?name=hoodie&color=orange&maxPrice=500#agreement>

{
  "pathname": "/products",
  "search": "?name=hoodie&color=orange&maxPrice=500",
  "hash": "#agreement",
  "state": null,
  "key": "random-browser-generated-id"
}

Хук useLocation
Повертає об'єкт розташування, що представляє поточний URL, щоразу коли ми переходимо новим маршрутом або оновлюємо частину 
поточного URL. Одним із застосувань може бути завдання, де необхідно виконати якийсь ефект при зміні поточного розташування. 
Наприклад, надіслати дані на сервіс аналітики.

src/component/App.jsx

import { useEffect } from "react";
import { useLocation } from "react-router-dom";
import Analytics from "path/to/analytics-service";

const App = () => {
  const location = useLocation();

  useEffect(() => {
    Analytics.send(location);
  }, [location]);

  return <div>...</div>;
};

Властивість location.state
Уявіть наступний сценарій у нашому додатку магазину. Користувач знаходиться на сторінці списку продуктів та виконав пошук 
за назвою, нехай поточний URL буде /products?name=hoodie. Після цього він кликає за карткою продукту та переходить 
на сторінку розширеної інформації про продукт, нехай поточний URL буде /products/h-1.

Нам поставлено завдання додати на сторінку продукту кнопку «Назад», при натисканні на яку виконається навігація на сторінку 
всіх продуктів, при цьому має зберегти стан рядка запиту. Тобто, при натисканні, користувача необхідно направити не на /products,
а в нашому випадку на /products?name=hoodie - той URL з якого була виконана навігація на сторінку продукту.

{
  pathname: string;
  search: string;
  hash: string;
  state: any;
  key: string;
}

Властивість state об'єкта розташування дозволяє передавати довільні дані при навігації від одного маршруту до іншого. 
Для цього використовуємо пропс state компонента Link і передамо об'єкт із властивістю from - звідки прийшов юзер.
Значення пропсу state не має зумовленої структури та може бути довільним, на розсуд розробника.

src/pages/Products.jsx

const Products = () => {
  return (
    <Link to="/products/h-1" state={{ from: "/dashboard?name=hoodie" }}>
      Navigate to product h-1
    </Link>
  );
};

Значення пропсу state буде доступно на об'єкті розташування маршруту куди була виконана навігація. 
Все, що необхідно зробити, це використовувати хук useLocation, отримати об'єкт location і звернутися до його властивості state.

src/pages/ProductDetails.jsx

const ProductDetails = () => {
  const location = useLocation();
  console.log(location.state);// { from: "/dashboard?name=hoodie" }

  return <Link to={location.state.from}>Back to products</Link>;
};

Насправді не потрібно обчислювати поточний URL для формування значення власності from. Об'єкт location описує всі частини 
URL поточного маршруту, тому можна передати його в пропс state.

src/pages/Products.jsx

const Products = () => {
  const location = useLocation();

  return (
    <Link to="/product/h-1" state={{ from: location }}>
      Navigate to product h-1
    </Link>
  );
};

У властивості location.state буде посилання на об'єкт location маршруту з якого відбулася навігація. 
Пропсу to компонента Link можна передавати не тільки рядок, що описує href майбутнього посилання, але й цілий об'єкт location.

src/pages/ProductDetails.jsx

const ProductDetails = () => {
  const location = useLocation();
  console.log(location.state);

// /products -> products/h-1
// { from: { pathname: "/products", search: "" } }

// /products?name=hoodie -> products/h-1
// { from: { pathname: "/products", search: "?name=hoodie" } }

  return <Link to={location.state.from}>Back to products</Link>;
};

Останнє, що необхідно врахувати, це випадок, коли користувач перейшов по збереженому раніше посиланню одного продукту 
в новій вкладці браузера, а не зі сторінки всіх продуктів. У такому разі значення location.state буде null і при зверненні 
до властивості location.state.from програма впаде з помилкою. Тому необхідно подбати про значення за замовчуванням для пропсу to.

src/pages/ProductDetails.jsx

const ProductDetails = () => {
  const location = useLocation();
  const backLinkHref = location.state?.from ?? "/products";

  return <Link to={backLinkHref}>Back to products</Link>;
};
*/

/**
  |============================
  | Розділення коду
  |============================
*/
/* 
За замовчуванням, всі залежності проекту об'єднуються в один файл. Чим більше коду, тим повільніше він завантажуватиметься, 
парситься і виконуватиметься у браузері користувача. На слабких комп'ютерах або телефонах, з поганим підключенням до Інтернет 
може бути десятки секунд.

При розробці на локальному сервері (localhost) усі файли раздаються з нашого комп'ютера. 
У цьому випадку швидкість підключення до Інтернету не має значення, та тому файли проекту завантажуються дуже швидко. 
Однак у продакшені завантаження великих файлів може стати проблемою, тому що не скрізь є високошвидкісний інтернет та 
потужні комп'ютери.

Вирішення проблеми очевидне - розбити проект на дрібніші файли та завантажувати їх лише за потребою. 
У цьому полягає концепція поділу коду. Якщо користувач заходить на сторінку логіна, не потрібно завантажувати весь код 
програми, буде достатньо частини, що відповідає за рендер компонентів тільки цієї сторінки.

Інтерфейси можуть бути дуже громіздкими. Якщо піти далі, то можна оптимізувати завантаження окремих, дуже великих 
компонентів сторінки, які не потрібні до певної дії користувача. Наприклад, компонент модального вікна, в якому 
використовується велика бібліотека текстового редактора. Такий підхід називається поділ коду на основі компонентів 
(component-centric).

ЩО ВИКОРИСТОВУВАТИ?
Розробник приймає рішення як, що і де поділяти. Проте ось кілька найкращих практик.
- Поділ коду на основі маршрутів є обов'язковим у будь-якому додатку.
- Поділ коду на основі компонентів варто робити тільки у великих, складних інтерфейсах із сотнями компонентів та 
великими бібліотеками.
- Надмірний поділ коду також не найкраща ідея. HTTP-запит за файлом може бути довше ніж додана вага до першого завантаження.


--- React.lazy() та React.Suspense ---
Ви вже знаєте що ES модулі статичні, тобто імпорти та експорти виконуються у час компіляції, а не під час виконання коду. 
Імпорти повинні бути оголошені у верхній частині файлу, інакше буде помилка компіляції. Це означає, що ви не можете 
імпортувати залежність динамічно на основі якоїсь умови.

- Без поділу коду -

import MyComponent from "path/to/MyComponent";

const App = () => {
  return (
    <Routes>
      <Route path="/some-path" element={<MyComponent />} />
      {///Інші маршрути///}
    </Routes>
  );
};

У специфікації ES2020 з'явилася можливість динамічного імпортування модуля. Різниця в тому, що замість звичайного 
статичного import використовується функція import(), яка повертає проміс, значенням якого буде файл модуля.

import("path/to/MyComponent").then(module => console.log(module));

React надає API для того, щоб вказати який код необхідно виділити в окремий файл, а потім завантажувати та рендерувати 
лише за потреби. Функція React.lazy() відповідає за асинхронне завантаження компонента, а Suspense призупиняє його відображення 
до завершення завантаження.

- З поділом коду -

import { lazy, Suspense } from "react";

const MyComponent = lazy(() => import("path/to/MyComponent"));

const App = () => {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Routes>
        <Route path="/some-path" element={<MyComponent />} />
        {///Інші маршрути///}
      </Routes>
    </Suspense>
  );
};

Метод lazy() очікує функцію-завантажувач, яка повертає результат динамічного імпорту - проміс, значенням якого буде 
дефолтний експорт модуль (компонент). Якщо під час рендеру компонент MyComponent ще не завантажений, потрібно показати заглушку. 
Для цього використовується компонент Suspense. Проп fallback приймає будь-який React-елемент або компонент. 
Suspense можна помістити будь-де над асинхронним компонентом або групою компонентів.

ДИНАМІЧНИЙ ІМПОРТ
Зверніть увагу на відсутність статичного імпорту MyComponent в останньому прикладі. Натомість використовується функція import(). 
Якщо залишити статичний імпорт, то Webpack не виконає поділ коду і додасть весь код MyComponent в основний JavaScript файл проекту.


Suspense та прийом «shared layout»
Якщо ви використовуєте прийом «shared layout», то потрібно розмістити Suspense безпосередньо всередині компонента SharedLayout. 
В іншому випадку, при завантаженні кожної сторінки, будуть пропадати і повторно рендерувати компоненти загальної частини сторінок, 
наприклад хедер та навігація.

// src/components/App.jsx
import { lazy } from "react";

const MyComponent = lazy(() => import("path/to/MyComponent"));

const App = () => {
  return (
    <Routes>
      <Route path="/" element={<SharedLayout />}>
        <Route path="some-pa///}
      </Route>
    </Routes>
  );
};

// src/components/SharedLayout.jsx
import { Suspense } from "react";
import { Outlet } from "react-router-dom";

const SharedLayout = () => {
  return (
    <Container>
      <AppBar>
        <Navigation />
        <UserMenu />
      </AppBar>

      <Suspense fallback={<div>Loading...</div>}>
        <Outlet />
      </Suspense>
    </Container>
  );
};

ВКЛАДЕНІ МАРШРУТИ ТА SUSPENSE
Зверніть увагу на використання компонента Suspense у коді компонента сторінки About. Так, при завантаженні підсторінок, 
не заново малюватиметься вся сторінка, лише її нижня частина з розміткою підсторінок. Компоненти Suspense у SharedLayout 
та About не заважають один одному, натомість React використовує найбільш підходящий - той, що найближче до завантажуваного 
компоненту.

*/
/**
  |============================
  | Основи Redux. Бібліотека Redux Toolkit та React-redux хуки
  |============================
*/
/**
  |============================
  | Управління станом
  |============================
*/
/* 
Вимоги до функціоналу додатків постійно зростають, у результаті збільшується кількість станів інтерфейсу: 
асинхронне завантаження даних, індикатори завантаження даних, значення фільтрів під час сортування, стан форм тощо. 
Бібліотеки управління станом стандартизують зберігання та роботу зі станом програми, тим самим спрощуючи процес розробки.

Redux це одна з найпопулярніших бібліотек керування станом програми.
- Передбачуваність результату - існує завжди одне джерело правди, стор (сховище, store), що приховує у собі стан програми 
та методи для роботи з ним.
- Підтримуваність - є набір правил та кращих практик про те, як повинен бути структурований код, що робить його більш 
одноманітним та зрозумілим.
- Інструменти розробника - зручне розширення браузера в якому надається максимум інформації про стан програми в режимі 
реального часу.

Без використання бібліотеки управління станом, процес поновлення даних виглядає наступним чином:
- Стан зберігається в найближчому загальному компоненті предка.
- Який-то вкладений компонент ініціалізує зміну стану викликавши метод отриманий як пропс.
- Змінений стан прокидається пропсами вниз по дереву компонентів.

Деякі компоненти виступають провідниками, тобто отримують пропс тільки для того, щоб прокидати його ще глибше, до 
компонента якому він справді потрібний. Спочатку потрібно прокидати через усе дерево компонентів метод зміни стану, 
потім сам стан. Це стандартний механізм передачі пропсів на декілька рівнів у глибину, змінити його не можна.

Redux вирішує цю проблему створенням стора (сховища, store), який відповідає за централізоване зберігання всього стану 
та надає набір правил та методів для його зміни. Компонентам залишається викликати методи для оновлення даних та підписатися 
на оновлення. Таким чином, Redux вирішує проблему передачі пропсів через всі компоненти дерева.

Потік даних у Redux завжди односпрямований, від компонентів до стору, та від стора до компонентів без посередників. 
Це робить логіку програми більш передбачуваною та легкою для розуміння.

- Користувач, працюючи з інтерфейсом, ініціалізує відправку екшенів (дій, actions).
- Стор (store) викликає всі оголошені редюсери (reducers), функції для зміни стану, передаючи їм поточний стан (state) 
та екшен (дія, action).
- Стор (store) зберігає оновлений стан (state) повернутий з редюсерів (reducers).
- При оновленні стану (state) повторно рендеруються залежні від нього компоненти.



--- Плюси і мінуси ---

Redux це лише інструмент для управління станом програми, який призначений для того, щоб допомогти відповісти на запитання -
«Коли і як змінилася певна частина стану». Якщо у вас немає проблем із керуванням станом використовуючи можливості React, 
вам може бути важче зрозуміти переваги Redux. Можливо стан React це все, що вам потрібно для створення програми.

Необхідність використовувати бібліотеку управління станом не слід сприймати як належне. Якщо додаток стає настільки 
складним, що ви не розумієте, де зберігається стан, як воно змінюється, і ви виявите, що зберігання даних у стані 
компонента React вже недостатньо, тоді саме час використовувати Redux.

Тим не менш, використання Redux потребує компромісів. Він не створений щоб бути найкоротшим або найшвидшим способом 
написання коду. Redux накладає певні вимоги: зберігати стан програми у вигляді простої структури даних (стор), 
описувати зміни об'єктами (екшени) та обробляти ці зміни за допомогою чистих функцій (редюсери).

*/

/**
  |============================
  | Планувальник завдань
  |============================
*/
/* 

Розбиратимемо Redux на прикладі програми планувальника завдань, в якій можна створити, видалити, відзначити завдання 
як виконане і відфільтрувати задачі за статусом. Це дозволить нам розглянути стандартні випадки під час роботи з колекцією даних.

В першу чергу пропишемо базові вимоги до інтерфейсу та логіки роботи програми:

Інтерфейс повинен складатися з кількох частин:
- Шапка з інформацією про завдання та фільтри
- Форма з полем введення для створення нових завдань
- Список завдань

У шапці необхідно відображати:
- Кількість виконаних та невиконаних завдань
- Фільтри списку завдань зі значеннями «All», «Active» та «Completed»

У кожного елементу списку завдань має бути:
- Абзац з текстом який вводив у форму користувач під час створення завдання
- Чекбокс перемикання статусу «виконано»
- Кнопка видалення завдання


Проектування стану
Інтерфейс програми повинен ґрунтуватися на його стані. Тому в першу чергу необхідно спроектувати стан програми, 
яка міститиме найменшу кількість значень, достатню для опису всього необхідного функціоналу. Це скоротить кількість 
даних, за якими необхідно буде стежити та оновлювати.

У нашому додатку є дві основні частини: список завдань, з яких можна отримати всі необхідні дані про кількість та 
статус завдань, та значення фільтрів списку завдань. Це і буде мінімально необхідний стан.

const appState = {
  tasks: [],
  filters: {
    status: "all",
  },
};


СТРУКТУРА СТАНУ
Стан Redux це завжди об'єкт, всередину якого додаються властивості для стану програми. Тому ми оголосили властивість 
tasks для масиву всіх завдань та filters для можливих фільтрів. Стан Redux може бути настільки простий або складний, 
наскільки цього вимагає функціонал програми.

Кожне завдання буде представлено об'єктом з наступними властивостями:
- id - унікальний ідентифікатор
- text - текст, який ввів користувач під час створення
- completed - прапор, що вказує, виконано завдання чи ні


Ось як може виглядати приклад стану нашої програми з кількома завданнями:
const appState = {
  tasks: [
    { id: 0, text: "Learn HTML and CSS", completed: true },
    { id: 1, text: "Get good at JavaScript", completed: true },
    { id: 2, text: "Master React", completed: false },
    { id: 3, text: "Discover Redux", completed: false },
    { id: 4, text: "Build amazing apps", completed: false },
  ],
  filters: {
    status: "all",
  },
};

Проектування екшенів
Екшени це події, які можуть статися в додатку, в тому числі як реакція на дії користувача. 
Складемо список подій, які можуть бути в нашому додатку:
- Додати нове завдання з текстом, введеним користувачем
- Видалити завдання
- Переключити статус завдання
- Змінити значення фільтра статусу


Структура файлів проекту
У Redux немає стандарту структури файлів проекту, тільки загальні рекомендації та приклади, тому кожен може вибрати 
щось для себе. Тим не менш, важливо продумати шаблон структури файлів проекту ще до написання коду.

Для того, щоб відокремити логіку Redux від коду компонентів, нам буде достатньо зробити папку src/redux з кількома файлами. 
У невеликому додатку, як наш планувальник завдань, цього буде достатньо.
actions.js - файл оголошення екшенів програми
reducer.js - файл оголошення функцій-редюсерів для оновлення стану
constants.js - файл для зберігання констант (наприклад значень фільтру статусу)
selectors.js - файл оголошення функцій-селекторів
store.js - файл створення стор Redux

Якщо в додатку багато різних даних, то підійде «feature based» підхід, де під кожну сутність створюється окрема папка
усередині папки redux. Усередині кожної сутності є стандартний набір файлів. В результаті більше файлів, але код логіки Redux 
поділений на сутності та більш структурований.
*/

/**
  |============================
  | Встановлення Redux
  |============================
*/
/* 
Додамо до проекту бібліотеку Redux - набір функцій для створення стора (сховища, store), роботи зі станом програми (state) 
та відправлення екшенів (дій, actions).

npm install redux

Для використання React та Redux разом, необхідно додати до проекту бібліотеку React Redux. Це набір компонентів та хуків
зв'язуючих компонентів React та Redux стор (store).

npm install react-redux

! REDUX VS REDUX TOOLKIT 
У матеріалах цього заняття ми познайомимося з основними концепціями бібліотеки Redux та обов'язково розберемо їх на живих 
прикладах. Але, надалі ми будемо використовувати Redux Toolkit - надбудову над базовими концепціями та конструкціями Redux, 
яка ґрунтується на кращих практиках, спрощує код пов'язаний з Redux і запобігає поширеним помилкам. 
Це офіційний рекомендований підхід до написання логіки Redux.
*/

/**
  |============================
  | Стор (store)
  |============================
*/
/* 
Об'єкт, який містить повний стан програми, методи доступу до стану та відправлення екшенів. У програмі може бути лише один 
стор. Для створення стора є функція createStore(), яка приймає кілька параметрів та повертає новий об'єкт стора.

--- createStore(reducer, preloadedState, enhancer) --- 

reducer - функція із логікою зміни стану Redux. Обов'язковий параметр.
preloadedState - початковий стан програми. Це має бути об'єкт тієї ж форми, що й, як мінімум, частина стану. Необов'язковий параметр.
enhancer - функція розширення можливостей стору. Необов'язковий параметр.

src/redux/store.js
import { createStore } from "redux";
2
/* 3  Початкове значення стану Redux для кореневого редюсера, якщо не передати параметр preloadedState. 
5* const initialState = { 
6 tasks: [  
7  { id: 0, text: "Learn HTML and CSS", completed: true },  
8  { id: 1, text: "Get good at JavaScript", completed: true },    
9  { id: 2, text: "Master React", completed: false },   
10 { id: 3, text: "Discover Redux", completed: false },  
11  { id: 4, text: "Build amazing apps", completed: false }, 
12 ], 
13 filters: { 
14  status: "all", 
15 },
16 };
17
/* 18 Поки що використовуємо редюсер який тільки повертає отриманий стан 
const rootReducer = (state = initialState, action) => {  return state; };
export const store = createStore(rootReducer);

Після створення стору необхідно зв'язати його з компонентами React, щоб вони могли отримувати доступ до стору та його 
методів. Для цього у бібліотеці React Redux є компонент Provider, котрий чекає однойменний пропс store. 
Для того щоб будь-який компонент у додатку міг використовувати стор, обертаємо Provider все дерево компонентів.

1 import ReactDOM from "react-dom/client";
2 import { Provider } from "react-redux";
3 import { store } from "./redux/store";
4
5 ReactDOM.createRoot(document.getElementById("root")).render(  
6 <Provider store={store}>  
7  <App />  
8 </Provider>
9 );
*/

/**
  |============================
  | Redux DevTools
  |============================
*/
/* 
Інструменти розробника це розширення браузера, яке додає зручний візуальний інтерфейс для налагодження змін стану програми 
та стеження за потоком даних у Redux, від відправлення дій до зміни стану.

Для початку необхідно додати розширення інструментів розробника у ваш браузер:

Chrome Web Store
https://chromewebstore.google.com/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?pli=1

Далі встановлюємо бібліотеку, яка дозволить ініціалізувати логіку Redux DevTools та зв'язати її з розширенням в інструментах 
розробника.

npm install @redux-devtools/extension

Ми поки що не використовуємо жодних додаткових можливостей Redux, тому імпортуємо функцію devToolsEnhancer і 
використовуємо її при створенні стора, передавши її результат третім аргументом, замість початкового стану.

src/redux/store.js

import { createStore } from "redux";
import { devToolsEnhancer } from "@redux-devtools/extension";
const initialState = {
  tasks: [
    { id: 0, text: "Learn HTML and CSS", completed: true },
    { id: 1, text: "Get good at JavaScript", completed: true },
    { id: 2, text: "Master React", completed: false },
    { id: 3, text: "Discover Redux", completed: false },
    { id: 4, text: "Build amazing apps", completed: false },
  ],
  filters: {
    status: "all",
  },
};
const rootReducer = (state = initialState, action) => {
  return state;
};
// Створюємо розширення стора, щоб додати інструменти розробника
const enhancer = devToolsEnhancer();
export const store = createStore(rootReducer, enhancer);

ПОРЯДОК АРГУМЕНТІВ
Якщо вам не потрібний початковий стан preloadedState, то значення enhancer передається другим аргументом. В іншому випадку - третім.

Після запуску проекту командою npm start, у стандартних інструментах розробника з'явиться нова вкладка Redux, при переході 
на яку відкриються Redux DevTools зі списком відправлених екшенів зліва та детальною інформацією про стан та екшени праворуч.

*/

/**
  |============================
  | Підписка на стор
  |============================
*/
/* 
Щоб отримати дані зі стору, компоненти повинні підписатися на необхідні їм частини стану Redux. 
Для цього у бібліотеці React Redux є хук [useSelector(selector)](<https://react-redux.js.org/api/hooks#useselector>). 

Аргументом він приймає функцію, яка оголошує один параметр state - весь об'єкт стану Redux, який буде автоматично переданий 
функції хуком useSelector. Ця функція називається селектором і повинна повернути тільки ту частину стану, яка необхідна компоненту.

// Імпортуємо хук
import { useSelector } from "react-redux";
const MyComponent = () => {
  // Отримуємо необхідну частину стану
  const value = useSelector(state => state.some.value);
};
Додамо код підписки компонентів нашої програми. Для того, щоб сфокусувати увагу на логіці коду передплати, 
у прикладах опустимо стилізацію. Повний код програми можна розібрати на живому прикладі в кінці цієї секції.

Фільтр за статусом
Збережемо можливі значення фільтра як об'єкта, щоб повторно використовувати їх у різних місцях програми: 
компоненті StatusFilter для обчислення поточного активного фільтра та відправки екшенів зміни фільтра, 
компоненті TaskList для обчислення списку видимих завдань, а також функції-редюсері в якій потім будемо обробляти екшен зміни фільтра.

src/redux/constants.js

export const statusFilters = Object.freeze({
  all: "all",
  active: "active",
  completed: "completed",
});
 OBJECT.FREEZE()
Використовуємо метод [Object.freeze()](<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze>)
для того, щоб «заморозити» об'єкт значень фільтра та запобігти випадковій зміні за посиланням у місцях імпорту.

Компоненту StatusFilter потрібно значення фільтра з властивості statusFilter стану Redux, тому функція-селектор 
виглядатиме як state => state.filters.status.

src/components/StatusFilter/StatusFilter.js

// Імпортуємо хук
import { useSelector } from "react-redux";
// Імпортуємо об'єкт значень фільтра
import { statusFilters } from "../../redux/constants";

export const StatusFilter = () => {
  // Отримуємо значення фільтра із стану Redux
  const filter = useSelector(state => state.filters.status);

  return (
    <div>
      <Button selected={filter === statusFilters.all}>All</Button>
      <Button selected={filter === statusFilters.active}>Active</Button>
      <Button selected={filter === statusFilters.completed}>Completed</Button>
    </div>
  );
};


Список завдань
Компоненту TaskList необхідний масив завдань із властивості tasks та значення фільтра із властивості statusFilter. 
На основі цих значень ми можемо вирахувати масив завдань, які необхідно рендерувати в інтерфейсі.

src/components/TaskList/TaskList.js
// Імпортуємо хук
import { useSelector } from "react-redux";
import { Task } from "components/Task/Task";
// Імпортуємо об'єкт значень фільтра
import { statusFilters } from "../../redux/constants";

const getVisibleTasks = (tasks, statusFilter) => {
  switch (statusFilter) {
    case statusFilters.active:
      return tasks.filter(task => !task.completed);
    case statusFilters.completed:
      return tasks.filter(task => task.completed);
    default:
      return tasks;
  }
};

export const TaskList = () => {
  // Отримуємо масив завдань із стану Redux
  const tasks = useSelector(state => state.tasks);
  // Отримуємо значення фільтра із стану Redux
  const statusFilter = useSelector(state => state.filters.status);
  // Обчислюємо масив завдань, які необхідно відображати в інтерфейсі
  const visibleTasks = getVisibleTasks(tasks, statusFilter);

  return (
    <ul>
      {visibleTasks.map(task => (
        <li key={task.id}>
          <Task task={task} />
        </li>
      ))}
    </ul>
  );
};
ДЕ ПРОПСИ?
Зверніть увагу на те, що у компонента TaskList немає пропсів, як це було б при використанні стану React. 
Компоненту App тепер не потрібно знати про те, що TaskList підписаний на дані із стору. 
Використовуючи Redux будь-який компонент може безпосередньо отримати доступ до значень стану Redux, якщо в цьому є необхідність.



Лічильник завдань
Компоненту TaskCounter необхідний масив завдань із властивості tasks стану Redux, тому функція-селектор виглядатиме 
як state => state.tasks. На базі цих даних ми можемо обчислити похідні дані кількості активних і виконаних завдань.

src/components/TaskCounter/TaskCounter.js

// Імпортуємо хук
import { useSelector } from "react-redux";

export const TaskCounter = () => {
  // Отримуємо масив завдань із стану Redux
  const tasks = useSelector(state => state.tasks);

  // На базі стану Redux отримуємо похідні дані
  const count = tasks.reduce(
    (acc, task) => {
      if (task.completed) {
        acc.completed += 1;
      } else {
        acc.active += 1;
      }
      return acc;
    },
    { active: 0, completed: 0 }
  );

  return (
    <div>
      <p>Active: {count.active}</p>
      <p>Completed: {count.completed}</p>
    </div>
  );
};

Функції-селектори
Один і той же селектор може використовуватися в декількох місцях програми, що призводить до дублювання коду, як, наприклад, 
у наших компонентах TaskList, StatusFilter та TaskCounter. Щоб уникнути цього та ще більше структурувати код, всі функції-селектори 
оголошуються в окремому файлі, наприклад, в src/redux/selectors.js, після чого імпортуються до компонентів.

src/redux/selectors.js

export const getTasks = state => state.tasks;

export const getStatusFilter = state => state.filters.status;



ОДНЕ ДЖЕРЕЛО ПРАВДИ
Оголошення функцій-селекторів поза компонентами також добре тим, що компоненти не знають про форму стану Redux, і у разі 
його зміни достатньо буде відредагувати код одного файлу, а не шукати селектори за кодом всіх компонентів програми.
*/

/**
  |============================
  | Екшени (actions)
  |============================
*/
/* 
Екшени - це об'єкти, які передають дані з компонентів у стор, тим самим сигналізуючи про те, яка подія сталася в інтерфейсі. 
Вони являються єдиним джерелом інформації для стору.

const action = {
  type: "Action type",
  payload: "Payload value",
};
Екшени повинні мати обов'язкову властивість type - рядок який описує тип події в інтерфейсі. 
Крім властивості type структура об'єкта може бути довільною, проте, дані зазвичай передають у необов'язковій властивості payload. 
Даними екшену може бути будь-яке значення крім функцій та класів.

Створимо екшени які описуватимуть додавання, видалення та перемикання статусу завдання, а також зміну значення фільтра.

const addTask = {
  type: "tasks/addTask",
  payload: {
    id: "Generated id",
    text: "User entered text",
    completed: false,
  },
};

const deleteTask = {
  type: "tasks/deleteTask",
  payload: "Task id",
};

const toggleCompleted = {
  type: "tasks/toggleCompleted",
  payload: "Task id",
};

const setStatusFilter = {
  type: "filters/setStatusFilter",
  payload: "Filter value",
};
НАЙКРАЩІ ПРАКТИКИ - НАЙМЕНУВАННЯ
Одна з найпопулярніших конвенцій складання типу екшену пропонує використовувати у значенні поля type дві частини 
у форматі domain/eventName. Перше це ім'я категорії (сутності) до якої належить екшен (tasks та filters), зазвичай 
збігається з ім'ям властивості частини стану Redux, і друге це подія, яка описує екшен (addTask, deleteTask, toggleCompleted, 
setStatusFilter).

НАЙКРАЩІ ПРАКТИКИ - МІНІМАЛІЗМ
Екшени повинні нести в собі мінімально необхідний набір інформації, якого буде достатньо для зміни стану. 
Наприклад, при видаленні завдання досить передати її ідентифікатор, а чи не весь об'єкт завдання цілком.



Генератори екшенів

Екшени це статичні об'єкти, значення властивості payload яких неможливо задати динамічно. 
Генератори екшенів (Action Creators) - функції, які можуть приймати аргументи, після чого створюють та повертають екшени 
з однаковим значенням властивості type, але різними payload. Вони можуть мати побічні ефекти, наприклад, заповнювати 
властивості за замовчуванням або генерувати унікальний ідентифікатор об'єкта завдання. 

Створимо генератори екшенів для нашої програми.
src/redux/actions.js

import { nanoid } from "nanoid";

export const addTask = text => {
  return {
    type: "tasks/addTask",
    payload: {
      id: nanoid(),
      completed: false,
      text,
    },
  };
};

export const deleteTask = taskId => {
  return {
    type: "tasks/deleteTask",
    payload: taskId,
  };
};

export const toggleCompleted = taskId => {
  return {
    type: "tasks/toggleCompleted",
    payload: taskId,
  };
};

export const setStatusFilter = value => {
  return {
    type: "filters/setStatusFilter",
    payload: value,
  };
};
 

УНІКАЛЬНИЙ ІДЕНТИФІКАТОР ЗАДАЧІ
Зверніть увагу на генератор екшенів створення задачі addTask. В майбутньому присвоєнням ідентифікатора займатиметься бекенд, 
а поки що зробимо це в нашому коді. Для цього використовуємо бібліотеку nanoid.



Відправлення екшенів

Для того щоб сповістити сторінку про те, що в інтерфейсі відбулася якась подія, необхідно відправити екшен. 
Для цього у бібліотеці React Redux є хук [useDispatch()](<https://react-redux.js.org/api/hooks#usedispatch>), 
який повертає посилання на функцію надсилання екшенів dispatch з об'єкта створеного нами раніше стора Redux.

// Імпортуємо хук
import { useDispatch } from "react-redux";

const MyComponent = () => {
  // Отримуємо посилання на функцію відправки екшенів
  const dispatch = useDispatch();
};


Додамо код відправлення раніше спроектованих екшенів із компонентів нашої програми. 
Для того щоб сфокусувати увагу на відправці екшенів, в приклади опустимо код стилізації. 


Створення завдання
При сабміті форми в компоненті TaskForm необхідно надіслати екшен створення нового завдання, передавши йому значення, 
введене користувачем у текстове поле.

src/components/TaskForm/TaskForm.js

// Імпортуємо хук
import { useDispatch } from "react-redux";
// Імпортуємо генератор екшену
import { addTask } from "../../redux/actions";

export const TaskForm = () => {
  // Отримуємо посилання на функцію відправки екшенів
  const dispatch = useDispatch();

  const handleSubmit = event => {
    event.preventDefault();
    const form = event.target;
    // Викликаємо генератор екшену та передаємо текст завдання для поля payload
    // Відправляємо результат – екшен створення завдання
    dispatch(addTask(form.elements.text.value));
    form.reset();
  };

  return (
    <form onSubmit={handleSubmit}>
      <input type="text" name="text" placeholder="Enter task text..." />
      <button type="submit">Add task</button>
    </form>
  );
};


При сабміті форми, у списку екшенів зліва Redux DevTools, додається відправлений екшен створення завдання. 
Клікнувши по ньому та вибравши у правій частині вкладку Actions, можна переглянути детальну інформацію.


Видалення завдання

При натисканні на кнопку видалення в компоненті Task, необхідно відправити екшен видалення завдання, передавши йому 
ідентифікатор завдання. Цих даних буде достатньо для видалення задачі з масиву об'єктів.

src/components/Task/Task.js

// Імпортуємо хук
import { useDispatch } from "react-redux";
// Імпортуємо генератор екшену
import { deleteTask } from "../../redux/actions";

export const Task = ({ task }) => {
  // Отримуємо посилання на функцію відправки екшенів
  const dispatch = useDispatch();

  // Викликаємо генератор екшену та передаємо ідентифікатор завдання
  // Відправляємо результат - екшен видалення завдання
  const handleDelete = () => dispatch(deleteTask(task.id));

  return (
    <div>
      <input type="checkbox" />
      <p>{task.text}</p>
      <button type="button" onClick={handleDelete}>
        Delete
      </button>
    </div>
  );
};

При натисканні на кнопку видалення, в Redux DevTools додається відправлений екшен видалення завдання. 
Клікнувши по ньому, можна переглянути детальну інформацію.


Переключення статусу

При натисканні на чекбокс в компоненті Task, необхідно відправити екшен перемикання статусу завдання, передавши йому 
ідентифікатор завдання. Цих даних буде достатньо для того, щоб знайти завдання в масиві об'єктів і змінити значення властивості на протилежне

src/components/Task/Task.js

// Імпортуємо хук
import { useDispatch } from "react-redux";
// Імпортуємо генератор екшену
import { deleteTask, toggleCompleted } from "../../redux/actions";

export const Task = ({ task }) => {
  // Отримуємо посилання на функцію відправки екшенів
  const dispatch = useDispatch();

  const handleDelete = () => dispatch(deleteTask(task.id));

  // Викликаємо генератор екшену та передаємо ідентифікатор завдання
  // Відправляємо результат - екшен перемикання статусу завдання
  const handleToggle = () => dispatch(toggleCompleted(task.id));

  return (
    <div>
      <input type="checkbox" onChange={handleToggle} checked={task.completed} />
      <p>{task.text}</p>
      <button onClick={handleDelete}>Delete</button>
    </div>
  );
};

При кліку по чекбоксу, Redux DevTools додається відправлений екшен зміни статусу завдання. Клікнувши по ньому, 
можна переглянути детальну інформацію.

БЕЗ ЗАЙВИХ ПРОПСІВ
Зверніть увагу на те, що у компонента Task немає додаткових пропсів, наприклад методів для видалення та зміни статусу, 
як це було б при використання стану React. Це також робить компонент списку завдань простіше, йому не доводиться приймати 
не потрібні пропси та прокидати їх у компонент завдання. Використовуючи Redux, будь-який компонент може безпосередньо отримати 
доступ до функції. відправлення екшенів.


Зміна фільтра

При натисканні на кнопки в компоненті StatusFilter необхідно відправити екшен зміни фільтра, передавши йому нове значення. 
Використовуємо об'єкт значень фільтр з файлу констант.

src/components/StatusFilter/StatusFilter.js

// Імпортуємо хук
import { useSelector, useDispatch } from "react-redux";
// Імпортуємо генератор екшену
import { setStatusFilter } from "../../redux/actions";
// Імпортуємо об'єкт значень фільтра
import { statusFilters } from "../../redux/constants";

export const StatusFilter = () => {
  // Отримуємо посилання на функцію відправки екшенів
  const dispatch = useDispatch();

  const filter = useSelector(state => state.statusFilter);

  // Викликаємо генератор екшену та передаємо значення фільтра
  // Відправляємо результат - екшен зміни фільтра
  const handleFilterChange = filter => dispatch(setStatusFilter(filter));

  return (
    <div>
      <Button
        selected={filter === statusFilters.all}
        onClick={() => handleFilterChange(statusFilters.all)}
      >
        All
      </Button>
      <Button
        selected={filter === statusFilters.active}
        onClick={() => handleFilterChange(statusFilters.active)}
      >
        Active
      </Button>
      <Button
        selected={filter === statusFilters.completed}
        onClick={() => handleFilterChange(statusFilters.completed)}
      >
        Completed
      </Button>
    </div>
  );
};
При натисканні на кнопки фільтра, в Redux DevTools додається відправлений екшен зміни фільтра. 
Клікнувши по ньому, можна переглянути детальну інформацію.

*/

/**
  |============================
  | Редюсери (reducers)
  |============================
*/
/* 
Ми спроектували стан програми, пов'язали компоненти та стор, додали відправлення екшенів. 
Настав час написати логіку зміни стану Redux.

Редюсер (reducer) - це функція, яка приймає поточний стан та екшен як аргументи і повертає новий стан. 
Редюсер визначає, як змінюється стан програми у відповідь на екшени, надіслані на стор. 
Пам'ятайте, що екшени описують тільки те, що сталося, а не як змінюється стан програми.

(state, action) => nextState

Кореневий редюсер

У додатку завжди буде лише один кореневий редюсер, який потрібно передати до createStore під час створення стора. 
Цей редюсер відповідає за обробку всіх відправлених екшенів та обчислення нового стану.

src/redux/reducer.js

import { statusFilters } from "./constants";

const initialState = {
  tasks: [
    { id: 0, text: "Learn HTML and CSS", completed: true },
    { id: 1, text: "Get good at JavaScript", completed: true },
    { id: 2, text: "Master React", completed: false },
    { id: 3, text: "Discover Redux", completed: false },
    { id: 4, text: "Build amazing apps", completed: false },
  ],
  filters: {
    status: statusFilters.all,
  },
};

// Використовуємо initialState як значення стану за умовчанням
export const rootReducer = (state = initialState, action) => {
  // Редюсер розрізняє екшени за значенням властивості type
  switch (action.type) {
    // Залежно від типу екшену виконуватиметься різна логіка
    default:
      // Кожен редюсер отримує всі екшени, відправлені в стор.
      // Якщо редюсер не повинен обробляти якийсь тип екшену,
      // необхідно повернути наявний стан без змін.
      return state;
  }
};

ПОЧАТКОВИЙ СТАН При ініціалізації стора (екшен @@INIT у Redux DevTools) всім редюсерам у якості значення стану передається undefined. 
Тому кожному редюсеру необхідно вказати значення за замовчуванням для параметра state, яке стане початковим станом програми.

Додамо логіку обробки екшену створення завдання. Перевіряємо чи відповідає тип відправленого екшену рядку "tasks/addTask" 
і повертаємо новий об'єкт, що містить весь стан, навіть для властивостей, які не змінилися.

src/redux/reducer.js

import { statusFilters } from "./constants";

const initialState = {
  tasks: [
    { id: 0, text: "Learn HTML and CSS", completed: true },
    { id: 1, text: "Get good at JavaScript", completed: true },
    { id: 2, text: "Master React", completed: false },
    { id: 3, text: "Discover Redux", completed: false },
    { id: 4, text: "Build amazing apps", completed: false },
  ],
  filters: {
    status: statusFilters.all,
  },
};

export const rootReducer = (state = initialState, action) => {
  // Редюсер розрізняє екшени за значенням властивості type
  switch (action.type) {
    // Залежно від типу екшену виконуватиметься різна логіка
    case "tasks/addTask": {
      // Потрібно повернути новий об'єкт стану
      return {
        // в якому є всі дані існуючого стану
        ...state,
        // та новий масив задач
        tasks: [
          // в якому є всі існуючі завдання
          ...state.tasks,
          // та об'єкт нового завдання
          action.payload,
        ],
      };
    }
    default:
      // Кожен редюсер отримує всі екшени, відправлені в стор.
      // Якщо редюсер не повинен обробляти якийсь тип екшену,
      // необхідно повернути наявний стан без змін.
      return state;
  }
};

ІМУТАБЕЛЬНІСТЬ СТАНУ 
Писати логіку оновлення стану вручну не найлегше завдання, тому випадкова зміна стану в редюсерах - це поширена помилка, 
на практиці вам не доведеться писати складні вкладені іммутабельні оновлення вручну. У наступному занятті ви дізнаєтесь, 
як використовувати Redux Toolkit, щоб спростити написання логіки поновлення стану.

Код файлу створення стора імпортує та використовує кореневий редюсер.

src/redux/store.js

import { createStore } from "redux";
import { devToolsEnhancer } from "@redux-devtools/extension";
import { rootReducer } from "./reducer";

const enhancer = devToolsEnhancer();
export const store = createStore(rootReducer, enhancer);



ОНОВЛЕННЯ ІНТЕРФЕЙСУ
Якщо тепер спробувати додати нове завдання до інтерфейсу нашої програми, то у списку завдань з'явиться новий елемент. 
Справа в тому, що хук useSelector змушує компонент рендери повторно кожного разу при зміні тієї частини стану, на яку 
підписаний компонент.


Правила редюсерів

Редюсери повинні бути чистими функціями та дотримуватися списку правил:
- Не можна змінювати аргументи (state та action). Редюсери мають лише обчислювати нове значення стану з урахуванням цих аргументів.
= Не можна змінювати стан (state). Натомість редюсери повинні робити оновлення, копіюючи існуючий стан та вносячи зміни до копії.
Редюсери не повинні виконувати жодних «побічних ефектів». Наприклад, запуск таймера, виконання HTTP-запиту, зміна значення поза
функцією або її аргументів, генерація випадкових чисел чи рядків тощо.

Як виконувати побічні ефекти ми розглянемо далі, поки просто пам'ятаєте - редюсер має бути чистою функцією. 
Отримуючи аргументи, він має обчислити наступний стан та повернути його. Жодних побічних ефектів. Жодних мутацій. 
Тільки обчислення нової версії стану.

Обробка екшенів

Додамо в кореневий редюсер код обробки всіх інших екшенів нашої програми.

Видалення завдання

При видаленні нам доступний ідентифікатор завдання у властивості payload, тому використовуємо метод Array.filter() 
для того, щоб іммутабельно створити новий масив без цього завдання. Перевіряємо, чи відповідає тип відправленого екшену 
рядку "tasks/deleteTask" та повертаємо новий об'єкт стану.

src/redux/reducer.js

export const rootReducer = (state = initialState, action) => {
switch (action.type) {
case "tasks/addTask":
return {
...state,
tasks: [...state.tasks, action.payload],
};
case "tasks/deleteTask":
return {
...state,
tasks: state.tasks.filter(task => [task.id](<http://task.id/>) !== action.payload),
};
default:
return state;
}
};


Переключення статусу

При перемиканні статусу нам доступний ідентифікатор завдання у властивості payload, тому використовуємо метод Array.map() 
для того, щоб іммутабельно створити новий масив із зміненим значенням властивості completed у задачі з відповідним ідентифікатором. 
Перевіряємо, чи відповідає тип відправленого екшену рядку "tasks/toggleCompleted" та повертаємо новий об'єкт стану.

src/redux/reducer.js

export const rootReducer = (state = initialState, action) => {
switch (action.type) {
case "tasks/addTask":
return {
...state,
tasks: [...state.tasks, action.payload],
};
case "tasks/deleteTask":
return {
...state,
tasks: state.tasks.filter(task => [task.id](<http://task.id/>) !== action.payload),
};
case "tasks/toggleCompleted":
return {
...state,
tasks: state.tasks.map(task => {
if ([task.id](<http://task.id/>) !== action.payload) {
return task;
}
return {
...task,
completed: !task.completed,
};
}),
};
default:
return state;
}
};


Зміна фільтра

При зміні фільтра нам доступне нове значення фільтра payload, тому перевіряємо чи відповідає тип відправленого екшену рядку 
"filters/setStatusFilter" та повертаємо новий об'єкт стану.

src/redux/reducer.js

export const rootReducer = (state = initialState, action) => {
switch (action.type) {
case "tasks/addTask":
return {
...state,
tasks: [...state.tasks, action.payload],
};
case "tasks/deleteTask":
return {
...state,
tasks: state.tasks.filter(task => [task.id](<http://task.id/>) !== action.payload),
};
case "tasks/toggleCompleted":
return {
...state,
tasks: state.tasks.map(task => {
if ([task.id](<http://task.id/>) === action.payload) {
return {
...task,
completed: !task.completed,
};
}
return task;
}),
};
case "filters/setStatusFilter":
return {
...state,
filters: {
...state.filters,
status: action.payload,
},
};
default:
return state;
}
};


Ми додали код обробки всього чотирьох екшенів, а код кореневого редюсера вже стає громіздким. Якщо намагатися обробити 
всі екшени програми в одній Функції-редюсер, код буде досить важким для розуміння. 
Тому редюсери зазвичай поділяються на кілька дрібніших, щоб спростити розуміння і підтримку коду

Композиція редюсерів

Зазвичай редюсери поділяються ґрунтуючись на частинах стану Redux які вони оновлюють. Розділимо обробку екшенів завдань 
та зміни фільтра на два незалежних редюсера. Кожен редюсер відповідатиме лише за свою частину стану Redux, тому код оновлення 
стану буде значно простіше.



src/redux/reducer.js

const tasksInitialState = [
  { id: 0, text: "Learn HTML and CSS", completed: true },
  { id: 1, text: "Get good at JavaScript", completed: true },
  { id: 2, text: "Master React", completed: false },
  { id: 3, text: "Discover Redux", completed: false },
  { id: 4, text: "Build amazing apps", completed: false },
];

// Відповідає лише за оновлення властивості tasks
// Тепер значенням параметра state буде масив завдань
const tasksReducer = (state = tasksInitialState, action) => {
  switch (action.type) {
    case "tasks/addTask":
      return [...state, action.payload];
    case "tasks/deleteTask":
      return state.filter(task => task.id !== action.payload);
    case "tasks/toggleCompleted":
      return state.map(task => {
        if (task.id !== action.payload) {
          return task;
        }
        return { ...task, completed: !task.completed };
      });
    default:
      return state;
  }
};

const filtersInitialState = {
  status: statusFilters.all,
};

// Відповідає лише за оновлення властивості filters
// Тепер значенням параметра state буде об'єкт фільтрів
const filtersReducer = (state = filtersInitialState, action) => {
  switch (action.type) {
    case "filters/setStatusFilter":
      return {
        ...state,
        status: action.payload,
      };
    default:
      return state;
  }
};


Тепер у нас є два окремі редюсери, але при створенні стора необхідно передати один кореневий редюсер, який відповідає 
за весь стан Redux. Ми можемо написати кореневий редюсер так, щоб він просто викликав два інші редюсери і передавав
їм необхідну частину стану та екшен. Це і є композиція редюсерів.



src/redux/reducer.js

// Код редюсерів tasksReducer та filtersReducer

export const rootReducer = (state = {}, action) => {
  // Повертаємо об'єкт стану
  return {
    // Обом редюсерам передаємо тільки частину стану, за яку вони відповідають.
    tasks: tasksReducer(state.tasks, action),
    filters: filtersReducer(state.filters, action),
  };
};
Щоб не створювати кореневий редюсер вручну, у бібліотеці Redux є функція combineReducers, яка робить те саме, але коротше.



src/redux/reducer.js

// Імпортуємо функцію композиції редюсерів
import { combineReducers } from "redux";

// Код редюсерів tasksReducer та filtersReducer

export const rootReducer = combineReducers({
  tasks: tasksReducer,
  filters: filtersReducer,
});
*/

/**
  |============================
  | Redux Toolkit
  |============================
*/
/* 
Під час використання бібліотеки Redux є три основні проблеми:
- Надмірно складний процес налаштування стора
- Необхідність встановлення стандартного набору додаткових бібліотек для розширення можливостей Redux
- Великий обсяг шаблонного коду створення екшенів, редюсерів тощо.

Redux Toolkit - це офіційна бібліотека для ефективної розробки з використанням Redux, яка призначена для стандартизації 
та спрощення написання логіки Redux.
- Дозволяє зосередитися на написанні основної логіки програми, не витрачаючи час на налаштування.
- Містить утиліти для спрощення основних завдань. Таких як налаштування стора, створення екшенів та редюсерів, іммутабельне 
оновлення даних та багато чого іншого.
- Надає стандартний набір налаштувань для стора і включає в себе бібліотеки, що часто використовуються з екосистеми Redux.

Бібліотека не призначена для вирішення всіх можливих проблем та навмисно обмежена в обсязі. 
Такі рішення як HTTP-запити, структура папок та файлів, управління зв'язками сутностей у сторі і т. п., 
лягають на плечі розробника. Тим не менш, Redux Toolkit буде корисним для всіх стандартних завдань, допоможе спростити 
та покращити код пов'язаний з Redux.
*/

/**
  |============================
  | Встановлення Redux Toolkit
  |============================
*/
/* 
Redux Toolkit встановлюється як стандартний NPM пакет.

npm install @reduxjs/toolkit

Використовуючи Redux Toolkit, немає необхідності додавати в проект пакет redux, крім випадків, коли вам необхідна 
функція combineReducers(). Достатньо встановити @reduxjs/toolkit для написання логіки Redux та react-redux для зв'язку 
стора з компонентами.

npm install @reduxjs/toolkit react-redux

Якщо ви ініціалізуєте створення стартових файлів програми, використовуючи Create React App, без попередньо заготовленого 
шаблону проекту, як наприклад для домашніх робіт, у такому разі варто використовувати офіційний шаблон. Для цього команді 
npx create-react-app потрібно передати прапор --template зі значенням redux.

npx create-react-app my-app --template redux
*/

/**
  |============================
  | configureStore
  |============================
*/
/* 
Redux Toolkit надає функцію [configureStore(options)](<https://redux-toolkit.js.org/api/configureStore>), 
яка обертає оригінальний createStore(), єдиним аргументом очікує об'єкт параметрів та налаштовує деякі корисні інструменти 
розробки як частина процесу створення стора.

Будемо виконувати рефакторинг коду програми планувальника завдань із попереднього заняття.

src/redux/store.js

//=============== Before ========================
import { createStore } from "redux";
import { devToolsEnhancer } from "@redux-devtools/extension";
import { rootReducer } from "./reducer";

const enhancer = devToolsEnhancer();
export const store = createStore(rootReducer, enhancer);

//=============== After ========================
import { configureStore } from "@reduxjs/toolkit";
import { rootReducer } from "./reducer";

const store = configureStore({
  reducer: rootReducer,
});

На перший погляд, практично одне й теж, проте, відразу були налаштовані інструменти розробника (Redux DevTools) 
та деякі інші корисні функції, наприклад перевірка поширених помилок, таких як мутація стану в редюсерах чи використання 
невалідних значень у стані.

Також функція configureStore() може автоматично створити кореневий редюсер. Для цього необхідно передати властивості reducer 
об'єкт тієї ж форми що в combineReducers. Для початку видалимо створення кореневого редюсера в нашому коді програми та додамо 
імпорти редюсерів завдань та фільтрів із файлу src/redux/reducer.js. Опустимо не критичний вихідний код для того, щоб скоротити обсяг прикладів.

src/redux/reducer.js

//=============== Before ========================
import { combineReducers } from "redux";
import { statusFilters } from "./constants";

const tasksInitialState = [];

const tasksReducer = (state = tasksInitialState, action) => {
  // Reducer code
};

const filtersInitialState = {
  status: statusFilters.all,
};

const filtersReducer = (state = filtersInitialState, action) => {
  // Reducer code
};

export const rootReducer = combineReducers({
  tasks: tasksReducer,
  filters: filtersReducer,
});

//=============== After ========================
import { statusFilters } from "./constants";

const tasksInitialState = [];

export const tasksReducer = (state = tasksInitialState, action) => {
  // Reducer code
};

const filtersInitialState = {
  status: statusFilters.all,
};

export const filtersReducer = (state = filtersInitialState, action) => {
  // Reducer code
};
Тепер у файлі створення стора імпортуємо та використовуємо окремі редюсери.

src/redux/store.js

import { configureStore } from "@reduxjs/toolkit";
import { tasksReducer, filtersReducer } from "./reducer";

export const store = configureStore({
  reducer: {
    tasks: tasksReducer,
    filters: filtersReducer,
  },
});
*/

/**
  |============================
  | createAction
  |============================
*/
/* 
Функція [createAction(type)](<https://redux-toolkit.js.org/api/createAction>) 
спрощує процес оголошення екшенів. В якості аргументу вона приймає рядок який описує тип дії та повертає генератор екшену.


src/redux/actions.js

//=============== Before ========================
const addTask = text => {
  return { type: "tasks/AddTask", payload: text };
};

console.log(addTask("Learn Redux Toolkit"));
// {type: "tasks/addTask", payload: "Learn Redux Toolkit"}

//=============== After ========================
import { createAction } from "@reduxjs/toolkit";

const addTask = createAction("tasks/AddTask");

console.log(addTask("Learn Redux Toolkit"));
// {type: "tasks/addTask", payload: "Learn Redux Toolkit"}
Додамо код створення інших генераторів екшенів для нашої програми. Використання createAction() позбавить нас від 
повторюваного шаблонного коду оголошення генератора екшену.

src/redux/actions.js

import { createAction } from "@reduxjs/toolkit";
export const addTask = createAction("tasks/addTask");
export const deleteTask = createAction("tasks/deleteTask");
export const toggleCompleted = createAction("tasks/toggleCompleted");
export const setStatusFilter = createAction("filters/setStatusFilter");

Тип екшену

Є два способи отримати тип екшену, наприклад, для використання в редюсері.

import { createAction } from "@reduxjs/toolkit";

const addTask = createAction("tasks/AddTask");

// У генератора екшену є властивість type
console.log(addTask.type); // "tasks/AddTask"

// Метод toString() функції addTask був перевизначений
console.log(addTask.toString()); // "tasks/AddTask"

У редюсері імпортуємо екшени та використовуємо їх властивість type для заміни рядків всередині інструкції switch.

src/redux/reducer.js

import { addTask, deleteTask, toggleCompleted } from "./actions";

export const tasksReducer = (state = tasksInitialState, action) => {
  switch (action.type) {
    case addTask.type:
      return [...state, action.payload];

    case deleteTask.type:
      return state.filter(task => task.id !== action.payload);

    case toggleCompleted.type:
      return state.map(task => {
        if (task.id !== action.payload) {
          return task;
        }
        return { ...task, completed: !task.completed };
      });

    default:
      return state;
  }
};

Вміст payload
За замовчуванням генератори екшенів приймають один аргумент, який стає значенням властивості payload. 
Якщо потрібно написати додаткову логіку створення значення payload, наприклад, додати унікальний ідентифікатор, 
createAction можна передати другий, необов'язковий аргумент - функцію створення екшену.

createAction(type, prepareAction)
Аргументи генератора екшену будуть передані функції prepareAction, яка повинна повернути об'єкт із властивістю payload. 
Властивість type буде додано автоматично.

src/redux/actions.js

import { createAction, nanoid } from "@reduxjs/toolkit";

export const addTask = createAction("tasks/addTask", text => {
  return {
    payload: {
      text,
      id: nanoid(),
      completed: false,
    },
  };
});

console.log(addTask("Learn Redux Toolkit"));
/**
 * {
 *   type: 'tasks/addTask',
 *   payload: {
 *     text: 'Learn Redux Toolkit',
 *     id: '4AJvwMSWEHCchcWYga3dj',
 *     completed: false
 *   }
 * }
 **/

/**
   |============================
   | createReducer
   |============================
 */
/* 
Будь-який редюсер отримує стан Redux і екшен, перевіряє тип екшену всередині інструкції switch і виконує відповідну
логіку оновлення стану для даного екшену. До того ж, редюсер визначає початкове значення стану та повертає отриманий стан, 
якщо не повинен обробляти екшен. Цей спосіб вимагає занадто багато шаблонного коду і схильний до помилок. 
Функція [createReducer()](<https://redux-toolkit.js.org/api/createReducer>) спрощує процес оголошення редюсерів.

createReducer(initialState, builderCallback)

Перший параметр initialState очікує початковий стан редюсера, а другий
параметр - функцію зворотнього виклику builderCallback, за допомогою якої
визначається редюсер для кожного екшена.

createReducer({}, builder => {
  builder.addCase(actionType, (state, action) => {});
});

Функція зворотнього виклику builderCallback оголошує один параметр builder - об'єкт із методами, за допомогою яких (addCase) 
ми реєструємо редюсери для екшенів. Тобто кожен case з switch стає викликом addCase, для якого написаний власний міні-редюсер.

addCase(action, reducer)

Замінимо код оголошення редюсера завдань у нашому додатку використовуючи createReducer.

src/redux/reducer.js

import { createReducer } from "@reduxjs/toolkit";
import { statusFilters } from "./constants";
import { addTask, deleteTask, toggleCompleted } from "./actions";

const tasksInitialState = [];

//=============== Before ========================
const tasksReducer = (state = tasksInitialState, action) => {
  switch (action.type) {
    case addTask.type:
    // case logic
    case deleteTask.type:
    // case logic
    case toggleCompleted.type:
    // case logic
    default:
      return state;
  }
};

//=============== After ========================
export const tasksReducer = createReducer(tasksInitialState, builder => {
  builder
    .addCase(addTask, (state, action) => {})
    .addCase(deleteTask, (state, action) => {})
    .addCase(toggleCompleted, (state, action) => {});
});


Зверніть увагу на те, що не потрібен аналог default. Функція createReducer

автоматично додає обробку поведінки за замовчуванням.



 ПРИВЕДЕННЯ ДО РЯДКА
Першим аргументом, який передається до addCase, є посилання на функцію
створення екшена. Вона перетворюється у рядок, тобто у значення властивості
type, оскільки метод toString() генератора екшену було перевизначено так,
щоб повертати тип екшену.

Всередині кожного міні-редюсера додаємо код оновлення стану для екшену з відповідним типом.

src/redux/reducer.js

export const tasksReducer = createReducer(tasksInitialState, builder => {
  builder
    .addCase(addTask, (state, action) => {
      return [...state, action.payload];
    })
    .addCase(deleteTask, (state, action) => {
      return state.filter(task => task.id !== action.payload);
    })
    .addCase(toggleCompleted, (state, action) => {
      return state.map(task => {
        if (task.id !== action.payload) {
          return task;
        }
        return {
          ...task,
          completed: !task.completed,
        };
      });
    });
});

export const filtersReducer = createReducer(filtersInitialState, builder => {
  builder.addCase(setStatusFilter, (state, action) => {
    return {
      ...state,
      status: action.payload,
    };
  });
});

Один із фундаментальних принципів Redux полягає в тому, що редюсери повинні бути чистими функціями, які не змінюють 
поточний стан, а повертають новий. Це дозволяє писати передбачуваний код, але іноді сильно ускладнює його, оскільки 
код іммутального оновлення стану може бути досить заплутаним.


Бібліотека Immer
Redux Toolkit «під капотом» використовує бібліотеку Immer, яка значно спрощує логіку роботи зі станом, дозволяючи нам 
писати код оновлення стану в редюсері так, ніби ми безпосередньо змінювали стан. Насправді редюсери отримують копію стану, 
а Immer перетворює всі мутації на еквівалентні операції оновлення.

src/redux/reducer.js

export const tasksReducer = createReducer(tasksInitialState, builder => {
  builder
    .addCase(addTask, (state, action) => {
      // ✅ Immer замінить це на операцію оновлення
      state.push(action.payload);
    })
    .addCase(deleteTask, (state, action) => {
      // ✅ Immer замінить це на операцію оновлення
      const index = state.findIndex(task => task.id === action.payload);
      state.splice(index, 1);
    })
    .addCase(toggleCompleted, (state, action) => {
      // ✅ Immer замінить це на операцію оновлення
      for (const task of state) {
        if (task.id === action.payload) {
          task.completed = !task.completed;
        }
      }
    });
});

export const filtersReducer = createReducer(filtersInitialState, builder => {
  builder.addCase(setStatusFilter, (state, action) => {
    // ✅ Immer замінить це на операцію оновлення
    state.status = action.payload;
  });
});

Написання редюсерів «змінюючих» стан робить код коротшим і усуває поширені помилки, які допускаються під час роботи 
з вкладеним станом. Однак це додає «магії» і візуально порушує один із фундаментальних принципів Redux.

Зміна або оновлення

Іноді код іммутабельного оновлення стану лаконічніший, ніж його альтернатива, що «змінює». 
Наприклад, у редюсері обробки екшену видалення завдання. У такому разі необхідно обов'язково повернути новий стан.

src/redux/reducer.js

export const tasksReducer = createReducer(tasksInitialState, builder => {
  builder.addCase(deleteTask, (state, action) => {
    // ❌ Не правильно
    // state.filter(task => task.id !== action.payload)

    // ✅ Правильно
    return state.filter(task => task.id !== action.payload);
  });
});

Зміна чи повернення

Один із підводних каменів бібліотеки Immer полягає в тому, що в коді одного редюсера можна лише або мутувати стан, 
або повернути оновлений, але не те й інше водночас.

const reducer = createReducer([], builder => {
  builder.addCase(doSomething, (state, action) => {
    // ❌ Так робити не можна, буде згенеровано виняток
    state.push(action.payload);
    return state.map(value => value * 2);
  });
});
*/

/**
  |============================
  | createSlice
  |============================
*/
/* 
При проектуванні структура стану Redux ділиться на слайси (slice, частина), за кожен із яких відповідає окремий редюсер. 
У нашому додатку планувальника задач є два слайси - завдання (tasks) та фільтри (filters).

const appState = {
  tasks: [],
  filters: {},
};

Для кожного слайсу створюється стандартний набір сутностей: типи екшенів, генератори екшенів та редюсер. 
Редюсери визначають початковий стан слайсу, список екшенів, що впливають на нього та операції оновлення стану.

Функція [createSlice()](<https://redux-toolkit.js.org/api/createSlice>) це надбудова над createAction() та createReducer(), 
яка стандартизує та ще більше спрощує оголошення слайсу. Вона приймає параметри налаштувань, створює і повертає типи екшенів, 
генератори екшенів та редюсер. Розберемо створення слайсу на прикладі списку задач.

import { createSlice } from "@reduxjs/toolkit";

const tasksSlice = createSlice({
  // Ім'я слайсу
  name: "tasks",
  // Початковий стан редюсера слайсу
  initialState: tasksInitialState,
  // Об'єкт редюсерів
  reducers: {
    addTask(state, action) {},
    deleteTask(state, action) {},
    toggleCompleted(state, action) {},
  },
});

// Генератори екшенів
const { addTask, deleteTask, toggleCompleted } = tasksSlice.actions;
// Редюсер слайсу
const tasksReducer = tasksSlice.reducer;
Властивість name визначає ім'я слайсу, яке додаватиметься під час створення екшенів, як приставка до імен редюсерів, оголошених 
у властивості reducers. Так ми отримаємо екшени з типами tasks/addTask, tasks/deleteTask та tasks/toggleCompleted.

Функція createSlice() у своїй реалізації використовує createReducer і бібліотеку Immer, тому можна писати логіку оновлення стану так, 
як якби ми безпосередньо змінювали його.

import { createSlice } from "@reduxjs/toolkit";

const tasksInitialState = [];

const tasksSlice = createSlice({
  name: "tasks",
  initialState: tasksInitialState,
  reducers: {
    addTask(state, action) {
      state.push(action.payload);
    },
    deleteTask(state, action) {
      const index = state.findIndex(task => task.id === action.payload);
      state.splice(index, 1);
    },
    toggleCompleted(state, action) {
      for (const task of state) {
        if (task.id === action.payload) {
          task.completed = !task.completed;
          break;
        }
      }
    },
  },
});

const { addTask, deleteTask, toggleCompleted } = tasksSlice.actions;
const tasksReducer = tasksSlice.reducer;


Вміст payload



Генератор екшену addTask очікує лише рядок з текстом завдання, після чого змінює значення payload використовуючи функцію 
підготовки екшену. Ось як це виглядає зараз у нашому коді.



src/redux/actions.js

import { createAction, nanoid } from "@reduxjs/toolkit";

export const addTask = createAction("tasks/addTask", text => {
  return {
    payload: {
      text,
      id: nanoid(),
      completed: false,
    },
  };
});


Щоб зробити те саме при створенні слайсу, властивості в об'єкті редюсерів, в нашому випадку addTask, необхідно передати не 
функцію, а об'єкт із двома властивостями - reducer та prepare.



import { createSlice, nanoid } from "@reduxjs/toolkit";

const tasksSlice = createSlice({
  name: "tasks",
  initialState: tasksInitialState,
  reducers: {
    addTask: {
      reducer(state, action) {
        state.push(action.payload);
      },
      prepare(text) {
        return {
          payload: {
            text,
            id: nanoid(),
            completed: false,
          },
        };
      },
    },
    // Код решти редюсерів
  },
});


Файли слайсів



Нам більше не потрібний файл reducer.js, тому що під кожен слайс ми створимо окремий файл. Для слайсу завдань це буде файл 
tasksSlice.js .



src/redux/tasksSlice.js

import { createSlice } from "@reduxjs/toolkit";

const tasksInitialState = [];

const tasksSlice = createSlice({
  name: "tasks",
  initialState: tasksInitialState,
  reducers: {
    addTask: {
      reducer(state, action) {
        state.push(action.payload);
      },
      prepare(text) {
        return {
          payload: {
            text,
            id: nanoid(),
            completed: false,
          },
        };
      },
    },
    deleteTask(state, action) {
      const index = state.findIndex(task => task.id === action.payload);
      state.splice(index, 1);
    },
    toggleCompleted(state, action) {
      for (const task of state) {
        if (task.id === action.payload) {
          task.completed = !task.completed;
          break;
        }
      }
    },
  },
});

// Експортуємо генератори екшенів та редюсер
export const { addTask, deleteTask, toggleCompleted } = tasksSlice.actions;
export const tasksReducer = tasksSlice.reducer;


Та файл filtersSlice.js для слайсу фільтрів.



src/redux/filtersSlice.js

import { createSlice } from "@reduxjs/toolkit";
import { statusFilters } from "./constants";

const filtersInitialState = {
  status: statusFilters.all,
};

const filtersSlice = createSlice({
  name: "filters",
  initialState: filtersInitialState,
  reducers: {
    setStatusFilter(state, action) {
      state.status = action.payload;
    },
  },
});

// Експортуємо генератори екшенів та редюсер
export const { setStatusFilter } = filtersSlice.actions;
export const filtersReducer = filtersSlice.reducer;


Створення стора



У файлі створення стора необхідно змінити код імпорту редюсерів.



src/redux/store.js

import { configureStore } from "@reduxjs/toolkit";

//=============== Before ========================
import { tasksReducer, filtersReducer } from "./reducer";

//=============== After ========================
import { tasksReducer } from "./tasksSlice";
import { filtersReducer } from "./filtersSlice";

export const store = configureStore({
  reducer: {
    tasks: tasksReducer,
    filters: filtersReducer,
  },
});
Генератори екшенів

Генератори екшенів тепер створюються автоматично для кожного слайсу. Це означає, що нам більше не потрібно вручну оголошувати 
їх в окремому файлі. createAction(). Ми можемо видалити файл actions.js та оновити імпорти генераторів екшенів у файлах компонентів. 

Імпорти генераторів екшенів виготовляються з відповідного файлу слайсу.


//=============== Before ========================
import { deleteTask, toggleCompleted } from "redux/actions";

//=============== After ========================
import { deleteTask, toggleCompleted } from "redux/tasksSlice";
*/

/**
  |============================
  | Асинхронні операції
  |============================
*/
/* 
Досі ми працювали з локальними даними, що зберігаються в пам'яті вкладки браузера або локального сховища. 
На практиці переважна більшість даних програми зберігається в базі даних на бекенді та будь-які операції над ними виконуються 
за допомогою HTTP-запитів.

HTTP-запити це асинхронні операції, які представлені промісами, тому їх можна розбити на три складові: процес запиту (pending), 
успішне завершення запиту (fulfilled) та завершення запиту з помилкою (rejected). 
Цей шаблон застосуємо до будь-яких запитів читання, створення, видалення та оновлення.
*/
/**
  |============================
  | Операції
  |============================
*/
/* 
Розглянемо завдання, що часто зустрічається, завантаження даних, обробки індикатора завантаження та помилки виконання запиту. 
Оголосимо слайс списку завдань, у стані якого будемо зберігати масив завдань, прапор статусу завантаження та дані можливої помилки.

src/redux/tasksSlice.js

const tasksSlice = {
name: "tasks",
initialState: {
items: [],
isLoading: false,
error: null,
},
reducers: {},
};
Додамо редюсер для обробки кожного з можливих станів запиту.

src/redux/tasksSlice.js

const tasksSlice = {
name: "tasks",
initialState: {
items: [],
isLoading: false,
error: null,
},
reducers: {
// Виконається в момент старту HTTP-запиту
fetchingInProgress(state) {},
// Виконається якщо HTTP-запит завершився успішно
fetchingSuccess() {},
// Виконається якщо HTTP-запит завершився з помилкою
fetchingError() {},
},
};

У редюсерах змінюємо відповідні частини стану. Прапор завантаження isLoading встановлюємо в true на старті запиту, 
та false у будь-якому іншому випадку, тому що запит завершено. При виконанні запиту з помилкою змінюємо значення властивості 
error, записавши в нього те, що прийде в action.payload - інформація про помилку. У разі успішного виконання запиту, 
скидаємо значення помилки та записуємо в items отримані дані з action.payload - масив завдань.

src/redux/tasksSlice.js

const tasksSlice = {
  name: "tasks",
  initialState: {
    items: [],
    isLoading: false,
    error: null,
  },
  reducers: {
    fetchingInProgress(state) {
      state.isLoading = true;
    },
    fetchingSuccess(state, action) {
      state.isLoading = false;
      state.error = null;
      state.items = action.payload;
    },
    fetchingError(state, action) {
      state.isLoading = false;
      state.error = action.payload;
    },
  },
};

export const { fetchingInProgress, fetchingSuccess, fetchingError } =
  tasksSlice.actions;

Для того, щоб при відправленні екшену виконати асинхронний код, необхідно оголосити «операцію» - асинхронний генератор екшену, 
в тілі якого викликаються інші, синхронні генератори екшенів. Операція не повертає екшен замість цього вона повертає іншу 
функцію, яка аргументом набуває вже знайомий нам dispatch. У тілі цієї функції можна виконувати асинхронні дії, наприклад, 
HTTP-запит. Для запитів використовуємо бібліотеку axios.

src/redux/operations.js

import axios from "axios";

axios.defaults.baseURL = "<https://62584f320c918296a49543e7.mockapi.io>";

const fetchTasks = () => async dispatch => {
  try {
    const response = await axios.get("/tasks");
  } catch (e) {}
};
*/

/**
  |============================
  | REDUX THUNK
  |============================
*/
/*
 
Можливість оголошувати асинхронні генератори екшенів та виконувати асинхронні дії надає розширення стора 
https://github.com/reduxjs/redux-thunk, яке за умовчанням включено до Redux Toolkit.

Тепер усередині операції надсилаємо синхронні екшени для обробки трьох ситуацій: встановлення індикатора завантаження, 
отримання даних при успішному запиті та обробка помилки.

src/redux/operations.js

import axios from "axios";
import {
  fetchingInProgress,
  fetchingSuccess,
  fetchingError,
} from "./tasksSlice";

axios.defaults.baseURL = "<https://62584f320c918296a49543e7.mockapi.io>";

export const fetchTasks = () => async dispatch => {
  try {
    // Індикатор завантаження
    dispatch(fetchingInProgress());
    // HTTP-запит
    const response = await axios.get("/tasks");
    // Обробка даних
    dispatch(fetchingSuccess(response.data));
  } catch (e) {
    // Обробка помилки
    dispatch(fetchingError(e.message));
  }
};
Далі додамо мінімальний код виклику асинхронного генератора екшену в компоненті, рендер індикатора завантаження, 
даних та обробку помилки.

src/components/App.js

import { useEffect } from "react";
import { useDispatch, useSelector } from "react-redux";
import { fetchTasks } from "redux/operations";
import { getTasks } from "redux/selectors";

export const App = () => {
  const dispatch = useDispatch();
  // Отримуємо частини стану
  const { items, isLoading, error } = useSelector(getTasks);

  // Викликаємо операцію
  useEffect(() => {
    dispatch(fetchTasks());
  }, [dispatch]);

  // Рендерим розмітку в залежності від значень у стані
  return (
    <div>
      {isLoading && <p>Loading tasks...</p>}
      {error && <p>{error}</p>}
      <p>{items.length > 0 && JSON.stringify(items, null, 2)}</p>
    </div>
  );
};

Розберіть код живого прикладу. При монтуванні компонента App спочатку відображається індикатор завантаження, а через 
якийсь час масив завдань. Для того щоб оновити сторінку прикладу в пісочниці, натисніть кнопку оновлення в нижній 
частини його вікна.

*/

/**
  |============================
  | createAsyncThunk
  |============================
*/
/* 
Redux Toolkit спрощує процес оголошення асинхронного генератора екшену за допомогою функції [createAsyncThunk()]
(<https://redux-toolkit.js.org/api/createAsyncThunk>). Першим аргументом вона приймає тип екшену, а другим функцію, 
яка повинна виконати HTTP-запит і повернути проміс із даними, які стануть значенням payload. Вона повертає асинхронний 
генератор екшену (операцію) при запуску якого виконається функція з кодом запиту.

src/redux/operations.js

import axios from "axios";
import { createAsyncThunk } from "@reduxjs/toolkit";

axios.defaults.baseURL = "<https://62584f320c918296a49543e7.mockapi.io>";

export const fetchTasks = createAsyncThunk("tasks/fetchAll", async () => {
  const response = await axios.get("/tasks");
  return response.data;
});
Функція createAsyncThunk() автоматично створює екшени, що представляють життєвий цикл HTTP-запиту, і відправляє їх у 
правильному порядку, залежно від статусу запиту. Тип створених екшенів складається з рядка, зазначеного першим аргументом 
("tasks/fetchAll"), до якого додається постфікси "pending", "fulfilled" або "rejected", залежно від того, який стан запиту 
описує екшен.

"tasks/fetchAll/pending" - початок запиту
"tasks/fetchAll/fulfilled" - успішне завершення запиту
"tasks/fetchAll/rejected" - завершення запиту з помилкою

Замінивши в нашому прикладі код оголошення операції fetchTasks та перезавантаживши сторінку в інструментах розробника видно, 
як при монтуванні компонента App відправляються екшени з правильними типами та payload.

Функція createAsyncThunk не створює редюсер, тому що не може знати, як ми хочемо відстежувати стан завантаження, 
з якими даними завершиться запит та як їх правильно обробити. Тому наступним кроком буде зміна коду слайсу tasksSlice так, 
щоб він обробляв нові екшени.

src/redux/tasksSlice.js

import { createSlice } from "@reduxjs/toolkit";
// Імпортуємо операцію
import { fetchTasks } from "./operations";

const tasksSlice = createSlice({
  name: "tasks",
  initialState: {
    items: [],
    isLoading: false,
    error: null,
  },
  // Додаємо обробку зовнішніх екшенів
  extraReducers: builder => {
    builder
      .addCase(fetchTasks.pending, (state, action) => {})
      .addCase(fetchTasks.fulfilled, (state, action) => {})
      .addCase(fetchTasks.rejected, (state, action) => {});
  }
});

export const tasksReducer = tasksSlice.reducer;
Властивість extraReducers використовується щоб оголосити редюсери для «зовнішніх» типів екшенів, тобто тих, які не згенеровані 
з властивості reducers. Оскільки ці редюсери обробляють «зовнішні» екшени, для них не буде створено генератори екшенів в 
slice.actions, в цьому немає необхідності.

ЕКШЕНИ ОПЕРАЦІЇ
Генератори екшенів, які мають життєвий цикл запиту, зберігаються в об'єкті операції як властивості pending, fulfilled та rejected. 
Вони автоматично створюються за допомогою createAction і тому мають властивість type і перевизначений метод toString(), 
який повертає рядок типу екшену.

Властивість reducers нам більше не потрібна, тому всю логіку обробки екшенів запиту переносимо до нових редюсерів.

src/redux/tasksSlice.js

import { createSlice } from "@reduxjs/toolkit";
import { fetchTasks } from "./operations";

const tasksSlice = createSlice({
  name: "tasks",
  initialState: {
    items: [],
    isLoading: false,
    error: null,
  },
  extraReducers: builder => {
    builder
      .addCase(fetchTasks.pending, (state, action) => {
        state.isLoading = true;
      })
      .addCase(fetchTasks.fulfilled, (state, action) => {
        state.isLoading = false;
        state.error = null;
        state.items = action.payload;
      })
      .addCase(fetchTasks.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload;
      });
  }
});

export const tasksReducer = tasksSlice.reducer;
Залишилося додати обробку запиту, що завершився з помилкою. Для цього необхідно доповнити код створення операції fetchTasks 
так, щоб у випадку помилки запиту повертався проміс, який буде відхилено. Тоді на екшені помилки запиту з'явиться властивість 
payload.


src/redux/operations.js

import { createAsyncThunk } from "@reduxjs/toolkit";
import axios from "axios";

axios.defaults.baseURL = "<https://62584f320c918296a49543e7.mockapi.io>";

export const fetchTasks = createAsyncThunk(
  "tasks/fetchAll",
  // Використовуємо символ підкреслення як ім'я першого параметра,
  // тому що в цій операції він нам не потрібен
  async (_, thunkAPI) => {
    try {
      const response = await axios.get("/tasks");
      // При успішному запиті повертаємо проміс із даними
      return response.data;
    } catch (e) {
      // При помилці запиту повертаємо проміс
      // який буде відхилений з текстом помилки
      return thunkAPI.rejectWithValue(e.message);
    }
  }
);

Колбек функція, в якій виконується запит, називається payloadCreator і відповідає за складання значення властивості payload. 
Вона буде викликана з двома аргументами: arg та thunkAPI.

payloadCreator(arg, thunkAPI)
arg - значення, яке було передано операції під час виклику. Використовується, наприклад, для передачі ідентифікаторів об'єктів 
при видаленні, тексту нотаток при створенні, тощо.
thunkAPI - об'єкт, який передається в асинхронний генератор екшену в redux-thunk. Містить властивості та методи доступу до стору, 
відправки екшенів, а також деякі додаткові.
*/
/**
  |============================
  | Планувальник завдань
  |============================
*/
/* 
Змінимо код нашої програми так, щоб працювати з даними від бекенда. Для цього використовуємо сервіс 
[mockapi.io](<https://mockapi.io/>), котрий надає візуальний інтерфейс для створення простого бекенду з базою даних. 
Це дозволить нам виконувати CRUD операції з масивом об'єктів.

Селектори
Через те, що у нас змінилася форма стану, необхідно доповнити файл селекторів.

src/redux/selectors.js

export const getTasks = state => state.tasks.items;
export const getIsLoading = state => state.tasks.isLoading;
export const getError = state => state.tasks.error;
export const getStatusFilter = state => state.filters.status;

Читання завдань
Операція та редюсери для читання масиву завдань у нас уже є. Доповнимо компонент App так, щоб при його монтуванні 
запускалася операція запиту за списком задач.

src/components/App.js

import { useEffect } from "react";
import { useDispatch } from "react-redux";
import { fetchTasks } from "redux/operations";
// Імпорти компонентів

export const App = () => {
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(fetchTasks());
  }, [dispatch]);

  return (
    <Layout>
      <AppBar />
      <TaskForm />
      <TaskList />
    </Layout>
  );
};
Після монтування компонента App та завершення запиту, в інтерфейсі відобразиться список завдань - компонент TaskList, який 
використовує селектори для отримання масиву завдань із стану Redux.

Індикатор запиту
Додамо відображення індикатора запиту над списком завдань.
src/components/App.js

import { useEffect } from "react";
import { useDispatch, useSelector } from "react-redux";
import { fetchTasks } from "redux/operations";
import { getError, getIsLoading } from "redux/selectors";
// Імпорти компонентів

export const App = () => {
  const dispatch = useDispatch();
  const isLoading = useSelector(getIsLoading);
  const error = useSelector(getError);

  useEffect(() => {
    dispatch(fetchTasks());
  }, [dispatch]);

  return (
    <Layout>
      <AppBar />
      <TaskForm />
      {isLoading && !error && <b>Request in progress...</b>}
      <TaskList />
    </Layout>
  );
};


Додавання завдання
Оголосимо операцію додавання задачі, яка очікує тільки введений текст користувачем. За створення унікального ідентифікатора 
та додавання властивості completed тепер відповідатиме бекенд.

src/redux/operations.js

export const addTask = createAsyncThunk(
  "tasks/addTask",
  async (text, thunkAPI) => {
    try {
      const response = await axios.post("/tasks", { text });
      return response.data;
    } catch (e) {
      return thunkAPI.rejectWithValue(e.message);
    }
  }
);

У компоненті TaskForm додаємо код запуску операції додавання завдання при сабміть форми.
src/components/TaskForm/TaskForm.js

import { useDispatch } from "react-redux";
import { addTask } from "redux/operations";

export const TaskForm = () => {
  const dispatch = useDispatch();

  const handleSubmit = event => {
    event.preventDefault();
    const form = event.target;
    dispatch(addTask(event.target.elements.text.value));
    form.reset();
  };

  // Решта коду компонента
};

Додамо в слайс tasksSlice код обробки екшенів додавання завдання.
src/redux/tasksSlice.js

import { createSlice } from "@reduxjs/toolkit";
import { fetchTasks, addTask } from "./operations";


const tasksSlice = createSlice({
  extraReducers: builder => {
    builder
      .addCase(addTask.pending, state => {
        state.isLoading = true;
      })
      .addCase(addTask.fulfilled, (state, action) => {
        state.isLoading = false;
        state.error = null;
        state.items.push(action.payload);
      })
      .addCase(addTask.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload;
      });
    // Код решти редюсерів
  },
});


Видалення завдання
Оголосимо операцію видалення, яка чекає лише на ідентифікатор видаленого завдання.
src/redux/operations.js

export const deleteTask = createAsyncThunk(
  "tasks/deleteTask",
  async (taskId, thunkAPI) => {
    try {
      const response = await axios.delete(`/tasks/${taskId}`);
      return response.data;
    } catch (e) {
      return thunkAPI.rejectWithValue(e.message);
    }
  }
);


У компоненті Task додаємо код запуску операції видалення завдання при натисканні на кнопку видалення, і передаємо їй ідентифікатор.
src/components/Task/Task.js

import { useDispatch } from "react-redux";
import { MdClose } from "react-icons/md";
import { deleteTask } from "redux/operations";

export const Task = ({ task }) => {
  const dispatch = useDispatch();

  const handleDelete = () => dispatch(deleteTask(task.id));

  return (
    <div>
      <input type="checkbox" checked={task.completed} />
      <p>{task.text}</p>
      <button onClick={handleDelete}>
        <MdClose size={24} />
      </button>
    </div>
  );
};

Додамо в слайс tasksSlice код обробки екшенів видалення завдання.
src/redux/tasksSlice.js

import { createSlice } from "@reduxjs/toolkit";
import { fetchTasks, addTask, deleteTask } from "./operations";


const tasksSlice = createSlice({
  extraReducers: builder => {
    builder
      .addCase(deleteTask.pending, state => {
        state.isLoading = true;
      })
      .addCase(deleteTask.fulfilled, (state, action) => {
        state.isLoading = false;
        state.error = null;
        const index = state.items.findIndex(
          task => task.id === action.payload.id
        );
        state.items.splice(index, 1);
      })
      .addCase(deleteTask.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload;
      });
    // Код решти редюсерів
  },
});


export const tasksReducer = tasksSlice.reducer;


Переключення статусу завдання



Оголосимо операцію зміни статусу, яка чекає на весь об'єкт завдання.



src/redux/operations.js

export const toggleCompleted = createAsyncThunk(
  "tasks/toggleCompleted",
  async (task, thunkAPI) => {
    try {
      const response = await axios.put(`/tasks/${task.id}`, {
        completed: !task.completed,
      });
      return response.data;
    } catch (e) {
      return thunkAPI.rejectWithValue(e.message);
    }
  }
);

У компоненті Task додаємо код запуску операції зміни статусу під час кліку по чекбоксу, і передаємо їй весь об'єкт завдання.
src/components/TaskForm/TaskForm.js

import { useDispatch } from "react-redux";
import { MdClose } from "react-icons/md";
import { deleteTask, toggleCompleted } from "redux/operations";

export const Task = ({ task }) => {
  const dispatch = useDispatch();

  const handleDelete = () => dispatch(deleteTask(task.id));

  const handleToggle = () => dispatch(toggleCompleted(task));

  return (
    <div>
      <input type="checkbox" checked={task.completed} onChange={handleToggle} />
      <p>{task.text}</p>
      <button onClick={handleDelete}>
        <MdClose size={24} />
      </button>
    </div>
  );
};


Додамо в слайс tasksSlice код обробки екшенів зміни статусу завдання.



src/redux/tasksSlice.js

import { createSlice } from "@reduxjs/toolkit";
import { fetchTasks, addTask, deleteTask, toggleCompleted } from "./operations";


const tasksSlice = createSlice({
  extraReducers: builder => {
    builder
      .addCase(toggleCompleted.pending, state => {
        state.isLoading = true;
      })
      .addCase(toggleCompleted.fulfilled, (state, action) => {
        state.isLoading = false;
        state.error = null;
        const index = state.items.findIndex(
          task => task.id === action.payload.id
        );
        state.items.splice(index, 1, action.payload);
      })
      .addCase(toggleCompleted.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload;
      });
    // Код решти редюсерів
  },
});


export const tasksReducer = tasksSlice.reducer;


Скорочуємо код редюсерів



Ви напевно вже звернули увагу на те, що код редюсерів, які обробляють pending та rejected екшени всіх операцій, ідентичний. 
Винесемо логіку цих редюсерів у функції, що допоможе нам скоротити дублювання коду.



src/redux/tasksSlice.js

const handlePending = state => {
  state.isLoading = true;
};


const handleRejected = (state, action) => {
  state.isLoading = false;
  state.error = action.payload;
};


const tasksSlice = createSlice({
  name: "tasks",
  initialState: {
    items: [],
    isLoading: false,
    error: null,
  },
  extraReducers: builder => {
    builder
      .addCase(fetchTasks.pending, handlePending)
      .addCase(fetchTasks.fulfilled, (state, action) => {
        state.isLoading = false;
        state.error = null;
        state.items = action.payload;
      })
      .addCase(fetchTasks.rejected, handleRejected)
      .addCase(addTask.pending, handlePending)
      .addCase(addTask.fulfilled, (state, action) => {
        state.isLoading = false;
        state.error = null;
        state.items.push(action.payload);
      })
      .addCase(addTask.rejected, handleRejected)
      .addCase(deleteTask.pending, handlePending)
      .addCase(deleteTask.fulfilled, (state, action) => {
        state.isLoading = false;
        state.error = null;
        const index = state.items.findIndex(
          task => task.id === action.payload.id
        );
        state.items.splice(index, 1);
      })
      .addCase(deleteTask.rejected, handleRejected)
      .addCase(toggleCompleted.pending, handlePending)
      .addCase(toggleCompleted.fulfilled, (state, action) => {
        state.isLoading = false;
        state.error = null;
        const index = state.items.findIndex(
          task => task.id === action.payload.id
        );
        state.items.splice(index, 1, action.payload);
      })
      .addCase(toggleCompleted.rejected, handleRejected);
  },
});


export const tasksReducer = tasksSlice.reducer;
*/

/**
  |============================
  | Селектори
  |============================
*/
/* 
Ми з вами вже знаємо, що селектори це функції, які інкапсулюють у собі читання значень із стану Redux. 
У найпростішому вигляді вони очікують на поточний стан Redux та повертають необхідну його частину.

const valueSelector = state => state.some.value;

У компонентах ми використовуємо хук useSelector(selector), якому передаємо посилання на функцію селектор.
const value = useSelector(valueSelector);

Таким чином компоненти не знають про форму стану Redux та процес обчислення необхідного їм значення. 
При зміні структури стану необхідно буде оновити лише селектори, компоненти не будуть порушені. Це скорочує час 
необхідний на рефакторинг і підвищує стресоспроможність додатку. Селектори також скорочують дублювання коду, якщо один 
і той же селектор використовується в кількох компонентах.

 АБСТРАКЦІЯ
По суті селектори це прошарок абстракції, який мінімізує зв'язок між компонентами та стором Redux.
*/

/**
  |============================
  | Найменування
  |============================
*/
/* 
До цього моменту ми не замислювалися про імена селекторів. Тим не менш, один з пунктів офіційного посібника зі 
стилю коду Redux, містить інформацію про найкращі практики іменування селекторів. Рекомендується починати імена функцій 
селекторів приставкою select, після якої йде опис обраного значення.

Наразі файл із селекторами виглядає наступним чином. Ім'я кожного селектора ми починали з приставки get.
У цьому немає нічого поганого, головне однорідність коду в проекті.

src/redux/selectors.js

export const getTasks = state => state.tasks.items;
export const getIsLoading = state => state.tasks.isLoading;
export const getError = state => state.tasks.error;
export const getStatusFilter = state => state.filters.status;

Тим не менш, слідуватимемо кращим практикам з керівництва за стилем коду та замінимо префікс на select.

src/redux/selectors.js

export const selectTasks = state => state.tasks.items;
export const selectIsLoading = state => state.tasks.isLoading;
export const selectError = state => state.tasks.error;
export const selectStatusFilter = state => state.filters.status;

Після зміни імен селекторів потрібно оновити код імпорту у файлах компонентів.


//=============== Before ========================
import {
  getTasks,
  getIsLoading,
  getError,
  getStatusFilter,
} from "redux/selectors";

//=============== After ========================
import {
  selectTasks,
  selectIsLoading,
  selectError,
  selectStatusFilter,
} from "redux/selectors";
*/
/**
  |============================
  | Складові селектори
  |============================
*/
/* 
У найпростішому вигляді селектор отримує поточний стан та повертає його необхідну частину. 
Селектори це звичайні функції, а отже, в них можна виконувати якісь дії, крім повернення значення. 
Селектор може обчислювати значення використовуючи частини стану та повертати результат обчислень.

const selectTotalValue = state => {
const a = state.values.a;
const b = state.values.b;
return a + b;
};

Список завдань
У компоненті списку завдань TaskList у нас є код обчислення списку завдань які підходять під поточну умову фільтрації. 
Те, що робить функція getVisibleTasks може робити селектор, цим приховуючи від компонента логіку обчислення відфільтрованого 
списку завдань.

src/components/TaskList/TaskList.js

import { useSelector } from "react-redux";
import { selectTasks, selectStatusFilter } from "redux/selectors";
import { statusFilters } from "redux/constants";

const getVisibleTasks = (tasks, statusFilter) => {
  switch (statusFilter) {
    case statusFilters.active:
      return tasks.filter(task => !task.completed);
    case statusFilters.completed:
      return tasks.filter(task => task.completed);
    default:
      return tasks;
  }
};

export const TaskList = () => {
  const tasks = useSelector(selectTasks);
  const statusFilter = useSelector(selectStatusFilter);
  const visibleTasks = getVisibleTasks(tasks, statusFilter);

  // Рендер JSX розмітки
};

Оголосимо селектор selectVisibleTasks і перенесемо до нього логіку обчислення списку відфільтрованих завдань.
src/redux/selectors.js

import { statusFilters } from "./constants";
export const selectTasks = state => state.tasks.items;
export const selectIsLoading = state => state.tasks.isLoading;
export const selectError = state => state.tasks.error;
export const selectStatusFilter = state => state.filters.status;
export const selectVisibleTasks = state => {
// Використовуємо інші селектори
const tasks = selectTasks(state);
const statusFilter = selectStatusFilter(state);
switch (statusFilter) {
case statusFilters.active:
return tasks.filter(task => !task.completed);
case statusFilters.completed:
return tasks.filter(task => task.completed);
default:
return tasks;
}
};

Зверніть увагу на те, що ми використовуємо інші селектори selectTasks та selectStatusFilter всередині селектора 
selectVisibleTasks, щоб одержати необхідні частини стану для наступних обчислень.

 ТЕРМІНОЛОГІЯ 
 Селектори, які тільки повертають якусь частину стану, без додаткових обчислень, називатимемо «атомарними». 
 А ті, що повертають якісь значення, що обчислюються - «складовими».

Тепер код компонента TaskList буде значно простіше, бо ми винесли всю логіку у селектор. Компоненту залишається лише 
викликати селектор і використовувати отримане значення.

src/components/TaskList/TaskList.js

import { useSelector } from "react-redux";
import { selectVisibleTasks } from "redux/selectors";

export const TaskList = () => {
  const tasks = useSelector(selectVisibleTasks);

  // Рендер JSX розмітки
};

Лічильник завдань
Така сама ситуація в компоненті TaskCounter, де обчислюється кількість активних та виконаних завдань.
src/components/TaskCounter/TaskCounter.js

import { useSelector } from "react-redux";
import { selectTasks } from "redux/selectors";

export const TaskCounter = () => {
  const tasks = useSelector(selectTasks);

  const count = tasks.reduce(
    (acc, task) => {
      if (task.completed) {
        acc.completed += 1;
      } else {
        acc.active += 1;
      }
      return acc;
    },
    { active: 0, completed: 0 }
  );

  // Рендер JSX розмітки
};

Оголосимо складовий селектор selectTaskCount, який буде використовувати атомарний selectTasks для отримання списку всіх завдань 
та повертати результат обчислень.
src/redux/selectors.js

// Решта селекторів

export const selectTasks = state => state.tasks.items;

export const selectTaskCount = state => {
  const tasks = selectTasks(state);

  return tasks.reduce(
    (count, task) => {
      if (task.completed) {
        count.completed += 1;
      } else {
        count.active += 1;
      }
      return count;
    },
    { active: 0, completed: 0 }
  );
};

Тепер код компонента TaskCounter буде значно простіше, тому що ми винесли всю логіку до селектора. 
Компоненту залишається лише викликати селектор і використовувати отримане значення.



src/components/TaskCounter/TaskCounter.js

import { useSelector } from "react-redux";
import { selectTaskCount } from "redux/selectors";

export const TaskCounter = () => {
  const count = useSelector(selectTaskCount);

  // Рендер JSX розмітки
};
*/

/**
  |============================
  | Оптимізація
  |============================
*/
/* 
Атомарні селектори повертають частини стану, тому значення, що повертається оновлюється лише за зміни відповідної 
частини стану, навіть якщо це посилальний тип даних, тобто масив чи об'єкт. Складові селектори повертають значення, 
що обчислюються, і ці обчислення запускаються щоразу при оновленні стану.

Якщо зараз у код селектора selectTaskCount додати логування повідомлення, то ми побачимо його надто часто.
Цей селектор обчислює кількість активних та виконаних завдань навіть при зміні значення фільтра статусу, хоча це ніяк 
не впливає на масив завдань у стані Redux від якого залежать обчислення.

src/redux/selectors.js

export const selectTaskCount = state => {
  const tasks = selectTasks(state);

  console.log("Calculating task count");

  return tasks.reduce(
    (count, task) => {
      if (task.completed) {
        count.completed += 1;
      } else {
        count.active += 1;
      }
      return count;
    },
    { active: 0, completed: 0 }
  );
};

Додайте логування рядка до коду селектора, після чого відкрийте вкладку Console в інструментах розробника,
змінюйте значення фільтра та подивіться результат - повідомлення про обчислення кількості завдань, при цьому масив 
задач не змінюється. Те саме з селектором selectVisibleTasks.

 ВИСНОВОК
 Якщо селектор повертає посилальний тип або виконує якісь обчислення, його необхідно оптимізувати так, щоб ці обчислення 
 запускалися тільки за умови зміни тих частин стану, які використовуються в селекторі.

Функція createSelector
Процес оптимізації селекторів називається мемоізація - збереження результатів виконання функції для запобігання повторним обчисленням.

Для мемоізації селектора використовується функція createSelector, яка приймає масив селекторів, значення яких необхідні для 
наступних обчислень та функцію перетворювач, в якій виконуватимуться всі обчислення.

import { createSelector } from "@reduxjs/toolkit";

const selector = createSelector(
  // Масив вхідних селекторів
  [inputSelector1, inputSelector2, inputSelector3],
  // Функція перетворювач
  (result1, result2, result3) => {
    // Виконуємо обчислення та повертаємо результат
  }
);
У масиві селекторів можуть бути будь-які інші селектори, як атомарні так і складові, у тому числі мемоізовані.
Результати вхідних селекторів передаються як аргументи функції перетворення в тому самому порядку, в якому вони перераховані.
Повторні обчислення виконуються лише якщо зміниться значення якогось параметра, в іншому випадку повертається результат 
останнього виклика функції.

Використовуємо createSelector та напишемо мемоізований селектор підрахунку кількості завдань selectTaskCount. 
Він залежить лише від масиву завдань, тому використовуємо один вхідний селектор selectTasks.

src/redux/selectors.js

import { createSelector } from "@reduxjs/toolkit";

// Решта селекторів

export const selectTaskCount = createSelector([selectTasks], tasks => {
  console.log("Calculating task count. Now memoized!");

  return tasks.reduce(
    (count, task) => {
      if (task.completed) {
        count.completed += 1;
      } else {
        count.active += 1;
      }
      return count;
    },
    { active: 0, completed: 0 }
  );
});


Відкрийте вкладку Console в інструментах розробника, змінюйте значення фільтра та подивіться результат - повідомлення 
про обчислення кількості завдань немає. Тепер обчислення виконуються лише якщо зміниться масив завдань.

Те саме з селектором списку завдань в залежності від значення фільтра selectVisibleTasks. 
Він залежить від списку завдань та фільтра, тому використовуємо вхідні селектори selectTasks та selectStatusFilter.

src/redux/selectors.js

import { createSelector } from "@reduxjs/toolkit";

// Решта селекторів

export const selectVisibleTasks = createSelector(
  [selectTasks, selectStatusFilter],
  (tasks, statusFilter) => {
    console.log("Calculating visible tasks. Now memoized!");

    switch (statusFilter) {
      case statusFilters.active:
        return tasks.filter(task => !task.completed);
      case statusFilters.completed:
        return tasks.filter(task => task.completed);
      default:
        return tasks;
    }
  }
);
*/
/**
  |============================
  | Облікові записи
  |============================
*/
/* 
Абсолютна більшість програм дозволяють користувачеві створити обліковий запис, що дає можливість фронтенду та бекенду 
розрізняти користувачів. Завдяки цьому, зареєстрований користувач може працювати з даними, які доступні лише йому. 
Наприклад, у додатку планувальника завдань у кожного зареєстрованого користувача буде своя особиста колекція завдань.

Крім цього, програма може мати закриті маршрути, доступні тільки зареєстрованим користувачам. Якщо користувач не 
увійшов до свого облікового запису, при спробі відвідати закритий маршрут, він буде перенаправлений на сторінку логіна 
чи реєстрації.
*/
/**
  |============================
  | Права доступу
  |============================
*/
/* 
Процес перевірки валідності даних при логіні та подальші перевірки наявності прав доступу до даних виконуються на бекенді 
та описуються двома термінами.

Аутентифікація (authentication) - це процес перевірки облікових даних користувача (логін/пароль). Перевірка автентичності 
користувача шляхом порівняння введеного ним логіна/паролю з даними збереженими в базі даних.

Авторизація (authorization) - це перевірка прав користувача на доступ до певних ресурсів. Правом доступу може бути якесь 
унікальне значення, яке фронтенд передає з кожним HTTP запитом на бекенд.

Наприклад, після аутентифікації користувач отримує право запитувати та отримувати від ресурсу my-api.com/tasks деякі дані. 
При кожному зверненні користувача до ресурсу tasks система авторизації перевірить, чи має він право звертатися до цього ресурсу, 
внаслідок чого пропускає чи відсікає запит. Право доступу до ресурсу визначається за наявністю якогось унікального значення 
у запиті (токену).
*/

/**
  |============================
  | JSON Web Token
  |============================
*/
/* 
Один із механізмів авторизації це JWT (JSON Web Token). Токени надають собою засіб авторизації для кожного запиту від 
фронтенду до бекенду. Токени створюються на бекенді ґрунтуючись на секретному ключі, який зберігається на сервері, та 
якихось унікальних для користувача даних, наприклад пошта тощо. Токен у результаті зберігається на фронтенді і 
використовується за необхідності авторизації будь-якого запиту.

Кожен токен це унікальний зашифрований рядок, який містить три блоки: заголовок (header), набір полів (payload) та сигнатуру. 
При спробі зловмисником підмінити дані в header або payload, токен стане не валідним, оскільки сигнатура не відповідатиме 
початковим значенням. А можливість згенерувати нову сигнатуру у зловмисника відсутня, оскільки секретний ключ для 
зашифрування лежить на сервері.
*/

/**
  |============================
  | Портали
  |============================
*/
/* 
Портали надають спосіб рендеру дочірніх елементів в DOM-вузол, який знаходиться поза DOM-ієрархією батьківського компонента.

ReactDOM.createPortal(child, container);
Першим аргументом може бути піддерево Virtual DOM будь-якої складності.
Другий аргумент - це DOM-вузол, в який буде рендеритися перший аргумент.

Використання

const PopupWindow = () => {
  return ReactDOM.createPortal(
    <div>PopupWindow with portal</div>,
    document.querySelector("#popup-root")
  );
};

Типовий варіант використання порталів - коли батьківський компонент має overflow: hidden або z-index, при цьому необхідно, 
щоб дочірній компонент візуально "виходив" зі свого контейнера. Наприклад, модальні вікна, спливаючі підказки.

Незважаючи на те, що портал може бути будь-де в DOM-дереві, він поводиться як звичайний дочірній React-елемент. 
Такі речі, як пропси або контекст, працюють як і раніше, незалежно від того, чи є дочірній елемент порталом, оскільки 
портал все ще існує в дереві React-компонентів, незалежно від його положення в DOM-дереві.

Те саме стосується і спливання подій. Подія, створена всередині порталу, поширюватиметься до предків у React-дереві, 
навіть якщо вони не є предками в DOM-дереві.
*/
