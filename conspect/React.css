/**
  |============================
  | Веб-застосунки
  |============================
*/
/* 
У сучасній веб-розробці змінилися не тільки техніки, що дозволяють веб-сайтам виглядати краще, завантажуватися швидше і бути 
приємнішими у використанні. Насамперед змінилися фундаментальні речі - те, як ми проектуємо та створюємо веб-застосунки.

Візьмемо довільний веб-сайт, наприклад, для роботи з колекцією рецептів, розкладом тренувань тощо. Завжди є набір сторінок: 
домашня, профіль, сторінка колекції та сторінка одного елемента колекції.


--- Multiple-page Application ---

Кілька років тому ми використовували б підхід, який включає декілька окремих HTML-сторінок.
- Архітектура клієнт-сервер
- Вся логіка живе на сервері
- На кожен запит сервер надсилає готовий HTML-документ
- Перезавантаження сторінки при кожному запиті
- Погана інтерактивність
- Відмінне SEO


--- Single-page Application ---

Сучасний підхід - сайт, на якому користувач ніколи не переходить на інші HTML-сторінки. 
Інтерфейс, замість запиту HTML-документів з сервера, перемальовується на клієнті, на одній і тій самій сторінці, 
без перезавантаження.
- Архітектура клієнт-сервер
- При завантаженні сайту сервер завжди віддає стартову HTML-сторінку index.html
- Кожен наступний запит на сервер отримує лише дані у JSON-форматі
- Оновлення інтерфейсу відбувається динамічно на клієнті
- Завантаження першої сторінки може бути досить повільним (лікується)
- Логіка, не пов'язана із безпекою, живе на клієнті
- Слабке SEO (лікується)
- Складність коду та його підтримки масштабується з кількістю функціоналу застосунку
*/

/**
  |============================
  | Бібліотека React
  |============================
*/

/* 
React - це бібліотека для створення елементів інтерфейсу користувача. У React немає вбудованої маршрутизації, 
HTTP-модуля тощо. Проте є багата екосистема, яка дозволить вирішити будь-яке завдання.
При створенні застосунку з використанням React розробник не взаємодіє безпосередньо з DOM-деревом. 
Його завдання - описати інтерфейс за допомогою компонентів (шаблон) та керувати зміною даних (модель). 

React, при зміні даних моделі, сам оновить інтерфейс за шаблоном.

React - мультиплатформний, розмітку можна рендерити на сервері (Next.js), писати нативні (React Native) або 
десктопні (Electron) застосунки.

--- Browser DOM ---
Browser DOM - деревоподібне представлення HTML-документа, де кожен елемент документа представлений у вигляді DOM-вузла. 
Зберігається в браузері і безпосередньо пов'язаний з тим, що ми бачимо на сторінці.

З кожною зміною DOM браузер виконує кілька трудомістких операцій. Часті операції оновлення такого дерева негативно 
впливають на продуктивність та реакцію інтерфейсу. Тому він повільний, та оновлювати його необхідно ефективно.

--- Virtual DOM --- 
Virtual DOM - абстракція, легковагова копія реального DOM-дерева у вигляді JSON-документа.

- Існує тільки в пам'яті і не рендериться в браузері
- Не залежить від внутрішньої імплементації браузера
- Використовує найкращі практики оновлення реального DOM
- Збирає оновлення в групи для оптимізації рендеру (batching)

--- Алгоритм оновлення DOM ---
У React кожен елемент інтерфейсу - це компонент (кастомний або вбудований), який залежить від пропсів або стану, 
і представлений вузлами віртуального DOM-дерева. Взаємодія користувача з інтерфейсом змінює стан застосунку.

У разі зміни компонента створюється нове віртуальне DOM-дерево. Далі, використовуючи breadth-first алгоритм, 
відбувається порівняння (диференціювання, diffing) двох віртуальних дерев - до та після оновлення.

https://s3.eu-north-1.amazonaws.com/lms.goit.files/f367ae64-ce26-49b3-b818-8b8cb775972aimage.png

Обчислюється різниця між попередньою та новою версією віртуального DOM-дерева. Застосовується оптимальний варіант 
внесення змін до реального DOM. Це гарантує, що в реальному DOM-дереві провадиться мінімальна кількість оновлень, 
тим самим підвищуючи продуктивність інтерфейсу.
*/

/**
  |============================
  | Інструменти
  |============================
*/
/* 
Для створення React-застосунку необхідні Node.js, Webpack, Babel, React і DevTools. 
Можна написати свою Webpack-збірку або взяти будь-яку хорошу з GitHub.

--- Create React App ---

Для навчання та маленьких/середніх проектів рекомендується використовувати утиліту від авторів React.

- Абстрагує всю конфігурацію, дозволяючи зосередитись на написанні коду
- Включає необхідні інструменти: Webpack, Babel, ESLint тощо.
- Розширюється додатковими пакетами з екосистеми React
- Має функцію вилучення, яка видаляє абстракцію і відкриває конфігурацію

npx create-react-app ім'я_папки_проекту

ІНФОРМАЦІЯ
Щоб створити застосунок у поточній папці, замість імені проекту ставиться крапка. Наприклад npx create-react-app .. 
Це можна використовувати, коли був склонований репозиторій, і в його локальній версії ініціалізується застосунок.

npx — інструмент, призначений для того, щоб допомогти стандартизувати використання npm-пакетів. 
Постачається з npm версії 5.2.0 та вище. npm спрощує встановлення та керування залежностями, розміщеними в реєстрі, 
a npx спрощує використання CLI-утиліт та інших файлів, що виконуються, без необхідності їх встановлення в систему або проект.

Документація Create React App:
https://create-react-app.dev/

--- React DevTools ---
В інструментах розробника можна подивитися на дерево компонентів, їх стан та пропси. 
Профайлер корисний під час оптимізації застосунку.

Devtools в Chrome Web Store
https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en
Introducing the New React DevTools
https://reactjs.org/blog/2019/08/15/new-react-devtools.html
*/

/**
  |============================
  | JSX
  |============================
*/
/* 
const link = <a href="<https://reactjs.org/>">React website</a>;

Це не рядок і не HTML, цей XML-образний синтаксис називається JSX (JavaScript Syntax Extension) - розширення 
синтаксису JavaScript, за допомогою якого зручно описувати розмітку того, що ми хочемо побачити на екрані.
- Дозволяє використовувати XML-образний синтаксис прямо у JavaScript
- Спрощує код, робить його декларативним та читабельним
- Описує об'єкти - елементи Virtual DOM
- Це не HTML, Babel трансформує JSX у виклики функцій
- У JSX можна використовувати всі можливості JavaScript

--- REACT ЕЛЕМЕНТИ ---
JSX створює елементи - найменші будівельні блоки React. 
Елементи Virtual DOM це звичайні JavaScript об'єкти, тому створювати їх дуже швидко.

Використовуючи JSX, розмітка стає схожою на звичні HTML-шаблони.

src/index.js

const imageUrl = "https://images.pexels.com/photos/461198/pexels-photo-461198.jpeg?dpr=2&h=480&w=640";

const productPrice = 10.99;

const product = (
  <div>
    <img src={imageUrl} alt="Tacos With Lime" width="640" />
    <h2>Tacos With Lime</h2>
    <p>Price: {productPrice}$</p>
    <button type="button">Add to cart</button>
  </div>
);

- Усередині JSX можна використовувати будь-який валідний вираз, обертаючи його в фігурні дужки.
- Значення атрибутів вказуються в подвійних лапках, якщо це звичайний рядок, та у фігурних дужках, якщо значення 
обчислюється, або тип відрізняється від рядка.
- Всі атрибути React-елементів іменуються в camelCase нотації.
- JSX-теги можуть бути батьками інших JSX-тегів. Якщо тег порожній або самозакривається, його обов'язково 
необхідно закрити використовуючи />.

--- Рендер елементів у DOM-дерево ---
Для того, щоб відрендерувати елемент у DOM-дерево, у пакеті react-dom є методи createRoot(container) та render(element), 
які працюють разом.

- createRoot(container) приймає посилання на існуючий DOM-елемент, наприклад div#root з index.html і створює корінь, 
в який буде рендеруватись вся програма.
- render(element) чекає на посилання на React-елемент або компонент (що рендерити).

src/index.js

import ReactDOM from "react-dom/client";

const imageUrl = "https://images.pexels.com/photos/461198/pexels-photo-461198.jpeg?dpr=2&h=480&w=640";

const productPrice = 10.99;

const product = (
  <div>
    <img src={imageUrl} alt="Tacos With Lime" width="640" />
    <h2>Tacos With Lime</h2>
    <p>Price: {productPrice}$</p>
    <button type="button">Add to cart</button>
  </div>
);

ReactDOM.createRoot(document.getElementById("root")).render(product);

--- ОДИН render() НА ПРОГРАМУ ---
React використовує модель відносин предок - нащадок, тому достатньо використовувати лише один виклик render() в програмі. 
Рендер найвищого елемента в ієрархії потягне за собою рендер всього піддерева.

--- Правило спільного батька ---
Права частина висловлювання присвоювання має повертати одне значення. Розберемо наступний код із невалідною JSX-розміткою.

const post = (
  <h2>Post Header</h2>
  <p>Post text</p>
);

Вираз це одне значення, результат деяких обчислень, звідси випливає правило спільного батька.

const post = (
  <div>
    <h2>Post Header</h2>
    <p>Post text</p>
  </div>
);

Якщо в розмітці зайвий тег-обгортка не потрібний, використовуються фрагменти, схожі на DocumentFragment. 
Цей вбудований компонент при рендері розчиняється, підставляючи свій вміст.

import { Fragment } from "react";

const post = (
  <Fragment>
    <h2>Post Header</h2>
    <p>Post text</p>
  </Fragment>
);

Синтаксис фрагментів можна скоротити та не додавати імпорт Fragment. Babel зробить всі необхідні трансформації, 
замінивши порожні JSX-теги на React.Fragment.

const post = (
  <>
    <h2>Post Header</h2>
    <p>Post text</p>
  </>
);


--- Додаткові матеріали ---
Знайомство з JSX
https://react.dev/learn/writing-markup-with-jsx
*/

/**
  |============================
  | Компоненти
  |============================
*/
/* 
Компоненти - основні будівельні блоки React-застосунків, за допомогою яких інтерфейс розділяється на незалежні частини.

Розробник створює невеликі компоненти, які можна поєднувати, щоб сформувати більші, або використовувати їх як самостійні 
елементи інтерфейсу. Найголовніше в цій концепції те, що і великі, і маленькі компоненти можна використовувати повторно 
і в поточному, і в новому проекті.

React-застосунок можна уявити як дерево компонентів. 
На верхньому рівні стоїть кореневий компонент, у якому вкладена довільна кількість інших компонентів. 
Кожен компонент повинен повернути JSX-розмітку, тим самим вказуючи, який HTML ми хочемо відрендерити в DOM.

--- Компоненти-функції ---
У найпростішій формі компонент - це JavaScript-функція з дуже простим контрактом: функція отримує об'єкт 
властивостей, який називається props і повертає дерево React-елементів.

ІНФОРМАЦІЯ
Ім'я компонента обов'язково повинно починатися з великої літери. 
Назви компонентів з маленької літери зарезервовані для HTML-елементів. Якщо ви спробуєте назвати компонент card, 
а не Card, під час рендеру React проігнорує його та відрендерить тег <card></card>.

const MyFunctionalComponent = props => <div>Functional Component</div>;

Компоненти-функції складають більшу частину React-застосунку.
- Менше boilerplate-коду
- Легше сприймати
- Легше тестувати
- Немає контексту (this)

Зробимо картку продукту компонентом-функцією.

const Product = props => (
  <div>
    <img
      src="<https://images.pexels.com/photos/461198/pexels-photo-461198.jpeg?dpr=2&h=480&w=640>"
      alt="Tacos With Lime"
      width="640"
    />
    <h2>Tacos With Lime</h2>
    <p>Price: 10.99$</p>
    <button type="button">Add to cart</button>
  </div>
);

// У розмітці компонент записується як JSX-тег
ReactDOM.createRoot(document.getElementById("root")).render(<Product />);

--- Властивості компонента (props) ---
Властивості (пропси) - це одна із основних концепцій React. Компоненти приймають довільні властивості і повертають 
React-елементи, що описують, що потрібно відрендерити в DOM.
- Пропси використовуються для передачі даних від батька до дитини.
- Пропси передаються лише вниз по дереву від батьківського компонента.
- При зміні пропсів React ререндерить компонент і, можливо, оновлює DOM.
- Пропси доступні лише для читання, у дитині їх не можна змінити.

Пропсом може бути текст кнопки, зображення, url, будь-які дані для компонента. 
Пропси можуть бути рядками або результатом JS-виразу. Якщо передане лише ім'я пропса - це буль, за замовчуванням true.

const App = () => (
  <>
    <h1>Best selling products</h1>
    <Product name="Tacos With Lime" />
  </>
);

Компонент <Product> оголошує параметр props, це завжди буде об'єкт, що містить усі передані пропси.
const Product = props => (
  <div>
    <h2>{props.name}</h2>
  </div>
);

Додамо компоненту <Products> кілька інших властивостей.
const Product = props => (
  <div>
    <img src={props.imgUrl} alt={props.name} width="640" />
    <h2>{props.name}</h2>
    <p>Price: {props.price}$</p>
    <button type="button">Add to cart</button>
  </div>
);

Відразу будемо використовувати простий патерн під час роботи з props. 
Оскільки props - це об'єкт, ми можемо деструктуризувати його у підписі функції. Це зробить код чистішим і читабельнішим.
const Product = ({ imgUrl, name, price }) => (
  <div>
    <img src={imgUrl} alt={name} width="640" />
    <h2>{name}</h2>
    <p>Price: {price}$</p>
    <button type="button">Add to cart</button>
  </div>
);

const App = () => (
  <div>
    <h1>Best selling products</h1>
    <Product
      imgUrl="<https://images.pexels.com/photos/461198/pexels-photo-461198.jpeg?dpr=2&h=480&w=640>"
      name="Tacos With Lime"
      price={10.99}
    />
    <Product
      imgUrl="<https://images.pexels.com/photos/70497/pexels-photo-70497.jpeg?dpr=2&h=480&w=640>"
      name="Fries and Burger"
      price={14.29}
    />
  </div>
);

В підсумку ми створили компонент, що налаштовується, і який можна використовувати для відображення товару. 
Ми передаємо йому дані як пропси, а у відповідь отримуємо дерево React-елементів з підставленими значеннями.
Компоненти:
https://react.dev/learn/your-first-component#components-ui-building-blocks
Пропси:
https://react.dev/learn/passing-props-to-a-component

--- Значення пропсів за замовчуванням ---
Що якщо компонент очікує якесь значення, а його не передали? - під час звернення до властивості об'єкта props 
отримаємо undefined.
Для того щоб вказати значення властивостей за замовчуванням, використовується синтаксис значень за замовчуванням 
під час деструктуризації пропсів.

const Product = ({
  imgUrl = "<https://dummyimage.com/640x480/2a2a2a/ffffff&text=Product+image+placeholder>",
  name,
  price,
}) => (
  <div>
    <img src={imgUrl} alt={name} width="640" />
    <h2>{name}</h2>
    <p>Price: {price}$</p>
    <button type="button">Add to cart</button>
  </div>
);

* Визначення defaultProps гарантує, що props.imgUrl матиме значення, навіть якщо воно не було вказане  під час виклику 
компонента у батька.

ReactDOM.createRoot(document.getElementById("root")).render(
  <Product name="Tacos With Lime" price={10.99} />
);

--- Властивість props.children --- 
Концепція дочірніх елементів дозволяє дуже просто робити композицію компонентів. У вигляді дітей можна передавати 
компоненти як вбудовані, так і кастомні. Це дуже зручно під час роботи зі складними складеними компонентами.

Властивість children автоматично доступна в кожному компоненті, її вмістом є те, що знаходиться між відкриваючим 
та закриваючим JSX-тегом.
У функціональних компонентах звертаємось як props.children.
Значенням props.children може бути практично все, що завгодно.

Наприклад, у нас є компонент профілю <Profile> та оформлювальний компонент <Panel>, в який ми можемо поміщати 
довільний контент.

const Profile = ({ name, email }) => (
  <div>
    <p>Name: {name}</p>
    <p>Email: {email}</p>
  </div>
);

const Panel = ({ title, children }) => (
  <section>
    <h2>{title}</h2>
    {children}
  </section>
);

const App = () => (
  <div>
    <Panel title="User profile">
      <Profile name="Mango" email="mango@mail.com" />
    </Panel>
  </div>
);

В іншому разі нам би довелося прокинути пропи для <Profile> через <Panel>, що тісніше пов'язує компоненти та 
ускладнює повторне використання.

--- Властивість propTypes ---
https://www.npmjs.com/package/prop-types
Перевірка типів одержуваних пропсів дозволить відловити багато помилок. Це економить час на дебаг, допомагає 
у разі неуважності та рятує з ростом застосунку. У майбутньому потрібно буде приділити час і познайомитися з 
Flow або TypeScript, а для старту вистачить невеликої бібліотеки.

Пакет prop-types надає ряд валідаторів для перевірки коректності отриманих типів даних під час виконання коду, 
повідомляючи про невідповідності в консолі. Все що необхідно зробити - це описати типи пропсів, що отримуються 
компонентом у спеціальній статичній властивості propTypes. Перевірка пропсів за допомогою prop-types відбувається 
лише під час розробки, у продакшені в ній немає потреби.

npm install --save-dev prop-types

Використаємо prop-types та опишемо пропси компонента Product.

import PropTypes from "prop-types";

const Product = ({
  imgUrl = "<https://dummyimage.com/640x480/2a2a2a/ffffff&text=Product+image+placeholder>",
  name,
  price,
}) => (
  <div>
    <img src={imgUrl} alt={name} width="640" />
    <h2>{name}</h2>
    <p>Price: {price}$</p>
    <button type="button">Add to cart</button>
  </div>
);

Product.propTypes = {
  imgUrl: PropTypes.string,
  name: PropTypes.string.isRequired,
  price: PropTypes.number.isRequired,
};

Спочатку застосовуються значення за замовчуванням, задані в defaultProps. 
Після цього запускається перевірка типів за допомогою propTypes. 
Отже, перевірка типів поширюється і на значення за замовчуванням.
 */

/**
   |============================
   | Рендер за умовою
   |============================
 */
/* 
Для рендеру розмітки за умовою використовуються оператори розгалужень та умов. 
Умови можна перевіряти перед поверненням розмітки або прямо в JSX.

ІНФОРМАЦІЯ
Якщо за умовою нічого не повинно бути відрендерено, можна повернути null, undefined або false, вони не рендеряться.

--- if за допомогою логічного оператора && ---
Читається як: якщо умова приводиться до true, то рендерим розмітку.

const Mailbox = ({ unreadMessages }) => {
  return (
    <div>
      <h1>Hello!</h1>
      {unreadMessages.length > 0 && (
        <p>You have {unreadMessages.length} unread messages.</p>
      )}
    </div>
  );
};

--- if...else за допомогою тернарного оператора ---
Читається як: якщо умова приводиться до true, рендерим розмітку після ?, інакше - рендерим розмітку після :.

const Mailbox = ({ username, unreadMessages }) => {
  return (
    <div>
      <h1>Hello {username}</h1>
      {unreadMessages.length > 0 ? (
        <p>You have {unreadMessages.length} unread messages.</p>
      ) : (
        <p>No unread messages.</p>
      )}
    </div>
  );
};

Останній приклад можна записати по-іншому, результат буде однаковий.

const Mailbox = ({ name, unreadMessages }) => {
  return (
    <div>
      <h1>Hello {name}</h1>
      <p>
        {unreadMessages.length > 0
          ? `You have ${unreadMessages.length} unread messages.`
          : "No unread messages."}
      </p>
    </div>
  );
};

Нехай у компоненті продукту ще є його доступна кількість.

const Product = ({ imgUrl, name, price, quantity }) => (
  <div>
    <img src={imgUrl} alt={name} width="640" />
    <h2>{name}</h2>
    <p>Price: {price}$</p>
    <h1>Quantity: {quantity < 20 ? "Few left" : "In stock"}</h1>
    <button type="button">Add to cart</button>
  </div>
);

Додаткові матеріали
Умовний рендеринг
https://react.dev/learn/conditional-rendering
All the Conditional Renderings in React
https://www.robinwieruch.de/conditional-rendering-react/
 */

/**
   |============================
   | Колекції
   |============================
 */
/* 
Для того щоб відрендерити колекцію однотипних елементів, використовується метод Array.prototype.map(), 
callback-функція якого, для кожного елемента колекції повертає JSX-розмітку. Отже, отримуємо масив React-елементів, 
який можна рендерити.

const favouriteBooks = [
  { id: "id-1", name: "JS for beginners" },
  { id: "id-2", name: "React basics" },
  { id: "id-3", name: "React Router overview" },
  { id: "id-4", name: "Redux in depth" },
];

const BookList = ({ books }) => {
  return (
    <ul>
      {books.map(book => (
        <li>{book.name}</li>
      ))}
    </ul>
  );
};

const App = () => {
  return (
    <div>
      <BookList books={favouriteBooks} />
    </div>
  );
};

Ключі
Під час виконання коду з прикладу вище спливе попередження про те, що для елементів списку потрібен ключ. 
React не може відрізнити елементи в колекції, таким чином, перемальовуючи всю колекцію повністю у разі будь-яких змін.

Ключ (key) — це спеціальний рядковий проп, який потрібно задати під час створення елементів колекції.
Елементи всередині колекції повинні бути забезпечені ключами, щоб мати стабільну ідентичність. 
React використовує ключі, щоб визначити, які з елементів в колекції необхідно створити і відрендерити знову, 
а не використовувати елементи з попереднього рендеру. Таким чином ми уникаємо перестворення всіх елементів 
колекції щоразу, коли щось змінюється.

Ключі повинні бути:
Унікальні - ключ елемента повинен бути унікальним лише серед його сусідів. Немає сенсу у глобально унікальних ключах.
Стабільні - ключ елемента не повинен змінюватися з часом, зі зміною порядку елементів або після оновлення сторінки.

ІНФОРМАЦІЯ
Індекси масиву унікальні, проте вони не стабільні - при перетасовуванні колекції ключі змінюються. 
Дата і час - унікальні, але не стабільні, оскільки постійно збільшуються. Таким чином, під час кожного рендеру 
створюються нові ключі. Використання випадкового числа рівносильно тому, що ключі взагалі не використовуються, 
оскільки випадкові числа не є унікальними або стабільними.

Найкращий спосіб задати ключ - використовувати статичний рядок, який однозначно ідентифікує елемент списку серед інших. 
Найчастіше як ключі використовуються ідентифікатори об'єктів, створених базою даних, - постійне, незмінне значення. 
Але також підійде будь-яке унікальне значення якоїсь властивості об'єкта.

const favouriteBooks = [
  { id: "id-1", name: "JS for beginners" },
  { id: "id-2", name: "React basics" },
  { id: "id-3", name: "React Router overview" },
  { id: "id-4", name: "Redux in depth" },
];

const BookList = ({ books }) => (
  <ul>
    {books.map(book => (
      <li key={book.id}>{book.name}</li>
    ))}
  </ul>
);

Якщо об'єкти масиву не мають унікальних значень властивостей і колекція не редагується, тобто у користувача немає 
можливості видалити або ще якось змінити порядок елементів, крім додавання нових, можна використовувати індекси масиву.

const favouriteBooks = [
  { name: "JS for beginners" },
  { name: "React basics" },
  { name: "React Router overview" },
  { name: "Redux in depth" },
];

const BookList = ({ books }) => (
  <ul>
    {books.map((book, index) => (
      <li key={index}>{book.name}</li>
    ))}
  </ul>
);

ІНДЕКСИ ЯК КЛЮЧІ
Використання індексів для ключів - це крайній випадок. В переважній більшості даних будуть унікальні ідентифікатори 
або будь-які інші властивості.

Додаткові матеріали

Списки і ключі
https://react.dev/learn/rendering-lists
*/

/**
  |============================
  | Вбудовані стилі
  |============================
*/
/* 
Існує кілька способів стилізації компонентів, найпростіший, але в той же час найбільш обмежений - це вбудовані стилі. 
Для цього використовується атрибут style, який у React приймає не рядок, а об'єкт стилів.

src/components/App.js

const App = () => {
  return (
    <p
      style={{
        margin: 8,
        padding: "12px 16px",
        borderRadius: 4,
        backgroundColor: "gray",
        color: "white",
      }}
    >
      Please update your email!
    </p>
  );
};

З прикладу можна виділити кілька обов'язкових правил вбудованих стилів:
Імена властивостей, що складаються з двох і більше слів, наприклад background-color, обов'язково повинні бути записані 
в camelCase нотації (backgroundColor), як при зверненні до властивостей об'єкта style у DOM-елемента.
До числових значень більшості властивостей буде автоматично додано суфікс px. 
Якщо необхідно використовувати одиниці відмінні від px, або значення складається з кількох частин, воно вказується як рядок.

Винесемо об'єкт стилів у змінну, щоб підвищити читабельність JSX розмітки.

src/components/App.js

const alertStyles = {
  margin: 8,
  padding: "12px 16px",
  borderRadius: 4,
  backgroundColor: "gray",
  color: "white",
};

const App = () => {
  return (
    <>
      <p style={alertStyles}>Please update your email!</p>
      <p style={alertStyles}>There was an error during transaction!</p>
      <p style={alertStyles}>Payment received, thank you for your purchase!</p>
    </>
  );
};

Створимо компонент Alert який буде рендерувати абзац тексту та приховає у собі майбутню логіку вибору кольору фону.
src/components/Alert.js

const alertStyles = {
  margin: 8,
  padding: "12px 16px",
  borderRadius: 4,
  backgroundColor: "gray",
  color: "white",
};

export const Alert = ({ children }) => {
  return <p style={alertStyles}>{children}</p>;
};

Використовуємо компонент Alert для рендеру декількох повідомлень.
src/components/App.js

import { Alert } from "./Alert";

const App = () => {
  return (
    <>
      <Alert>Please update your email!</Alert>
      <Alert>There was an error during transaction!</Alert>
      <Alert>Payment received, thank you for your purchase!</Alert>
    </>
  );
};

Зробимо так, щоб залежно від типу оповіщення, у компоненті Alert змінювався колір фону абзацу. 
Для цього додамо йому обов'язковий пропс variant з кількома можливими значеннями.
src/components/App.js

import { Alert } from "./Alert";

const App = () => {
  return (
    <>
      <Alert variant="info">
        Would you like to browse our recommended products?
      </Alert>
      <Alert variant="error">
        There was an error during your last transaction
      </Alert>
      <Alert variant="success">
        Payment received, thank you for your purchase
      </Alert>
      <Alert variant="warning">
        Please update your profile contact information
      </Alert>
    </>
  );
};

Логіку вибору кольору винесемо у функцію getBgColor(variant), яка буде повертати рядок із назвою кольору 
залежно від значення параметра variant.

src/components/Alert.js

const alertStyles = {
  margin: 8,
  padding: "12px 16px",
  borderRadius: 4,
  color: "white",
};

const getBgColor = variant => {
  switch (variant) {
    case "info":
      return "blue";
    case "success":
      return "green";
    case "error":
      return "red";
    case "warning":
      return "orange";
    default:
      throw new Error(`Unsupported variant prop value - ${variant}`);
  }
};


export const Alert = ({ variant, children }) => {
  return (
    <p style={{ ...alertStyles, backgroundColor: getBgColor(variant) }}>
      {children}
    </p>
  );
};

ДИНАМІЧНІ СТИЛІ
Відбувається створення фінального значення атрибуту style - базові стилі з alertStyles та динамічне значення 
backgroundColor залежно від пропсу variant. Такий підхід застосовується у разі коли значення однієї і більше 
властивостей залежить від пропсів. Наприклад, якщо посилання на зображення для background-image передається як пропс.

Вбудовані стилі можуть видаватися зручними через простоту використання, але вони мають ряд істотних недоліків.
- Дуже слабка масштабованість та повторне використання стилів
- Обмежені можливості (псевдокласи, псевдоелементи, адаптивні властивості)
- Погана продуктивність при відмальовуванні досить великої кількості елементів
- Відсутність зручних інструментів розробника
- Немає підтримки в популярних інструментах, наприклад autoprefixer

ВИСНОВОК
На практиці вбудовані стилі використовуються тільки для динамічно обчислюваних значень властивостей, у парі із 
зовнішніми таблицями стилів. В якості основного способу стилізації компонентів вбудовані стилі не використовуються в 
проектах та тому не рекомендуються.
*/

/**
  |============================
  | Ванільний CSS
  |============================
*/
/* 
Оформлення компонента можна винести до таблиці стилів. У цьому випадку стилі кожного компонента оголошуються 
в окремому CSS-файлі з розширенням .css. Ім'я файлу складається з імені компонента та розширення. 
Наприклад, для компонента Alert, файл стилів буде називатися Alert.css.

src/components/Alert.css
.alert {
  margin: 8px;
  padding: 12px 16px;
  border-radius: 4px;
  background-color: gray;
  color: white;
}

ЦЕ ЗВИЧАЙНИЙ CSS
Всередині файлу стилів можна написати будь-який валідний CSS код. 
Хорошою практикою буде писати CSS тільки для HTML-розмітки компонента до якого належить цей файл стилів.

Стилі компонента імпортуються у файл оголошення, після чого CSS-класи описані у таблиці стилів доступні для використання. 

У React HTML-атрибуту class відповідає JSX-атрибут className, куди можна передати рядок з перерахуванням 
усіх класів елемента.

src/components/Alert.js

import "./Alert.css";

const Alert = ({ children }) => {
  return <p className="alert">{children}</p>;
};

АВТОМАТИЗАЦІЯ
На стадії збирання проекту Create React App мінімізує CSS та автоматично додає вендорні префікси використовуючи 
Autoprefixer. Сучасний синтаксис та можливості CSS покриваються поліфілами для можливості підтримки старих браузерів. 
Тому розробнику не потрібно турбуватися про це.

Композиція класів
Додамо CSS класи для кожного типу оповіщення, щоб контролювати колір фону абзацу в залежності від значення пропсу variant. 
Для зручності назвемо класи аналогічно варіантам значення пропсу.

src/components/Alert.css

.alert {
  margin: 8px;
  padding: 12px 16px;
  border-radius: 4px;
  color: white;
}

.alert.info {
  background-color: blue;
}

.alert.success {
  background-color: green;
}

.alert.error {
  background-color: red;
}

.alert.warning {
  background-color: orange;
}

Додамо компоненту Alert два необов'язкові пропси outlined та elevated. Їх значеннями можуть бути тільки true, 
false або undefined. Якщо значення цих пропсів true, будемо додавати елементу <p> класи is-outlined та is-elevated.

src/components/Alert.css
// Весь попередній CSS код

.alert.is-outlined {
  outline: 1px solid black;
}

.alert.is-elevated {
  box-shadow: rgb(0 0 0 / 20%) 0px 3px 3px -2px, rgb(0 0 0 / 14%) 0px 3px 4px 0px,
    rgb(0 0 0 / 12%) 0px 1px 8px 0px;
}

Процес обчислення фінального значення атрибуту className залежить від розробника та поточного завдання. 
Наприклад, використовуємо масив рядків та блок if. Класи alert і якийсь із варіантів буде завжди, а класи 
для пропсів elevated та outlined додаємо тільки за потребою.

src/components/Alert.js

import "./Alert.css";
const Alert = ({ variant, outlined, elevated, children }) => {
  const classNames = ["alert", variant];
  if (outlined) classNames.push("is-outlined");
  if (elevated) classNames.push("is-elevated");
  return <p className={classNames.join(" ")}>{children}</p>;
};

СТАНДАРТУ НЕМАЄ
Для обчислення фінального значення атрибуту className можна було використати блок if...else, інструкцію switch, 
тернарний оператор або будь-який інший синтаксис JavaScript, який дасть нам той же результат. Головне, щоб рядок 
з класами був складений правильно і не мав зайвих чи невалідних значень.

--- Бібліотека clsx ---
Для вирішення більшості завдань, пов'язаних з безліччю класів, що задаються згідно з певними умовами, використовують 
бібліотеку clsx. Звичайно, JavaScript надає багатий синтаксис, але здебільшого пишуться непродуктивні рішення або код, 
що погано читається. Бібліотека стандартизує цей процес і робить його більш зручним за рахунок продуманого синтаксису.

npm install clsx

Функції clsx можна передати список виразів як набір аргументів. Вирази що приводяться до true, результат яких це 
рядок або число, буде додано у фінальний рядок класів.

import clsx from "clsx";
const className = clsx(
  "first",
  10,
  undefined && "second",
  true && "third",
  false ? "fourth" : "fifth"
);

console.log(className); // "first 10 third fifth"

Ось як виглядатиме код компонента Alert використовуючи бібліотеку clsx. Навіть у такому, відносно простому випадку, 
код виходить простіше і читабельніше.

src/components/Alert.js

import clsx from "clsx";
import "./Alert.css";

const Alert = ({ variant, outlined, elevated, children }) => {
  return (
    <p
      className={clsx(
        "alert",
        variant,
        outlined && "is-outlined",
        elevated && "is-elevated"
      )}
    >
      {children}
    </p>
  );
};

Можна комбінувати варіативну та об'єктну форму функції clsx. Спочатку передаються класи, які будуть завжди, після чого 
в об'єкті налаштувань перераховуємо динамічні значення класів залежно від якихось обчислень.

src/components/Alert.js

import clsx from "clsx";
import "./Alert.css";

const Alert = ({ variant, outlined, elevated, children }) => {
  return (
    <p
      className={clsx("alert", variant, {
        "is-outlined": outlined,
        "is-elevated": elevated,
      })}
    >
      {children}
    </p>
  );
};

--- Глобальний простір імен ---

Імпорт стилів компонента саме у файл його оголошення це просто гарна практика. Наприклад, якщо зробити імпорт 
стилів Alert.css у компоненті App, то нічого не зламається. В результаті імпорту весь оголошений CSS код файлу 
просто додається в одну загальну таблицю стилів, разом з усім іншим CSS кодом проекту з інших компонентів.

У коді прикладу буде проблема конфлікту CSS правил із селектором класу .text. Залежно від порядку імпорту 
цих двох CSS файлів у додатку фінальні стилі класу text можуть виглядати по-різному.

FirstComponent.css
.text {
  color: red;
  font-size: 24px;
}

SecondComponent.css
.text {
  color: blue;
}

УНІКАЛЬНІСТЬ ІМЕН
Імена селекторів класу повинні бути унікальними у всьому додатку, щоб не було конфліктів CSS правил з однаковими 
селекторами у різних компонентах.

--- Препроцесори ---
Використовувати препроцесори можна, але можливість композиції компонентів робить їх менш корисними, оскільки 
замінює такі концепції як домішки, функції, вкладеність та інші. Не рекомендується використовувати одні й ті самі 
CSS-класи в різних компонентах, для цього є композиція компонентів.

Наприклад, замість використання базового CSS-класу .button у компонентах <LoginButton> та <FollowButton>, 
краще створити компонент <Button> зі своїми власними стилями, які можуть відображатись у кількох варіантах. 
Тоді компоненти <LoginButton> та <FollowButton> можуть використовувати компонент <Button>, а не просто CSS-клас.

// Button.js
const Button = ({ variant, children }) => {
// Базові стилі кнопки з кількома варіантами відображення
  return <button className={clsx("button", variant)}>{children}</button>;
};

// LoginButton.js
const LoginButton = () => {
// Унікальна логіка кнопки логіна
  return <Button variant="primary">Login</Button>;
};

// FollowButton.js
const FollowButton = () => {
// Унікальна логіка кнопки підписки
  return <Button variant="secondary">Follow</Button>;
};

Правила іменування файлів такі ж, як і для ванільного CSS, відрізняється тільки розширення, наприклад .scss для SASS. 
В іншому у препроцесорів ті ж можливості, концепції та недоліки, що і у ванільного CSS. Для того щоб додати можливість 
використання SASS, встановіть його компілятор у проект.

npm install sass

Висновок
Використання ванільного CSS теж не найкращий підхід і має ряд недоліків, особливо у великих проектах.
- Слабка масштабованість
- Обмежене повторне використання стилів
- Для динамічних значень необхідно використовувати вбудовані стилі
- Проблема глобального простору імен
- Необхідність використовувати якусь конвенцію іменування селекторів класу
- Відсутність автоматичного видалення коду, що не використовується.
*/

/**
  |============================
  | CSS-модулі
  |============================
*/
/* 
CSS-модулі - це не офіційна специфікація, вони не імплементовані в браузери. 
Це процес, що запускається на стадії складання проекту (наприклад, за допомогою Webpack), в результаті виконання якого 
імена класів замінюються на унікальні. Це дозволяє використовувати одне і те ж ім'я класу в різних CSS-файлах, 
не турбуючись про конфлікти імен. Цей підхід був розроблений, щоб вирішити проблему глобальної області видимості в CSS.

Create React App за замовчуванням підтримує CSS-модулі, все, що необхідно зробити це створювати файли стилів з розширенням 
.module.css, наприклад Alert.module.css. Всередині модуля CSS можна використовувати будь-який валідний CSS.

src/components/Alert.module.css

.alert {
  margin: 8px;
  padding: 12px 16px;
  border-radius: 4px;
  background-color: gray;
  color: white;
}

ТРОХИ ГЛИБШЕ
Хоча CSS-модуль виглядає як звичайний CSS, насправді він компілюється у формат, що називається ICSS (Interoperable CSS), 
який призначений для розробників інструментів на зразок Webpack, а не для кінцевих користувачів.

Синтаксис імпорту CSS-модуля нагадує імпорт файлу JavaScript модуля. 
У CSS-модулі є експорт за замовчуванням - об'єкт відповідності оригінального та згенерованих імен класів. 
У фінальному файлі стилів буде унікальне ім'я класу у форматі [filename]_[classname]__[hash].

src/components/Alert.js

// Синтаксис імпорту CSS-модуля
import css from "./Alert.module.css";

// Отримуємо об'єкт відповідності імен класів
console.log(css); // { alert: "Alert_alert_ax7yz" }

const Alert = ({ children }) => {
  // Звертаємось до властивості об'єкта на ім'я класу з файлу модуля
  return <p className={css.alert}>{children}</p>;
};



ГЛОБАЛЬНІ СТИЛІ
Селектори тегів за замовчуванням будуть у глобальній області видимості, CSS-модулі генерують лише унікальні 
імена селекторів класу.


Властивість composes
Композиція селекторів це одна з ключових можливостей CSS-модулів, яка дозволяє створювати клас, наслідуючи стилі 
іншого класу, але не дублюючи їх. Використовуємо композицію класів та виконаємо рефакторинг стилів компонента Alert. 
Наслідуємо стилі базового класу .alert у всіх класах варіантів. Властивість composes має передувати іншим правилам, 
щоб можна було перевизначити стилі, якщо це необхідно.

src/components/Alert.module.css

.alert {
  margin: 8px;
  padding: 12px 16px;
  border-radius: 4px;
  background-color: gray;
  color: white;
}

.info {
  composes: alert;
  background-color: blue;
}

.success {
  composes: alert;
  background-color: green;
}

.error {
  composes: alert;
  background-color: red;
}

.warning {
  composes: alert;
  background-color: orange;
}

При композиції у простих випадках можна обійтися без бібліотеки clsx. 
Не задаємо базовий клас alert, тому що від нього виконано композицію класів варіантів. 
В результаті на елементі <p> будуть два класи, базовий alert і клас варіанта, у якому перевизначається 
значення кольору фону.

src/components/Alert.js

import css from "./Alert.module.css";

const Alert = ({ variant, children }) => {
  return <p className={css[variant]}>{children}</p>;
};

ДОСТУП ДО ВЛАСТИВОСТЕЙ
До властивостей об'єкта зазвичай звертаються як css.alert, але можна використовувати квадратні дужки, 
наприклад css["alert"]. Це корисно у випадку коли ім'я властивості зберігається у змінній, як у нас у пропсі variant.


Бібліотека clsx
Додамо CSS класи для вже знайомих нам пропсів outlined та elevated. 
Імена класи, що складаються з декількох слів записують у верблюжій нотації. В протилежному випадку, 
оскільки вони стають властивостями об'єкта, звертатися до них доведеться через квадратні дужки, 
наприклад css["is-outlined"], що менш зручно.

src/components/Alert.module.css

Весь попередній CSS код

.alert.isOutlined {
  outline: 1px solid black;
}

.alert.isElevated {
  box-shadow: rgb(0 0 0 / 20%) 0px 3px 3px -2px, rgb(0 0 0 / 14%) 0px 3px 4px 0px,
    rgb(0 0 0 / 12%) 0px 1px 8px 0px;
}


Тепер ми знову використовуємо бібліотеку clsx для складання фінального значення властивості className.

src/components/Alert.js

import clsx from "clsx";
import css from "./Alert.module.css";

const Alert = ({ variant, outlined, elevated, children }) => {
  return (
    <p
      className={clsx(css[variant], {
        [css.isOutlined]: outlined,
        [css.isElevated]: elevated,
      })}
    >
      {children}
    </p>
  );
};
*/

/**
  |============================
  | Нормалізація стилів
  |============================
*/
/* 
Стилі елементів можуть відрізнятись між браузерами. Для того, щоб привести їх до стандартного вигляду, 
необхідно додати набір правил, що виправляє відмінності у стилях елементів між браузерами, наскільки це можливо.

У Create React App вбудована можливість використовувати PostCSS Normalize - суміш кількох популярних таблиць 
стилів (normalize.css та sanitize.css) з найкращими практиками нормалізації. Все, що необхідно зробити - 
це додати директиву @import-normalize; у будь-якому місці файлу стилів або CSS-модуля. 
Повторюючі імпорти будуть автоматично видалені, тому достатньо додати директиву до одного файлу стилів, наприклад index.css.

src/index.css

@import-normalize;

Решта стилів файлів

НАЛАШТУВАННЯ VSCODE
Якщо у VSCode ви бачите попередження «Unknown at rule @import-normalize css(unknownAtRules)», змініть у редакторі 
значення налаштування css.lint.unknownAtRules на ignore.

Залишилось імпортувати файл стилів index.css з підключеною нормалізацією в JavaScript модуль, наприклад в кореневий 
файл програми index.js або у файл компонента App.js.

src/index.js

import "./index.css";

Крім стандартизації зовнішнього вигляду елементів може бути корисно скинути або додати деякі глобальні стилі елементів. 
Наприклад, відступи списків та заголовків, стилі зображень, стилі елемента <body> і тому подібне. Буде логічно зробити 
це в тому ж файлі, в якому додавалася нормалізація.

src/index.css

@import-normalize;

body {
 font-family: sans-serif;
 line-height: 1.5;
}

h1,
h2,
h3,
h4,
h5,
h6,
p {
 margin: 0;
}

ul,
ol {
 margin: 0;
 padding: 0;
}

img {
 display: block;
 max-width: 100%;
 height: auto;
}
*/
