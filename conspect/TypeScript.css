/* Основні переваги використання TypeScript будуть корисні незалежно від напрямку, в якому ти плануєш розвиватись.
Ти зможеш писати безпечний код, зменшувати кількість помилок, які виникають на продакшені, та забезпечувати швидший процес розробки.

Курс познайомить тебе з основними концепціями та можливостями TypeScript:

- Базові типи, типи для змінних, аргументів, методів та функцій, створення власних типів та роботу з опціональними параметрами 
та властивостями.
- Об'єктно-орієнтоване програмування в TypeScript, роботі з класами та інтерфейсами, а також про використання UML 
та шаблонів проєктування для структурування та організації коду.
- Використання TypeScript у контексті розробки на React, типізація компонентів та хуків, а також обробка подій з типізацією.

TypeScript відкриває нові можливості та значно спрощує життя під час програмування. 
Він надає статичну типізацію та багато корисних функцій, що полегшують розробку та зменшують кількість помилок.

В цьому модулі ти дізнаєшся:
Що таке TypeScript і його переваги;
Як встановити та налаштувати середовище розробки;
Які необхідні кроки для налаштування компілятора;
Що таке Debugging, як правильно його виконувати.
 */

/**
   |============================
   | Що таке TypeScript і навіщо він потрібен
   |============================
 */
/* 
TypeScript — це мова програмування, створена Microsoft, яка розширює JavaScript і додає типи та деякі інші функції. 

Це суперсет JavaScript, який означає, що будь-який дійсний код JavaScript також є дійсним кодом TypeScript.

Мови програмування бувають двох типів: компільовані, такі як C, C++, Go і Rust, та інтерпретовані, такі як Python, Ruby, JavaScript 
та PHP. TypeScript, хоч і не у звичному сенсі, можна віднести до компільованих мов, оскільки він у результаті компілюється 
в JavaScript, і для цього нам потрібен компілятор. 

Процес перетворення TS на JS називається транспіляція. Це дозволяє відловлювати помилки не на етапі виконання коду, 
а на етапі компіляції, що є однією з великих переваг TypeScript. Однак, важливо зазначити, що оскільки TypeScript 
в результаті перетворюється на JS, потрібно враховувати наступне: якщо ви вказали тип number для якогось поля, 
а після компіляції передасте рядок, жодної помилки не буде.

Якщо згадати початок 2012 року, коли TypeScript тільки з'явився, обговорювали, чи він вартий докладання зусиль, 
і наскільки виправдано його використання. На той час еталоном розробки був JQuery, який закривав усі проблеми розробки на frontend. 
Node.js був не дуже популярний, про нього майже не згадували, і backend-технологія відбувалася на чистому JS.

Згодом frontend-код став складнішим, як і код на backend. Такі фреймворки, як React, Angular, Vue, набули масового поширення, 
і JQuery відійшов на другий план. Ось тут люди й згадали про TypeScript, тому що чистий JS не покриває всі парадигми 
об'єктно-орієнтованого програмування (ООП), не має суворої типізації, важко контролювати структуру даних.

TypeScript по суті є синтаксичним цукром для розробки. Його перевага полягає в тому, що він забезпечує статичну типізацію, 
яка допомагає виявити та виправити помилки раніше, покращує читабельність і підтримку коду. TypeScript також забезпечує повноцінну 
підтримку ООП і включає класи, інтерфейси та наслідування.

TypeScript значно уповільнює час розробки, швидше писати на чистому JS, але це ставка на перевагу в майбутньому. 
Приходить новий розробник і він вже розуміє, що саме треба передати в метод і якого типу, навіть без дослідження документації. 
До того ж сам процес розробки стає зрозумілішим, оскільки більшість помилок буде видно в процесі розробки, а не після запуску коду.

Загалом TypeScript став стандартом для великих застосунків, особливо в сучасних фреймворках, таких як React, Angular і Vue.js. 
Знання TypeScript значно збільшує ваші шанси знайти роботу або поліпшити свої навички як розробника.
*/

/**
  |============================
  | Основні переваги використання TypeScript
  |============================
*/
/* 
Давайте ще глибше розберемося в темі, чим саме гарний TypeScript, оскільки це важливий крок під час вибору мови розробки, 
й нам потрібно враховувати її основні переваги.

- Статична типізація. Статична типізація є основною перевагою TypeScript, що значно спрощує процес розробки. 
Це дозволяє уникнути багатьох помилок вже на стадії написання коду, оскільки типи змінних відомі заздалегідь.
- Підтримка ООП. TypeScript має повну підтримку об'єктно-орієнтованого програмування та включає класи, інтерфейси й успадкування. 
Це робить TypeScript чудовим інструментом для розробки великих і складних застосунків.
- Підтримка сучасних функцій JavaScript. TypeScript постійно оновлюється для підтримки нових і майбутніх функцій ECMAScript. 
Це дозволяє розробникам використовувати найсучасніші функції JavaScript і бути впевненими в їхній стабільній роботі.
- Інструменти розробки. TypeScript значно покращує взаємодію з інструментами розробки. Він пропонує покращене автозаповнення коду, 
підказки по типах, перехід до визначень та багато інших функцій, які спрощують процес написання коду.
- Сумісність із JavaScript. TypeScript — це суперсет JavaScript, що означає, що будь-який код JavaScript, що вже існує, 
можна перевести на TypeScript без модифікації. Це значно полегшує процес міграції на TypeScript і дозволяє використовувати 
вже наявний код.
- Зрозумілість і підтримка коду. Статична типізація робить код, написаний на TypeScript, більш зрозумілим і підтримуваним. 
Це полегшує роботу над проєктами, особливо у великих командах.
- Більш безпечний рефакторинг. TypeScript полегшує процес рефакторингу коду, що допомагає уникнути помилок, які можуть 
виникнути під час зміни типів або структур даних.
*/
/**
  |============================
  | Встановлення та налаштування середовища розробки
  |============================
*/
/* 
Для ефективної роботи з TypeScript нам потрібно зробити кілька кроків для встановлення та налаштування середовища розробки. 
У цьому випадку ми будемо використовувати Node.js і Visual Studio Code (VS Code).

Спочатку потрібно встановити Node.js, якщо у вас його немає. Ви можете завантажити його з офіційного сайту за адресою 
https://nodejs.org/en/. Рекомендується вибрати версію LTS (Long Term Support), оскільки вона є найстабільнішою.

Наступним кроком буде встановлення TypeScript. Це можна зробити за допомогою Node Package Manager (npm), який автоматично 
встановлюється з Node.js. 

Відкрийте термінал і виконайте наступну команду:
npm install -g typescript

Ця команда встановлює TypeScript глобально на ваш комп'ютер, що дозволяє використовувати його в будь-якому проєкті.

Visual Studio Code (VS Code) — чудовий вибір для роботи з TypeScript. Якщо ви ще не встановили VS Code, ви можете завантажити 
його з офіційного сайту: https://code.visualstudio.com/.

Після встановлення VS Code рекомендується встановити наступні розширення, які спростять розробку:

ESLint
Prettier - Code formatter
Path Intellisense

Тепер у вас є все необхідне для початку роботи з TypeScript! Ви можете створити новий файл TypeScript з розширенням .ts 
і почати писати код.

Ми створили файл test.ts і тепер перекинемо в нього код з попереднього прикладу, але давайте виправимо помилку:

function add(num1: number, num2: number) {
  return num1 + num2;
}

add(1, 1);

І ми зробимо його компіляцію в консолі за допомогою команди:
tsc test.ts

У нас з`явився файл js поруч з файлом ts. 

Як бачимо, в js зникли всі типи після компіляції, і це стало звичайним JavaScript.

Ми також можемо стежити за зміною файлу в режимі реального часу, виконавши команду:
tsc test.ts -w

Повна команда виглядає так:
tsc test.ts -watch

Щоразу, коли ви зберігаєте файл, він буде компілюватися знову, якщо виникне помилка, ви відразу побачите її в консолі.
*/

/**
  |============================
  | Налаштування компілятора
  |============================
*/
/* 
Ми навчилися компілювати один файл, але що робити, якщо є декілька файлів? 
Нам буде не дуже зручно запускати компілятор для кожного файлу окремо. Замість цього ми можемо створити проєкт TypeScript.

Давайте створимо нову папку (наприклад, ts_courses), перейдемо до неї та виконаємо в консолі команду:
tsc --init

Ця команда створить файл tsconfig.json, який містить стандартні налаштування TypeScript.

Файл tsconfig.json містить багато налаштувань. Розглянемо деякі з найважливіших:

baseUrl: Якщо ваш проєкт має складну структуру, і ви не хочете прописувати повний шлях, як app/javascript/react/Component 
під час імпорту, ви можете використовувати baseUrl для спрощення імпорту, наприклад, react/Component. 
У цьому разі baseUrl буде app/javascript.

outDir: Каталог, де зберігаються скомпільовані файли.

rootDir: Коренева папка проєкту, у якій знаходиться основний файл.

target: Визначає версію ECMAScript, яка використовується для генерації вихідного коду. Наприклад, якщо вказати es5, 
компільований файл не матиме команд const і let та інших нових функцій, які були додані до es6, але код буде підтримуватися 
старими браузерами. ESNext генерує код, який відповідає останній версії ECMAScript. У сучасному світі можна починати з версії 
es2019 і вище.

module: Визначає систему модулів для використання. commonjs — стандартна система модулів для Node.js. Але ES2020 або 
ES2022 краще підходить для розробки на клієнтській стороні.

strict: Включає всі суворі перевірки типів у TypeScript. Це допомагає уникнути багатьох поширених помилок коду.

lib: Визначає, які бібліотеки слід використовувати. Якщо передати порожній масив у lib, у нашому коді буде недоступний 
навіть console.log. У lib потрібно вказати мінімально необхідну версію JavaScript, наприклад ["ES2021"].

allowJs: Дозволяє компілятору TypeScript обробляти файли JavaScript. Це може бути корисно, якщо ви мігруєте проєкт, 
написаний на JavaScript і переписується на TypeScript. Після завершення міграції це налаштування зазвичай ставлять у false.

esModuleInterop: Дозволяє імпортувати модулі CommonJS так, ніби вони були б ES6-модулями. Це означає, що якщо у нас 
є якась бібліотека, яка використовує CommonJS, нам доведеться писати так:
import * as express from 'express';
З esModuleInterop ми можемо імпортувати модулі більш природним для ES6 способом:
import express from 'express';

allowSyntheticDefaultImports: Працює у зв`язці з esModuleInterop і дозволяє запобіганню помилок, які виникають під час 
збірки через несумісності SystemJS і CommonJS. Це налаштування стосується типів.

experimentalDecorators: Якщо увімкнути цю опцію, TypeScript дозволятиме використання декораторів у вашому коді.

emitDecoratorMetadata: Це налаштування, що використовується у зв`язці з experimentalDecorators, додає метадані до декораторів.

isolatedModules: Гарантує, що кожен файл буде розглядатися як окремий модуль, буде неможливо створити файл і щось експортувати 
з нього. Увімкнено за замовчуванням під час створення проєкту через Create React App. Якщо увімкнено — ви не зможете 
використовувати const enum у коді.

preserveConstEnums: Якщо preserveConstEnums встановлено в true, TypeScript зберігає константні перерахування у згенерованому 
коді JavaScript, коли увімкнено isolatedModules.

moduleResolution: Визначає стратегію розділення модулів. Доступні два значення: "node" і "classic". Оскільки наші пакети 
встановлені через npm, найкращим вибором є node.

skipLibCheck: Вимикає перевірку типів у бібліотеках node_modules. Зазвичай встановлюється в true для пришвидшення компіляції.

strictNullChecks: TypeScript не дозволить вам використовувати значення null або undefined, де очікується об'єкт. 
Це допомагає запобігти багатьом поширеним помилкам, оскільки null і undefined є основними джерелами помилок у JavaScript.

types: Дозволяє задати власні глобальні типи.

sourceMap: Чи створювати файли source map.

jsx: Відповідає за обробку синтаксису JSX. Вам знадобиться значення "react" або "react-jsx", додане в TypeScript 4.1 для 
підтримки нового JSX Transform, введеного в React 17.

І декілька параметрів, які записуються поза блоком compilerOptions:

include: Визначає, які файли слід включити до процесу компіляції. Наприклад, ви можете включити всі файли TypeScript за допомогою 
[ "** /*.ts", "** /*.tsx" ].

exclude: За замовчуванням, якщо значення не задано, до нього включається "node_modules". Якщо потрібно виключити певні файли 
чи каталоги, потрібно вручну додати "node_modules". Якщо ви бажаєте виключити певні типи файлів з усіх папок, наприклад тести, 
ви можете вказати "** /*.spec.ts". Тоді буде ["./node_modules", "** /*.spec.ts"].

Це основні налаштування, які можна змінювати залежно від потреб вашого проєкту.

Може здатися, що налаштувань занадто багато, але з досвідом ви, можливо, скажете, що їх не вистачає :)

Давайте налаштуємо tsconfig.json самостійно.

{
  "compilerOptions": {
    "allowJs": false,
    "allowSyntheticDefaultImports": true,
    "emitDecoratorMetadata": true,
    "esModuleInterop": true,
    "experimentalDecorators": true,
    "lib": ["ES2021"],
    "module": "es2020",
    "moduleResolution": "node",
    "preserveConstEnums": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "target": "es2019"
  },
  "include": ["** /*.ts"]
}

Давайте створимо файл index.html у корені проєкту, а також додамо каталог src, який буде містити два файли: 
index.ts і concatenation.ts.

Оскільки у нас є проєкт, ми можемо просто виконати команду:
tsc

Давайте подивимося, що вийшло:

У каталозі src з'явилися два файли: index.js і concatenation.js. Ми досягли того, що хотіли. Ми скомпілювали весь 
проєкт однією командою.

Але що в цьому незручно? Справа в тому, що файли js і ts знаходяться поруч один до одного. Якщо файлів буде багато, нам, 
як мінімум, буде важко знайти потрібні. Давайте встановимо два параметри в налаштуваннях: outDir і rootDir.

Додамо ці параметри в tsconfig.json:
{
  "compilerOptions": {
    "rootDir": "./src", // new
    "outDir": "./dist", // new
    "allowJs": false,
    "allowSyntheticDefaultImports": true,
    "emitDecoratorMetadata": true,
    "esModuleInterop": true,
    "experimentalDecorators": true,
    "lib": ["ES2021"],
    "module": "es2020",
    "moduleResolution": "node",
    "preserveConstEnums": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "target": "es2019"
  },
  "include": ["** /*.ts"]
}

І знову виконаємо команду:
tsc

Тепер наш проєкт розділено на дві частини: у dist зберігаються файли js, а в src - файли ts.

Давайте тепер напишемо код, почнемо з index.html:

<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Simple TypeScript page</title>
    <script type="module" src="./dist/index.js" defer></script>
  </head>
  <body>
    <input />
    <button>Concat!</button>
  </body>
</html>

Зверніть увагу, ми встановили type="module" для script. Це пов'язане з тим, що ми хочемо використовувати команду 
import у коді, і браузер буде підтримувати його, тільки якщо використовуються модулі.

А тепер давайте опишемо concatenation.ts і index.ts:

-----

function concatenation(firstWord: string, secondWord: string) {
  console.log(`${firstWord} ${secondWord}`);
}

export { concatenation };

-----

import { concatenation } from './concatenation';

const button = document.querySelector('button')!;
const input = document.querySelector('input')!;

if (button && input) {
  button.addEventListener('click', () => {
    concatenation(input.value, 'hello!');
  });
}

-----

Здається, ми все написали правильно, але все одно бачимо помилки, пов'язані з console і document. 
Якщо ми наведемо курсор на ці помилки, ми побачимо:

Cannot find name 'document'. Do you need to change your target library? Try changing the 'lib' compiler option to include 'dom'.


Отже, нам потрібно додати 'dom' в налаштування 'lib' файлу tsconfig.json:

{
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./dist",
    "allowJs": false,
    "allowSyntheticDefaultImports": true,
    "emitDecoratorMetadata": true,
    "esModuleInterop": true,
    "experimentalDecorators": true,
    "lib": ["dom", "ES2021"], // new
    "module": "es2020",
    "moduleResolution": "node",
    "preserveConstEnums": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "target": "es2019"
  },
  "include": ["** /*.ts"]
}

Але якщо ми зараз відкриємо файл index.js в браузері, то отримаємо помилку CORS.

На жаль, ми не можемо використовувати модулі, а отже, команду import, локально. Нам знадобиться сервер. 

Давайте швидко встановимо сервер @web/dev-server. Але для початку ініціалізуємо проєкт через npm:
npm init -y

Тепер встановимо сам сервер:
npm i --save-dev @web/dev-server

Перейдемо до файлу package.json, де нам потрібно додати команду start:

{
  "name": "courses_ts",
  "version": "1.0.0",
  "description": "",
  "scripts": {
    "start": "web-dev-server --node-resolve --open --watch"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@web/dev-server": "^0.2.1"
  }
}

А тепер просто запускаємо:

npm start


Ми створили невеликий застосунок. Давайте ще трохи поговоримо про зручність розробки. Щоб не виконувати команду 'tsc' щоразу, 
коли ми змінюємо код, ми можемо використовувати наступну команду:

tsc -w

Вона автоматично слідкуватиме за файлами проєкту і компілювати файли, які були змінені. Для того, щоб не зупиняти виконання 
npm start щоразу, можна відкрити tsc -w в окремій консолі.
*/

/**
  |============================
  | Debugging
  |============================
*/
/* 
У програмуванні налагодження (або debugging) — це процес виявлення та виправлення помилок або аномалій у програмному 
забезпеченні. Це критичний процес у життєвому циклі розробки застосунків, що дозволяє виявляти та виправляти помилки.

Для занурення в цей процес нам потрібно розібрати важливу технологію Source Maps.

Source Map — це файл, який браузер використовує для відображення транспільованого або мініфікованого коду назад у вихідний код.

Це дозволяє вам бачити вихідний код в інструментах розробника браузера, навіть якщо ви працюєте з компільованою версією коду. 

У компаніях часто використовують такі системи, як Sentry, які відстежують помилки користувачів. Однак код на продакшені 
зазвичай мініфікований і source maps дозволяють побачити нормальний, читабельний код.

У контексті TypeScript, для генерації source maps потрібно додати в tsconfig.json опцію "sourceMap": true 
в секції "compilerOptions". Це призведе до генерації .map-файлів разом з компільованими JavaScript-файлами. 
Ці файли містять інформацію, яка зв'язує ваш мініфікований або транспільований код із вихідними файлами.

Давайте додамо цей параметр:

{
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./dist",
    "allowJs": false,
    "allowSyntheticDefaultImports": true,
    "emitDecoratorMetadata": true,
    "esModuleInterop": true,
    "experimentalDecorators": true,
    "lib": ["dom", "ES2021"],
    "module": "es2020",
    "moduleResolution": "node",
    "preserveConstEnums": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "target": "es2019",
    "sourceMap": true
  },
  "include": ["** /*.ts"]
}

Подивимося, що у нас вийшло в каталозі dist:

Ви побачите, що кожному файлу .js відповідає файл .map, який містить карту для перетворення коду назад у вихідний вигляд. 
Якщо ми відкриємо файл, побачимо таке:

{"version":3,"file":"concatenation.js","sourceRoot":"","sources":["../src/concatenation.ts"],"names":[],
"mappings":"AAAA,SAAS,aAAa,CAAC,SAAiB,EAAE,UAAkB;IAC1D,OAAO,CAAC,GAAG,CAAC,GAAG,SAAS,IAAI,UAAU,GAAG,CAAC,
CAAC;AAC7C,CAAC;AAED,OAAO,EAAE,aAAa,EAAE,CAAC"}

Але що нам це дає на практиці? Коли ви відкриваєте вкладку "Sources" в інспекторі браузера, ви бачите директорії 
та файли, які відповідають вашому вихідному коду TypeScript. Ви можете поставити точку зупинки (breakpoint) у будь-якому 
місці вашого TypeScript-коду, і браузер зупинить виконання після досягнення цієї точки.

Тепер під час натискання кнопки 'Concat!' код зупинить своє виконання, і ми зможемо дослідити, що зберігається в змінних 
і як працює код. Принадність полягає в тому, що ми працюємо з кодом на TypeScript, ніби це він виконується, а не JavaScript.
*/
