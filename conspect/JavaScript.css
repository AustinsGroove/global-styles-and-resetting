/**
  |============================
  | Подключение скрипта
  |============================
*/
/* Чтобы подключить JavaScript из внешнего файла:

Создайте файл с расширением .js и поместите его в подпапку js.
Затем укажите путь к файлу скрипта в атрибуте src тега script.
Cкрипт подключают перед закрывающим тегом <body> после всего содержимого

<script src="js/script.js"></script> 

Если скрипт подключен в <head>, отрисовка страницы останавливается до тех пор, пока скрипт не загрузится и выполнится полностью.
*/ /**
  |============================
  | Синтаксис
  |============================
*/
/* 
Инструкция (statement) - это связанный набор слов и символов из синтаксиса языка, которые объединяются чтобы выразить одну идею, 
одну инструкцию для машины.
a = b * 2;
    a и b - переменные (как в алгебраическом уравнении), это хранилища данных, которые использует программа. Переменная состоит 
            из идентификатора (имени) и связанного с ним значения.
    2 - просто число. Это называется значением литерала (literal value), так как не хранится в переменной.
    = и * - операторы, производят действия над значениями и переменными.

Инструкции состоят из частей, как в любом языке предложения состоят из фраз, и эти фразы называются выражениями.
Выражение (expression) - ссылка на переменную или значение, или на набор переменных и значений в сочетании с операторами.

Интерфейс - это набор свойств и методов сущности, доступных для использования в исходном коде.

Свойство
У нас с вами есть свойства: рост, вес, цвет глаз, то есть какие-то описательные характеристики. Так же и у данных есть свойства, 
например у строки есть свойство ее длины. Синтаксис обращения к свойству очень простой - через точку.
сущность.имя_свойства
Для наглядности обратимся к свойству строки length, которое содержит кол-во символов строки.
"JavaScript is awesome".length;

Метод
Это вызов действия, например присесть или плавать, то есть какая-то активная операция. Так же и у данных есть свои заранее 
определённые методы, например можно добавить или удалить элементы из коллекции, перевести строку в разный регистр и т. д. 
Синтаксис вызова метода очень похож на обращение к свойству, но в конце добавляется пара круглых скобок.
сущность.имя_метода()
Для примера обратимся к методу строки toUpperCase(), который сделает все буквы заглавными.
"JavaScript is awesome".toUpperCase();

Строгий режим
Новая возможность в спецификации ECMAScript 5, которая позволяет переводить скрипт в режим полного соответствия современному стандарту. 
Это предотвращает определенные ошибки, такие как использование небезопасных и устаревших конструкций.
Для того, чтобы перевести скрипт в строгий режим, достаточно указать директиву в начале js-файла. 
Всегда пишите код в строгом режиме.

script.js
"use strict";
// Это комментарий. Дальше идет весь код JS-файла
*/
/**
  |============================
  | Переменные и типы
  |============================
*/
/* 
Переменные используются для хранения данных и состоят из идентификатора (имени) и области в памяти, где хранится их значение.

Идентификатор - это имя переменной, функции или класса. Состоит из одного или нескольких символов в следующем формате.

Первым символом должна быть буква a-z или A-Z, символ подчеркивания _ или знак доллара $.
Другие символы могут быть буквами a-z, A-Z, цифрами 0-9, подчеркиваниями _ и знаками доллара $.
Идентификаторы чувствительны к регистру. Это значит, что переменные user, usEr и User различны.

Использование camelCase-нотации для идентификаторов это стандарт. Первое слово пишется строчными буквами, а каждое последующее 
начинается с заглавной. Например, user, greetUser, getUserData.

Как называть переменные:
https://bookflow.ru/kak-nazyvat-peremennye/

Есть список зарезервированных ключевых слов, которые имеют специальное значение и используются для определенных конструкций. 
Нельзя использовать ключевые слова как идентификаторы.
abstract	arguments	await	boolean
break	byte	case	catch
char	class	const	continue
debugger	default	delete	do
double	else	enum	eval
export	extends	false	final
finally	float	for	function
goto	if	implements	import
in	instanceof	int	interface
let	long	native	new
null	package	private	protected
public	return	short	static
super	switch	synchronized	this
throw	throws	transient	true
try	typeof	var	void
volatile	while	with	yield

Объявление переменной начинается с ключевого слова const. Такая переменная должна быть сразу инициализирована значением, после 
чего его нельзя переопределить.
Переменные, объявленные как const, обязательно должны быть инициализированы значением во время объявления, иначе будет ошибка.

const yearOfBirth = 2006;

Для того, чтобы объявить переменную, которой в будущем можно будет присвоить новое значение, используется ключевое слово let.
Переменным, объявленным через let, не обязательно сразу присваивать значение.

let age;

Если переменной, объявленной как let, изначально не присвоено значение, она инициализируется специальным значением undefined (не определено).

константы и КОНСТАНТЫ
Имена КОНСТАНТ - переменных, значение которых не изменяется никогда на протяжении работы всего скрипта, обычно записываются 
в формате UPPER_SNAKE_CASE.
Абсолютное большинство переменных – константы в другом смысле, они просто не изменяют значение после присвоения. 
Но при разных запусках скрипта, это значение может быть разным. Имена таких переменных записывают используя формат camelCase.

неопределенные и необъявленные переменные
Неопределенная (undefined) - это переменная, которая была объявлена ключевым слово let, но не инициализирована значением. 
По умолчанию ей присваивается начальное значение undefined.
Необъявленная (undeclared или not defined) - это переменная, которая не была объявлена в доступной области видимости. Попытка обратиться 
к пременной до её объявления вызовет ошибку. Например, чтобы прочитать или изменить её значение.

Примитивные типы
- Number - целые числа и числа с плавающей запятой (точкой).
const age = 20;
- String - строки, последовательность из нуля или более символов. Строка начинается и заканчивается одиночной ', или двойными кавычками ".
const username = "Mango";
- Boolean - логический тип данных, флаги состояния. Всего два значения: true и false. 
const isLoggedIn = true;
- null - особое значение, которое по сути значит ничто. Используется в тех ситуациях, когда необходимо явно указать пустоту. 
К примеру если пользователь ещё ничего не выбрал, то можно сказать что значение null.
let selectedProduct = null;
- undefined - ещё одно специальное значение. По умолчанию, когда переменная объявляется, но не инициализируется, ее значение 
не определено, ей присваивается undefined.
let username;
console.log(username); // undefined

Оператор typeof
Используется для получения типа значения переменной. Возвращает на место своего вызова тип значения переменной указанного после 
него - строку в которой указан тип.
let username;
console.log(typeof username); // "undefined"
let inputValue = null;
console.log(typeof inputValue); // "object"
*/
/**
  |============================
  | Взаимодействие с пользователем
  |============================
*/
/* 
Вывод данных
Для вывода данных есть два метода: console.log() и alert(). 
В круглых скобках указываем имя переменной, значение которой необходимо вывести.
Можно сначала указать какую-то описательную строку, после чего поставить запятую и указать имя переменной.

const username = "Mango";
console.log("Username is ", username);

Метод alert() выводит модальное окно, текст которого соответствует значению переменной (или литерала) которую передадим в скобках.
const message = "JavaScript is awesome!";
alert(message);

Получение данных
Для получения данных от пользователя есть prompt() и confirm(). Это тоже методы из интерфейса window. 
Результатом своего выполнения они возвращают то, что было введено пользователем, поэтому результат их работы можно записать 
в переменную для дальнейшего использования.

confirm() - выводит модальное окно с сообщением, и две кнопки, Ok и Cancel. 
При нажатии на Ok, результатом будет true, при нажатии на Cancel - возвращается false.
const isComing = confirm("Please confirm hotel reservation");
console.log(isComing);

prompt() - выводит модальное окно с полем ввода и кнопками Ok и Cancel. При нажатии Ok, результатом будет то, что ввел пользователь, 
при Cancel - возвращается null.
const hotelName = prompt("Please enter desired hotel name");
console.log(hotelName);
Важная особенность prompt в том, что не зависимо что ввел пользователь, всегда вернется строка. То есть, если пользователь ввел 5, 
то вернется не число 5, а строка "5".
*/
/**
  |============================
  | Основные операторы
  |============================
*/
/* 
Математические операторы
Назначение, функционал и приоритет (порядок) операций ничем не отличаются от школьного курса алгебры. 
Операторы возвращают значение как результат выражения.
Важно запомнить термины составляющих выражения. + - * / % называются операторы, а то, на чем они применяются - операнды.
const x = 10;
const y = 5;
// Сложение
console.log(x + y); // 15
// Вычитание
console.log(x - y); // 5
// Умножение
console.log(x * y); // 50
// Деление
console.log(x / y); // 2
// Остаток от деления
console.log(x % y); // 0
// Сложение с заменой (также есть для всех других операторов)
let value = 5;
// Аналогично записи value = value + 10;
value += 10;
console.log(value); // 15

Операторы сравнения
Используются для сравнения двух значений. Результатом своего выполнения возвращают буль - true или false, то есть «да» или «нет».

a > b и a < b - больше/меньше
a >= b и a <= b - больше/меньше или равно
a == b - равенство
a != b - неравенство
a === b - строгое равенство
a !== b - строгое неравенство

const x = 5;
const y = 10;
const z = 5;

console.log("x > y:", x > y); // false
console.log("x < y:", x < y); // true
console.log("x < z:", x < z); // false
console.log("x <= z:", x <= z); // true
console.log("x === y:", x === y); // false
console.log("x === z:", x === z); // true
console.log("x !== y:", x !== y); // true
console.log("x !== z:", x !== z); // false

«Нестрогие» операторы равенства == и != выполняют преобразование типов сравниваемых значений к числу, что может привести к ошибкам, 
особенно у начинающих.
console.log(5 == "5"); // true
console.log(5 != "5"); // false
На следующей иллюстрации показана таблица сравнения значений используя операторы нестрогого равенства.
https://textbook.edu.goit.global/javascript-yk5evp/v2/img/lesson-01/not-strict-equality.png

Поэтому для проверки равенства или неравенства двух значений используются только операторы === (строгое равенство) и 
!== (строгое неравенство), которые не выполняют приведение типов операндов.
console.log(5 === "5"); // false
console.log(5 === 5); // true
console.log(5 !== "5"); // true
В таком случае, все равно только себе. Перед оценкой ничего не преобразуется.
https://textbook.edu.goit.global/javascript-yk5evp/v2/img/lesson-01/strict-equality.png
*/
/**
  |============================
  | Числа
  |============================
*/
/* 
Все числа в JavaScript, как целые так и дробные, имеют тип Number и записывать их можно не только в десятичной системе счисления.

Приведение к числу
Большинство арифметических операций и математических функций преобразуют значение в число автоматически. 
Для того чтобы сделать это явно, используйте функцию Number(val), передавая ей в val то, что надо привести к числу.
Если значение не возможно привести к числу, результатом будет специальное числовое значение NaN (Not a Number). Аналогичным образом 
происходит преобразование и в других математических операторах и функциях.

const valueA = "5";
console.log(Number(valueA)); // 5
console.log(typeof Number(valueA)); // "number"

const valueB = "random string";
console.log(Number(valueB)); // NaN
console.log(typeof Number(valueB)); // "number"


Методы Number.parseInt() и Number.parseFloat()
Преобразуют строку символ за символом, пока это возможно. При возникновении ошибки возвращается число, которое получилось.

Метод Number.parseInt() парсит из строки целое число.
console.log(Number.parseInt("5px")); // 5
console.log(Number.parseInt("12qwe74")); // 12
console.log(Number.parseInt("12.46qwe79")); // 12
console.log(Number.parseInt("qweqwe")); // NaN

Метод Number.parseFloat() парсит из строки дробное число.
console.log(Number.parseFloat("5px")); // 5
console.log(Number.parseFloat("12qwe74")); // 12
console.log(Number.parseFloat("12.46qwe79")); // 12.46
console.log(Number.parseFloat("qweqwe")); // NaN

Функция Number - преобразует переданное значение в число. 
В случае строки пробельные символы по краям обрезаются, затем, если строку возможно преобразовать в число - то возвращается это число, 
а если нет - возвращается NaN. 
Значение true преобразуется к числу 1, значение false - к числу 0. 
Объекты при численных преобразованиях превращаются в NaN.
 
Преобразуем булевое значение true в число:
Number(true);
Результат выполнения кода:
1
 
А теперь давайте преобразуем булевое значение false:
Number(false);
Результат выполнения кода:
0
 
Давайте в параметр функции введем строку, содержащую число:
Number('53');
В результате преобразования мы получим число:
53
 
А теперь добавим к числу пробелы в начале и в конце строки:
Number(' 5 ');
После выполнения кода лишние пробелы удаляются и в итоге мы получаем число:
5
 
Давайте преобразуем пустую строку:
Number('');
Результат выполнения кода:
0
 
Теперь преобразуем строку, содержащую букву и цифру:
Number('a5');
После выполнения кода получаем значение NaN, показывающее недопустимую математическую операцию:
NaN
 
Давайте поменяем местами в строке букву и цифру:
Number('5a');
Результат выполнения кода останется прежним:
NaN
 
Теперь преобразуем строку, в которой числа разделены пробелом:
Number('5 5');
В результате выполнения кода мы опять увидим, что данная математическая операция недопустима:
NaN
 
Давайте преобразуем булевое значение true, заключенное в строку:
Number('true');
После выполнения кода снова получим NaN:
NaN
 
Теперь преобразуем пустой объект:
Number({});
Результат выполнения кода:
NaN
 
Давайте зададим в параметре функции пустой массив:
Number([]);
В результате мы получим число 0:
0
 
Теперь добавим в массив цифру:
Number([1]);
Массив преобразуется в число:
1
 
Давайте преобразуем массив, включающий две цифры:
Number([1, 2]);
В результате нам снова сообщат, что данная математическая операция недопустима:
NaN



Проверка на число
Для проверки на число можно использовать метод Number.isNaN(val). Он проверяет, является ли указанное значение NaN или нет. 
Метод отвечает на вопрос "Это Not A Number?" и возвращает:
true - если значение val это NaN
false - если значение val это не NaN
Этот метод не производит попытку преобразовать val к числу, а просто выполняет проверку на NaN.

const validNumber = Number("51"); // 51
console.log(Number.isNaN(validNumber)); // false

const invalidNumber = Number("qweqwe"); // NaN
console.log(Number.isNaN(invalidNumber)); // true



Сложение чисел с плавающей точкой

При сложении не целых чисел в JavaScript и других языках программирования, есть особенность. Если кратко, то 0.1 + 0.2 не равно 0.3, 
результат сложения больше чем 0.3. Все от того что машина считает в двоичной системе.
Число 0.1 в двоичной системе счисления - это бесконечная дробь, так как единица на десять в двоичной системе не делится. 
Двоичное значение бесконечных дробей хранится только до определенного знака, поэтому возникает неточность. При сложении 0.1 и 0.2, 
две неточности складываются, получается незначительная, но всё же ошибка в вычислениях.
console.log(0.1 + 0.2 === 0.3); // false
console.log(0.1 + 0.2); // 0.30000000000000004

Конечно, это не означает, что точные вычисления для таких чисел невозможны. Есть несколько методов решения этой проблемы.
Можно сделать их целыми, умножив на N, сложить, а потом результат разделить также на N.
console.log(0.17 + 0.24); // 0.41000000000000003
console.log((0.17 * 100 + 0.24 * 100) / 100); // 0.41
Еще один способ - сложить, а результат отсечь до определённого знака после запятой при помощи метода toFixed().
console.log(0.17 + 0.24); // 0.41000000000000003
console.log((0.17 + 0.24).toFixed(2)); // 0.41




Класс Math
Один из встроенных классов, который предоставляет набор методов для работы с числами.
// Math.floor(num) - возвращает наибольшее целое число, меньшее, либо равное указанному
console.log(Math.floor(1.7)); // 1

// Math.ceil(num) - возвращает наименьшее целое число, большее, либо равное указанному числу.
console.log(Math.ceil(1.2)); // 2

// Math.round(num) - возвращает значение числа, округлённое до ближайшего целого
console.log(Math.round(1.2)); // 1
console.log(Math.round(1.5)); // 2

// Math.max(num1, num2, ...) - возвращает наибольшее число из набора
console.log(Math.max(20, 10, 50, 40)); // 50

// Math.min(num1, num2, ...) - возвращает наименьшее число из набора
console.log(Math.min(20, 10, 50, 40)); // 10

// Math.pow(base, exponent) - возведение в степень 
console.log(Math.pow(2, 4)); // 16

// Math.random() - возвращает псевдослучайное число в диапазоне [0, 1)
console.log(Math.random()); // случайное число между 0 и 1
console.log(Math.random() * (10 - 1) + 1); // псевдослучайное число от 1 до 10

*/

/**
  |============================
  | Строки
  |============================
*/
/* 
Строка - это индексированный набор из нуля или более символов, заключенных в одинарные либо двойные кавычки.
const username = "Mango";
Важно помнить, что индексация элементов строки начинается с нуля. К примеру в строке "JavaScript" буква "J" стоит на позиции с индексом 0.
Содержимое строки нельзя изменить, только прочитать. То есть нельзя взять какой-то символ и заменить его, 
как только строка создана - она такая навсегда. Можно лишь создать целиком новую строку и присвоить в переменную вместо старой.

Конкатенация строк
Если применить оператор + к строке и любому другому типу данных, результатом операции «сложения» будет строка. 
Эта операция называется конкатенация, или сложение строк.
Во время конкатенации, любой тип данных приводится к строке и сшивается со строкой, но есть особенность - последовательность 
записи операндов.
Последовательность операций имеет значение, преобразование типов происходит только в момент операции сложения со строкой, 
до этого момента действуют привычные правила математики.

const message = "Mango " + "is" + " happy";
console.log(message); // Mango is happy
console.log(1 + "2"); // "12"
console.log(1 + "2" + 4); // "124"
console.log(1 + 2 + "4"); // "34"
В последнем примере произошла математическая операция сложения для первых двух чисел 1 и 2, после чего число 3 было преобразовано 
в строку "3" и сшито со строкой "4".



Шаблонные строки
Шаблонные строки это альтернатива конкатенации с более удобным синтаксисом. Шаблонная строка заключена в обратные (косые) 
кавычки вместо двойных или одинарных и может содержать местозаполнители, которые обозначаются знаком доллара и фигурными скобками 
- ${выражение}.

// Используя переменные необходимо составить строку с подставленными значениями
const guestName = "Манго";
const roomNumber = 207;
const greeting =  "Welcome " + guestName + ", your room number is " + roomNumber + "!";
console.log(greeting); // "Welcome Mango, your room number is 207!"

Составлять строки с подставляемыми значениями используя конкатенацию очень неудобно. 
На помощь приходят шаблонные строки и интерполяция.
const guestName = "Манго";
const roomNumber = 207;
const greeting = `Welcome ${guestName}, your room number is ${roomNumber}!`;
console.log(greeting); // "Welcome Mango, your room number is 207!"



Свойство length
Для того чтобы узнать длину строки, то есть количество её символов, у всех строк есть встроенное свойство length, 
значение которого можно получить обратившись к нему через точку после имени переменной или строкового литерала.

const message = "Welcome to Bahamas!";
console.log(message.length); // 19
console.log("There is nothing impossible to him who will try".length); // 47



Методы toLowerCase() и toUpperCase()
Возвращают новую строку в соответствующем регистре, не изменяя оригинальную строку.

const message = "Welcome to Bahamas!";
console.log(message.toLowerCase()); // "welcome to bahamas!"
console.log(message.toUpperCase()); // "WELCOME TO BAHAMAS!"
console.log(message); // "Welcome to Bahamas!"

Чтобы не требовать абсолютно точный ввод можно сделать «нормализацию» введённой пользователем строки, то есть преобразовать 
все её символы в верхний или нижний регистр. Методы строки toLowerCase() и toUpperCase() вернут новую строку в соответствующем 
регистре, не изменяя оригинальную.

const BRAND_NAME = "SAMSUNG";
const userInput = "saMsUng";
const normalizedToUpperCaseInput = userInput.toUpperCase();

console.log(userInput); // 'saMsUng'
console.log(userInput === BRAND_NAME); // false
console.log(normalizedToUpperCaseInput); // 'SAMSUNG'
console.log(normalizedToUpperCaseInput === BRAND_NAME); // true



Метод indexOf()
Возвращает позицию (индекс) на которой находится первое совпадение подстроки или -1, если ничего не найдено.
const message = "Welcome to Bahamas!";
console.log(message.indexOf("to")); // 8
console.log(message.indexOf("hello")); // -1



Метод includes()
Проверяет входит ли подстрока в строку, возвращает буль - true если входит и false в противном случае. 
Регистр символов в строке и подстроке имеет значение, так как например буква "a" не равна букве "А".

const productName = "Ремонтный дроид";
console.log(productName.includes("н")); // true
console.log(productName.includes("Н")); // false
console.log(productName.includes("дроид")); // true
console.log(productName.includes("Дроид")); // false
console.log(productName.includes("Ремонтный")); // true
console.log(productName.includes("ремонтный")); // false



Метод endsWith()
Позволяет определить, заканчивается ли строка символами (подстрокой) указанными в скобках, возвращая true или false.
const jsFileName = "script.js";
console.log(jsFileName.endsWith(".js")); // true
const cssFileName = "styles.css";
console.log(cssFileName.endsWith(".js")); // false



Методы replace() и replaceAll()
Возвращают новую строку, в которой первое (replace) или все совпадения (replaceAll) подстроки заменены на указанное значение.

const jsFileName = "script.js";
const minifiedJsFileName = jsFileName.replace(".js", ".min.js");
console.log(minifiedJsFileName); // "script.min.js"

const cssFileNames = "styles.css, about.css, portfolio.css";
const minifiedCssFileNames = cssFileNames.replaceAll(".css", ".min.css");
console.log(minifiedCssFileNames); // "styles.min.css, about.min.css, portfolio.min.css"



Метод slice()
Метод строк slice(startIndex, endIndex) используется для создания копии части или всей строки. 
Он делает копию элементов строки от startIndex и до, но не включая endIndex и возвращает новую строку, не изменяя оригинал.

const productName = "Repair droid";
console.log(productName.slice(0, 4)); // "Repa"
console.log(productName.slice(3, 9)); // "air dr"
console.log(productName.slice(0, productName.length)); // "Repair droid"
console.log(productName.slice(7, productName.length)); // "droid"
*/

/**
  |============================
  | Логические операторы
  |============================
*/
/* 
Логические операторы используются для проверки условий с множественными выражениями, например в операциях сравнения.

Приведение типов
В логических операциях осуществляется приведение типов операндов к true или false. 
Приведение происходит если в коде обнаружен логический оператор.
Truthy и Falsy - термины, которые используются для тех значений, которые, в логической операции, приводятся к true или false, 
хотя изначально не были булями.



Логическое «И»
Оператор && приводит все операнды к булю и возвращает значение одного из них. 
Левый операнд если его можно привести к false, и правый в остальных случаях.

выражение && выражение

В следующем примере оба условия вернут true, поэтому результатом всего выражения будет true - вернётся значение правого операнда.
const age = 20;
console.log(age > 10 && age < 30); // true && true -> true
Если хотябы один из операндов будет приведён к false, результатом выражения будет его значение.

const age = 50;
console.log(age > 10 && age < 30); // true && false -> false
console.log(age > 80 && age < 120); // false && true -> false
То есть логическое «И» запинается на лжи и возвращает то на чём запнулось или последний операнд.

console.log(1 && 5); // true && true -> 5
console.log(5 && 1); // true && true -> 1
console.log(0 && 2); // false && true -> 0
console.log(2 && 0); // true && false -> 0
console.log("" && "Mango"); // false && true -> ""
console.log("Mango" && ""); // true && false -> ""
console.log("Mango" && "Poly"); // true && true -> "Poly"
console.log("Poly" && "Mango"); // true && true -> "Mango"



Логическое «ИЛИ»
Оператор || приводит все операнды к булю и возвращает значение одного из них. 
Левый операнд если его можно привести к true, и правый в остальных случаях.

выражение || выражение

В следующем примере условие слева вернёт true, поэтому результатом всего выражения будет true - вернётся значение первого операнда 
которое было приведено к true.
const age = 5;
console.log(age < 10 || age > 30); // true || false -> true

Тут результатом тоже будет true, так как хотябы один из операндов, в этом случае правый, был приведён к true.
const age = 40;
console.log(age < 10 || age > 30); // false || true -> true

А здесь ни одно из условий не выполняется, поэтому получаем false - значение последнего операнда.
const age = 20;
console.log(age < 10 || age > 30); // false || false -> false

То есть логическое «ИЛИ» запинается на правде и возвращает то на чём запнулось или последний операнд.

console.log(true || false); // true
console.log(false || true); // true
console.log(true || true); // true

console.log(3 || false); // 3
console.log(false || 3); // 3
console.log(3 || true); // 3
console.log(true || 3); // true



Оператор нулевого слияния ??

Аналогичен оператору "ИЛИ" ||, но в качестве false воспринимает только null и undefined
То есть это логический оператор, возвращающий значение правого операнда, если значение левого операнда содержит null или undefined, 
в противном случае возвращается значение левого операнда.



Логическое «НЕ»
Все операторы которые мы рассматривали до этого были бинарными - содержащими два операнда, левый и правый. 
Логическое «НЕ» это унарный оператор - выполняющий операцию над одним операндом справа.

!выражение

Оператор ! приводит операнд к булю, если необходимо, а затем делает инверсию - заменяет его на противоположный 
true -> false или false -> true.

console.log(!true); // false
console.log(!false); // true
console.log(!3); // !3 -> !true -> false
console.log(!"Mango"); // !"Mango" -> !true -> false
console.log(!0); // !0 -> !false -> true
console.log(!""); // !"" -> !false -> true

const isOnline = true;
const isNotOnline = !isOnline; // !isOnline -> !true -> false
*/
/**
  |============================
  | Ветвления
  |============================
*/
/* 
Ветвления используются для выполнения различного кода в зависимсти от условия. Принцип работы простой - результат условия 
приводится к булю true или false, после чего поток программы направляется в ту или иную ветку.



Инструкция if
Входные данные, которые приводятся к булю называются условием. Условие помещают за оператором if в круглых скобках. 
Если условие приводится к true, то выполняется код в фигурных скобках тела if.
Если условие приводится к false, код в фигурных скобках будет пропущен.

let cost = 0;
const subscription = "pro";
if (subscription === "pro") {
  cost = 100;
}
console.log(cost); // 100

let cost = 0;
const subscription = "free";
if (subscription === "pro") {
  cost = 100;
}
console.log(cost); // 0



Инструкция if...else
Расширяет синтаксис if тем, что в случае если условие приводится к false, выполнится код в фигурных скобках после оператора else.
Если условие приводится к true, тело блока else игнорируется.

let cost;
const subscription = "free";
if (subscription === "pro") {
  cost = 100;
} else {
  cost = 0;
}
console.log(cost); // 0

let cost;
const subscription = "pro";
if (subscription === "pro") {
  cost = 100;
} else {
  cost = 0;
}
console.log(cost); // 100



Инструкция else...if
Конструкция if...else может проверить и среагировать на выполнение или невыполнение только одного условия.
Блок else...if позволяет добавить после else еще один оператор if с условием. В конце цепочки может быть классический блок else, 
который выполнится только в случае, когда ни одно из условий не приведётся к true.
При первом же true проверки прекратятся и выполнится только один сценарий, соответствующий этому true. 
Поэтому подобную запись следует читать как: ищу первое совпадение условия, игнорирую все остальное.

let cost;
const subscription = "premium";

if (subscription === "free") {
  cost = 0;
} else if (subscription === "pro") {
  cost = 100;
} else if (subscription === "premium") {
  cost = 500;
} else {
  console.log("Invalid subscription type");
}

console.log(cost); // 500
*/

/**
  |============================
  | Тернарный оператор
  |============================
*/
/* 
Тернарный оператор используется как более синтаксически краткая замена инструкции if...else, когда одной и той же переменной 
необходимо присвоить разные значения по условию.

<условие> ? <выражение_если_условие_истинно> : <выражение_если_условие_ложно>

Работает по такой схеме:
Вычисляется условие.
Если условие истинно, то есть приводится к true, вычисляется выражение после ?.
Если условие ложно, то есть приводится к false, вычисляется выражение после :.
Значение вычисленного выражения возвращается как результат работы тернарного оператора.

Тернарный оператор должен использоваться в простых операциях присваивания или возврата. 
го использование для описания сложных ветвлений - плохая практика (антипаттерн).

let type;
const age = 20;
if (age >= 18) {
  type = "adult";
} else {
  type = "child";
}
console.log(type); // "adult"

Выполним рефакторинг заменив if...else тернарным оператором.

const age = 20;
const type = age >= 18 ? "adult" : "child";
console.log(type); // "adult"

Запишем операцию поиска большего числа.

const num1 = 5;
const num2 = 10;
let biggerNumber;
if (num1 > num2) {
  biggerNumber = num1;
} else {
  biggerNumber = num2;
}
console.log(biggerNumber); // 10

Код работает верно, получаем большее число из двух, но это решение кажется слишком громоздким, учитывая, насколько проста проблема. 
Используем тернарный оператор.

const num1 = 5;
const num2 = 10;
const biggerNumber = num1 > num2 ? num1 : num2;

console.log(biggerNumber); // 10
*/

/**
  |============================
  | Инструкция switch
  |============================
*/
/* 
В некоторых случаях неудобство чтения сложных ветвлений if...else можно избежать используя более «плоский» синтаксис инструкции 
ветвления switch.
Область применения switch ограничена задачами с одним общим вопросом (что сравнивать) и множеством вариантов ответов (с чем сравнивать).
Его синтаксис состоит из блока switch(значение) - что нужно сравнить и множества отдельных случаев case значение - с чем нужно сравнить. 
Для сравнения используется оператор строгого равенства ===. То есть нельзя сравнить на больше или меньше, только на равенство.

switch (значение) {
  case значение:
    инструкции;
    break;
  case значение:
    инструкции;
    break;
  default:
    инструкции;
}

Значение в блоке switch(значение) - строка или число, которое сравнивается на строгое равенство со всеми значениями в блоках case 
значение по порядку, сверху вниз.
Оператор break в завершении каждого блока case необходим чтобы прервать дальнейшие проверки и сразу перейти к коду за switch 
в том случае, когда проверка на равенство вернула true.
Если оператор break будет отсутствовать, то после того как выполнится какое-то условие case, все последующие за ним блоки кода будут 
ыполняться один за другим, что может привести к нежелательным последствиям при неверном применении.
Если ни одного совпадения значений не произошло, необходимо выполнить код по умолчанию, как в блоке else для инструкции if...else. 
Для этого после всех блоков case добавляется блок default. Оператор break после блока default не нужен, так как это и так последнее 
что будет выполнено в switch и управление будет передано коду за ним.

let cost;
const subscription = "premium";

switch (subscription) {
  case "free":
    cost = 0;
    break;

  case "pro":
    cost = 100;
    break;

  case "premium":
    cost = 500;
    break;

  default:
    console.log("Invalid subscription type");
}

console.log(cost); // 500
*/

/**
  |============================
  | Паттерн switch(true)
  |============================
*/
/* 
let value = 10;
switch(true) {
  case value > 5:
    // always do this
    break;
  case value > 15:
    // unreachable
  default:
    // unreachable
}
*/

/**
  |============================
  | Область видимости
  |============================
*/
/* 
------ Глобпльная и локальная (блочная) области видимости -----
Область видимости (scope) - механизм который определяет доступность переменных в исполняемом коде.

Область видимости переменных (variable scope) - доступность переменных в определённом месте кода.

Цепочка областей видимости (scope chain) - области видимости образуют иерархию, так что дочерние области имеют доступ к переменным из родительских областей, 
но не наоборот.

Глобальная область видимости используется по умолчанию. Все и вся имеют доступ к переменным объявленным в ней.
Переменные, объявленные на самом верхнем уровне, то есть вне любых конструкций вроде if, while, for и функций, находятся в глобальной области видимости 
и доступны везде после их объявления.
Например, переменная value объявлена в глобальной области видимости, то есть вне какого-то блока, и доступна в любом месте 
после объявления.

const value = 5;
if (true) {
  console.log("Block scope: ", value); // 5
}

console.log("Global scope: ", value); // 5

Переменные, объявленные внутри инструкций if, for, функций и других блоков кода обрамлённых фигурными скобками {}, находятся в 
блочной области видимости и доступны только внутри этого блока кода или вложенных в него.
Любая конструкция использующая фигурные скобки {} (условия, циклы, функции и т. п.) создает новую локальную область видимости, 
и переменные, объявленные в этой области видимости, используя let или const, не доступны вне этого блока.

if (true) {
  const value = 5;
  console.log("Block scope: ", value); // 5
}

console.log("Global scope: ", value); // ReferenceError: value is not defined

Глубина вложенности областей видимости не ограничена, и все они будут работать по одному принципу - область видимости имеет доступ 
ко всем переменным объявленным выше по иерархии вложенности, но не может получить доступ к переменным объявленным во вложенных 
областях видимости.




----- Поиск по цепочке областей видимости -----
Интерпретатор пытается сначала найти переменную в той области видимости, в которой к ней обратились. Если такой переменной в локальной области видимости нет, 
то он выходит наружу, на один уровень за попытку, пока не найдёт значение или не дойдет до самой верхней области видимости (глобальной) и поймет, 
что переменную с таким идентификатором невозможно найти, так как ее просто нет, тогда будет ошибка о том, что переменная не объявлена.




------ Глобальная и функциональная области видимости -----
var не имеет блочной области видимости
Как мы видели в предыдущих примерах, блок кода создает область видимости для переменных, объявленных с помощью ключевых слов const и let. 
Однако это не работает для переменных, объявленных с помощью ключевого слова var.

Рассмотрим пример:
if (true) {
    // область видимости блока if
    var count = 0
    console.log(count) // 0
}
console.log(count) // 0

Переменная count, как и ожидалось, доступна внутри блока if. Однако, она доступна и за пределами данного блока!
Дело в том, что блок кода не создает области видимости для переменных, объявленных с помощью ключевого слова var. Но это делает функция.

Область видимости функции
Функции в JavaScript создают область видимости для всех переменных, независимо от того, с помощью какого ключевого слова они объявлены (var, const или let).

Например:

function run() {
    // область видимости функции run()
    var message = 'Беги, Форрест, беги!'
    console.log(message)
}
run() // 'Беги, Форрест, беги!'
console.log(message) // ReferenceError

Функция run() создает область видимости. Переменная message доступна внутри функции, но недоступна снаружи.



----- Инициализация в разных областях видимости -----
Попытка присвоеить значение переменной до ее инициализации выдаст ошибку.

let a;
if (true) {
  a = 10;
  let a; // ReferenceError: Cannot access "a" before initialization
} 

В данном примере инициализируется глобальная переменная а. Затем внутри блока if  инициализируется локальная переменная a, но перед этим производится попытка
присвоить ей значение а = 10, что выдаст ошибку.






*/

/**
  |============================
  | Циклы
  |============================
*/
/* 
Цикл - управляющая конструкция в высокоуровневых языках программирования, предназначенная для организации многократного 
исполнения набора инструкций.
Тело цикла - последовательность инструкций, предназначенная для многократного исполнения.
Итерация - единичное выполнение тела цикла.
Условие выхода - выражение, определяющее будет в очередной раз выполняться итерация, или цикл завершится.
Счётчик - переменная, хранящая текущий номер итерации. Цикл не обязательно содержит счётчик, и он не обязан быть один, 
условие выхода из цикла может зависеть от нескольких изменяемых в цикле переменных.




Цикл while
Цикл с предусловием — цикл, который выполняется пока истинно некоторое условие, указанное перед его началом. 
Это условие проверяется до выполнения тела цикла, поэтому тело может быть не выполнено ни разу, если условие с самого начала ложно.

while (condition) {
  // код, тело цикла (statement)
}

Конструкция while создает цикл, который выполняет блок кода, пока условие проверки оценивается как true.
condition, то есть условие, вычисляется перед каждой итерацией цикла.
Если condition оценивается как true, оператор while выполняет statement.
Если condition оценивается как false, выполнение цикла прерывается и скрипт продолжает выполнять инструкции после цикла while.

Сделаем счетчик.

let counter = 0;
while (counter < 10) {
  console.log("counter: ", counter);
  counter += 1;
}

Будем заполнять места в отеле до тех пор пока текущее количество клиентов не будет равно максимально допустимому.

let clientCounter = 18;
const maxClients = 25;
while (clientCounter < maxClients) {
  console.log(clientCounter);
  clientCounter += 1;
}




Цикл do...while
Цикл с постусловием - цикл, в котором условие проверяется после выполнения тела цикла. Отсюда следует, что тело всегда выполняется 
хотя бы один раз.

do {
  // statement
} while (condition);

Конструкция do...while создает цикл, который выполняет блок кода до тех пор, пока condition не вернёт false.
В отличие от цикла while, цикл do...while всегда выполняет statement как минимум один раз, прежде чем он оценит condition.
Внутри цикла нужно внести изменения в некоторую переменную, чтобы убедиться, что выражение равно false после итераций. 
В противном случае будет бесконечный цикл.

let password = "";
do {
  password = prompt("Введите пароль длиннее 4-х символов", "");
} while (password.length < 5);

console.log("Ввели пароль: ", password);




Цикл for
Цикл со счётчиком - цикл, в котором некоторая переменная изменяет своё значение от заданного начального до конечного значения 
с некоторым шагом и для каждого значения этой переменной тело цикла выполняется один раз.

В большинстве процедурных языков программирования реализуется конструкцией for, в которой указывается счётчик, требуемое 
количество итераций и шаг, с которым изменяется счётчик.

for (initialization; condition; post-expression) {
  // statements
}

Алгоритм исполнения цикла for:

Инициализация (initialization) - выполняется один раз перед началом цикла. Используется для создания переменной-счётчика и указания 
её начального значения.
Условие (condition) - выражение, оцениваемое перед каждой итерацией (повторением) цикла. Тело цикла выполняется только тогда, 
когда выражение приводится к true. Цикл завершается, если значение будет false.
Тело (statements) - набор инструкций для выполнения на каждом повторении. Выполняется если выражение условия приводится к true.
Пост-выражение (post-expression) - выполняется в конце каждого повторения цикла, перед проверкой условия. Используется для 
обновления переменной-счётчика.
Переменные-счетчики, по традиции, называются буквами i, j и k.

for (let i = 0; i <= 20; i += 5) {
  console.log(i);
}

В примере объявляется перемнная-счетчик i, инициализируется значением 0 и цикл выполняется до тех пор, пока i <= 20, то есть 
условие приводится к true. После каждой итерации счётчик увеличивается на 5.

Посчитаем сумму чисел до определенного значения.

const target = 3;
let sum = 0;

for (let i = 0; i <= target; i += 1) {
  sum += i;
}

console.log(sum);

Вспомним про операцию a % b и выведем остаток от деления используя цикл.

const max = 10;
for (let i = 0; i < max; i += 1) {
  console.log(`${max} % ${i} = `, max % i);
}




Оператор break
Прервать выполнение цикла можно в любой момент. Для этого сущестует оператор break, который полностью прекращает выполнение цикла 
и передаёт управление на строку за его телом.

Найдём число 3. Как только выполнится условие if, цикл прекратит своё выполнение (будет прерван).

for (let i = 0; i <= 5; i += 1) {
  console.log(i);

  if (i === 3) {
    console.log("Нашли число 3, прерываем выполнение цикла");
    break;
  }
}

console.log("Лог после цикла");





Оператор continue
Прерывает не весь цикл, а только выполнение текущей итерации. Его используют, если понятно, что на текущей итерации цикла делать 
больше нечего или вообще ничего делать не нужно и пора переходить на следующую итерацию.

Используем цикл для вывода только нечетных чисел. Для чётных i срабатывает continue, выполнение тела прекращается и управление 
передаётся на следующую итерацию.

const number = 10;

for (let i = 0; i < number; i += 1) {
  if (i % 2 === 0) {
    continue;
  }

  console.log("Нечетное i: ", i); // 1, 3, 5, 7, 9
}
*/

/**
  |============================
  | Массивы
  |============================
*/
/* 
Массив - структура данных для хранения и манипулирования коллекцией индексированных значений.

Создание
Массив объявляется открывающей и закрывающей квадратной скобками [] - литералом массива. 
Внутри скобок каждый элемент массива разделяется запятой.

const clients = ["Mango", "Poly", "Ajax"];

Доступ к элементам
Для доступа к значению элемента массива используется синтаксис квадратных скобок массив[индекс]. 
Между именем переменной хранящей массив и квадратными скобками не должно быть пробела.
Индексация элементов массива начинается с нуля.

const clients = ["Mango", "Poly", "Ajax"];

// Указывая в скобках индекс элемента мы получаем его значение
console.log(clients[0]); // Mango
console.log(clients[1]); // Poly
console.log(clients[2]); // Ajax



Переопределение
В отличии от строк, элементы массива можно изменять обратившись к ним по индексу и присвоив другое значение.

const clients = ["Mango", "Poly", "Ajax"];
clients[0] = "Kiwi";
clients[1] = "Pango";




Длина массива
Длина массива, то есть число его элементов, хранится в свойстве length. 
Это динамическая величина, которая изменяется автоматически при добавлении или удалении элементов.

const clients = ["Mango", "Poly", "Ajax"];
console.log(clients.length); // 3




Индекс последнего элемента
Чаще всего мы заранее в коде не знаем какая будет длина массива. 
Для того чтобы получить значение последнего элемента применяется следующий подход - длина массива всегда на единицу больше 
чем индекс последнего элемента. Используя формулу длина_массива - 1 можно получить значение последнего элемента массива 
произвольной длины.

const clients = ["Mango", "Poly", "Ajax"];
const lastElementIndex = clients.length - 1;
console.log(lastElementIndex); // 2
console.log(clients[lastElementIndex]); // "Ajax"

*/

/**
  |============================
  | Проверка массива
  |============================
*/
/* 
console.log(typeof arrayName); // object
console.log(Array.isArray(arrayName)); // true
*/

/**
  |============================
  | Итерация по массиву
  |============================
*/
/* 
Цикл for можно использовать для итерации по массиву, то есть «перебрать» его поэлементно.

const clients = ["Mango", "Ajax", "Poly"];

for (let i = 0; i < clients.length; i += 1) {
  console.log(clients[i]);
}
*/

/**
  |============================
  | Цикл for...of
  |============================
*/
/* 
Конструкция for...of объявляет цикл, перебирающий итерируемые объекты, такие как массивы и строки. 
Тело цикла будет выполняться для значения каждого элемента. Это хорошая замена циклу for если не нужен доступ к счётчику итерации.

for (const variable of iterable) {
  // тело цикла
}

variable — переменная которая будет хранить значение элемента на каждой итерации.
iterable — коллекция, которая имеет перечислимые элементы, например массив.

const clients = ["Mango", "Ajax", "Poly"];

for (const client of clients) {
  console.log(client);
}

const string = "javascript";

for (const character of string) {
  console.log(character);
}
*/

/**
  |============================
  | Операторы break и continue
  |============================
*/
/* 
Будем искать имя клиента в массиве имен, если нашли - прервем цикл, так как нет смысла искать дальше, имена у нас уникальные.

const clients = ["Mango", "Poly", "Ajax"];
const clientNameToFind = "Poly";
let message;

for (const client of clients) {
  // На каждой итерации будем проверять совпадает ли элемент массива с
  // именем клиента. Если совпадает то мы записываем в message сообщение
  // об успехе и делаем break чтобы не искать дальше
  if (client === clientNameToFind) {
    message = "Клиент с таким именем есть в базе данных!";
    break;
  }

  // Если они не совпадают то запишем в message сообщение об отсутствии имени
  message = "Клиента с таким именем нету в базе данных!";
}

console.log(message); // "Клиент с таким именем есть в базе данных!"

Можно изначально задать message значение неудачи поиска, а в цикле перезаписать его на успех, если нашли имя. 
Но break все равно пригодится, так как если у нас массив из 10000 клиентов, а нужный нам стоит на позиции 2, то нет абсолютно 
никакого смысла перебирать оставшиеся 9998 элементов.

const clients = ["Mango", "Poly", "Ajax"];
const clientNameToFind = "Poly";
let message = "Клиента с таким именем нету в базе данных!";

for (const client of clients) {
  if (client === clientNameToFind) {
    message = "Клиент с таким именем есть в базе данных!";
    break;
  }
  // Если не совпадает, то на этой итерации ничего не делаем
}

console.log(message); // Клиент с таким именем есть в базе данных!

Используем цикл для вывода только чисел больше определенного значения.

const numbers = [1, 3, 14, 18, 4, 7, 29, 6, 34];
const threshold = 15;

// Для чисел меньше чем порог срабатывает continue, выполнение тела прекращается
// и управление передаётся на следующую итерацию.
for (let i = 0; i < numbers.length; i += 1) {
  if (numbers[i] < threshold) {
    continue;
  }

  console.log(`Число больше чем ${threshold}: ${numbers[i]}`); // 18, 29, 34
}
*/

/**
  |============================
  | Присвоение по ссылке и по значению
  |============================
*/
/* 
Фундаментальным отличием сложных типов от примитивов, является то, как они хранятся и копируются. 
Примитивы: строки, числа, були,null и undefined, при присваивании копируются целиком, по значению (by value).
Все примитивные типы присваиваются по значению, то есть создается копия.
let a = 5;
let b = a;
a = 10;
console.log(a); // 10
console.log(b); // 5

Со сложными типами всё не так. В переменной, которой присвоен массив или объект, хранится не само значение, а адрес его места в памяти, иными словами - ссылка 
(указатель) на него и передаются они по ссылке (by reference).
Сложные типы - объекты, массивы, функции присваиваются по ссылке, то есть переменная просто получает ссылку на уже существующий объект.
const a = ["Mango"];
const b = a;
a.push("Poly");
console.log(a); // ["Mango", "Poly"]
console.log(b); // ["Mango", "Poly"]
*/

/**
  |============================
  | Методы массива
  |============================
*/
/* 
split(delimiter) превращает строку в массив, «разбив» её по разделителю delimiter. Если разделитель это пустая строка, то получится массив отдельных символов. Разделителем может быть один или несколько символов.

const name = "Mango";
console.log(name.split("")); // ["M", "a", "n", "g", "o"]
const message = "JavaScript это интересно";
console.log(message.split(" ")); // ["JavaScript", "это", "интересно"]





join(delimiter) соединяет элементы массива в строку. В строке элементы будут разделены символом или группой символов указанных в delimiter. 
То есть это операция обратная методу строк split(delimiter).

const words = ["JavaScript", "это", "интересно"];
console.log(words.join("")); // "JavaScriptэтоинтересно"
console.log(words.join(" ")); // "JavaScript это интересно"
console.log(words.join("-")); // "JavaScript-это-интересно"





indexOf(value) возвращает первый индекс, в котором элемент со значением value был найден в массиве, или число -1, если такого элемента нет. 
Используйте indexOf тогда, когда необходимо получить непосредственно индекс элемента.

const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.indexOf("Poly")); // 2
console.log(clients.indexOf("Monkong")); // -1





includes(value) проверяет есть ли в массиве элемент со значением value и возвращает true или false соответственно. 
Область применения этого метода сводится к ситуациям когда необходимо проверить есть ли элемент в массиве и не важна его позиция (индекс).

const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.includes("Poly")); // true
console.log(clients.includes("Monkong")); // false





Проверка множественных условий с includes()
const fruit = "apple";
if (
  fruit === "apple" ||
  fruit === "strawberry" ||
  fruit === "cherry" ||
  fruit === "cranberries"
) {
  console.log("It is a red fruit!");
}

Можем переписать условие используя метод includes(), это очень просто и масштабируемо.

const redFruits = ["apple", "strawberry", "cherry", "cranberries"];
const fruit = "cherry";

const hasFruit = redFruits.includes(fruit);
if (hasFruit) {
  console.log(`${fruit} is a red fruit!`);
}





Методы push() и pop()
Добавляют или удаляют крайние элементы массива. Работают с крайним левым и крайним правым элементом и не могут поставить или удалить элемент с произвольной позиции.

Метод push() добавляет один или несколько элементов в конец массива, без необходимости указывать индексы добавляемых элементов. 
Возвращает длину массива после добавления элементов.

const numbers = [];
numbers.push(1);
console.log(numbers); // [1]
numbers.push(2);
console.log(numbers); // [1, 2]
numbers.push(3);
console.log(numbers); // [1, 2, 3]

Метод pop() удаляет последний элемент из конца массива и возвращает удаленный элемент. Если массив пустой, метод возвращает undefined.

const numbers = [1, 2, 3, 4, 5];

console.log(numbers.pop()); //  5
console.log(numbers); // [1, 2, 3, 4]
console.log(numbers.pop()); //  4
console.log(numbers); // [1, 2, 3]
console.log(numbers.pop()); //  3
console.log(numbers); // [1, 2]




Методы shift, unshift

Метод unshift() добавляет один или более элементов в начало массива и возвращает новую длину массива.
Синтаксис
arr.unshift(element1[, ...[, elementN]])
Параметры
element1, ..., elementN - Элементы, добавляемые в начало массива.
Возвращаемое значение - Новое свойство length объекта, над которым был вызван метод unshift.

Метод shift() удаляет первый элемент из массива и возвращает его значение. Этот метод изменяет длину массива.
Синтаксис
arr.shift()
Описание
Метод shift удаляет элемент по нулевому индексу, сдвигает значения по последовательным индексам вниз, а затем возвращает удалённое значение. 
Если свойство length массива равно 0, вернётся значение undefined.
Метод shift не является привязанным к типу; этот метод может быть вызван или применён к объектам, напоминающим массив. Объекты, не содержащие свойство length, 
отражающее последний элемент в серии последовательных числовых, начинающихся с нуля, свойств, могут повести себя неправильным образом.





Метод slice()
slice(begin, end) возвращает новый массив, содержащий копию части исходного массива, не изменяя его. 
Этод метод не мутирует оригинальный массив, то есть не является мутабельным методом.
Копия делается от begin и до, но не включая, end - индексы элементов исходного массива.

const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.slice(1, 3)); // ["Ajax", "Poly"]

Если begin и end не указаны, будет создана полная копия исходного массива.

Если не указан end, копирование будет от start и до конца исходного массива.
const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.slice(1)); // ["Ajax", "Poly", "Kiwi"]

Если значение start отрицательное, а end не указан, то будут скопированы последние start элементов
const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.slice(-2)); // ["Poly", "Kiwi"]





Метод splice()
Швейцарский нож для работы с массивами, если исходный массив нужно изменить. Удаляет, добавляет и заменяет элементы в произвольном месте массива.
Этод метод изменяет оригинальный массив, то есть является мутабельным методом массива.


Удаление
Чтобы удалить элементы в массиве, передаются два аргумента.

splice(position, num)

position - указывает позицию (индекс) первого элемента для удаления
num - определяет количество удаляемых элементов

! Метод splice изменяет исходный массив и возвращает массив, содержащий удаленные элементы. !
Например, у нас есть массив оценок, который содержит пять чисел от 1 до 5.

const scores = [1, 2, 3, 4, 5];

// Удаляем три элемента массива, начиная с первого элемента (индекс 0)
const deletedScores = scores.splice(0, 3);

// Теперь массив scores содержит два элемента
console.log(scores); // [4, 5]

// А массив deletedScores содержит три удаленных элемента
console.log(deletedScores); // [1, 2, 3]


Добавление
Для того чтобы добавить один или несколько элементов в массив, необходимо передать три или более аргумента, при этом второй аргумент должен быть равен нулю.

splice(position, 0, new_element_1, new_element_2, ...)

Аргумент position указывает начальную позицию в массиве, куда будут вставлены новые элементы.
Второй аргумент это ноль, он говорит методу не удалять элементы в месте добавления новых.
Третий, четвертый и все последующие аргументы - это новые элементы, которые добавляются в массив.
Например, у нас есть массив с названиями цветов в виде строк. Добавим новый цвет перед элементом с индексом 2.

const colors = ["red", "green", "blue"];

colors.splice(2, 0, "purple");
console.log(colors); // ["red", "green", "purple", "blue"]

На рисунке показан вызов метода colors.splice(2, 0, 'purple') из примера.


Замена
Замена это операция добавления в которой удаляются элементы в месте добавления новых. Для этого необходимо передать минимум три аргумента. 
Количество удаляемых и добавляемых элементов может не совпадать.

splice(position, num, new_element_1, new_element_2, ...)

position - указывает позицию (индекс) первого элемента для удаления
num - определяет количество удаляемых элементов
Третий, четвертый и все последующие аргументы - это новые элементы, которые добавляются в массив.
например, у нас есть массив языков программирования из четырех элементов.

const languages = ["C", "C++", "Java", "JavaScript"];

// Заменяем элемент с индексом 1 на новый
languages.splice(1, 1, "Python");
console.log(languages); // ["C", "Python", "Java", "JavaScript"]

// Заменяем один элемент (с индексом 2) на несколько
languages.splice(2, 1, "C#", "Swift", "Go");
console.log(languages); // ["C", "Python", "C#", "Swift", "Go", "JavaScript"]





Метод concat()
Объединяет два или более массива в один. Он не изменяет массив на котором вызывается, а возвращает новый. 
Порядок аргументов метода влияет на порядок элементов нового массива.

const oldClients = ["Mango", "Ajax", "Poly", "Kiwi"];
const newClients = ["Monkong", "Singu"];

const allClientsWithOldFirst = oldClients.concat(newClients);
console.log(allClientsWithOldFirst); // ["Mango", "Ajax", "Poly", "Kiwi", "Monkong", "Singu"]

const allClientsWithNewFirst = newClients.concat(oldClients);
console.log(allClientsWithNewFirst); // ["Monkong", "Singu", "Mango", "Ajax", "Poly", "Kiwi"]

console.log(oldClients); // ["Mango", "Ajax", "Poly", "Kiwi"]
console.log(newClients); // ["Monkong", "Singu"]
*/

/**
  |============================
  | Функции
  |============================
*/
/* 
Функция - это подпрограмма, независимая часть кода, предназначенная для многократного выполнения конкретной задачи с разными начальными значениями. 
Функции позволяют структурировать большие программы, уменьшают повторение и изолируют код.
Функцию можно представить как чёрный ящик, она получает что-то на входе (данные), и возвращает что-то на выходе (результат выполнения кода внутри неё).

Объявление функции (function declaration) начинается с ключевого слова function, за которым идёт её имя - глагол отвечающий на вопрос «Что сделать?» 
и пара круглых скобок.
Тело функции заключено в фигурные скобки {} и содержит инструкции которые необходимо выполнить при её вызове. 
Затем, когда необходимо, функция вызывается с помощью имени и пары круглых скобок.

// 1. Объявление функции multiply
function multiply() {
  // Тело функции
  console.log("Это лог при вызове функции multiply");
}
// 2. Вызовы функции multiply
multiply(); // 'Это лог при вызове функции multiply'



Параметры и аргументы
В круглых скобках после имени функции идут параметры - перечисление данных которые функция ожидает при вызове.

// Объявление параметров x, y, z
function multiply(x, y, z) {
  console.log(`Результат умножения равен ${x * y * z}`);
}

Параметры это локальные переменные доступные только в теле функции. Они разделяются запятыми. Параметров может быть несколько, или вообще не быть, 
тогда записываются просто пустые круглые скобки.
Параметры будут создаваться заново каждый раз при вызове функции, и их отдельные инкарнации никак друг с другом не связаны.

При вызове функции, в круглых скобках можно передать аргументы - значения для объявленных параметров функции.

!!! Если аргументов будет меньше чем параметров, то параметрам без значений будет присвоено undefined !!!

!!! Параметры и их аргументы создают локальные переменные в теле функии !!! :

let someValue = 2;                     // глобальная переменная someValue = 2
function checkScope(someValue) {       // параметр someValue будет создавать в теле функии локальную переменную someValue и принимать ее знаение из аргумента
 someValue = 45;                       // локальной переменной someValue присваевается значение 45
 return someValue;                     // функция возвращает в место своего вызова 45
}
checkScope(someValue);                 // вызов функии
console.log(someValue);                // 2

// 1. Объявление параметров x, y, z
function multiply(x, y, z) {
  console.log(`Результат умножения равен ${x * y * z}`);
}
// 2. Передача аргументов
multiply(2, 3, 5); // Результат умножения равен 30
multiply(4, 8, 12); // Результат умножения равен 384
multiply(17, 6, 25); // Результат умножения равен 2550

Порядок передачи аргументов должен соответствует порядку объявленых параметров: значение первого аргумента будет присвоено первому параметру, 
второго аргумента второму параметру и т. д. 

!!! Если аргументов будет меньше чем параметров, то параметрам без значений будет присвоено undefined !!!

function fn(valA, valB) {
     return valA + valB;
}

fn(4, 5); //   9
fn(4);    //   NaN



Оператор return используется для передачи значения из тела функции во внешний код. 
Когда интерпретатор встречает return, он сразу же выходит из функции (прекращает её выполнение), и возвращает указанное значение в то место кода, 
где функция была вызвана.

function multiply(x, y, z) {
  console.log("Код до return выполняется как обычно");
  // Возвращаем результат выражения умножения
  return x * y * z;
  console.log("Этот лог никогда не выполнится, он стоит после return");
}
// Результат работы функции можно сохранить в переменную
let result = multiply(2, 3, 5);
console.log(result); // 30

Оператор return без явно указанного значения возвращает специальное значение undefined.
При отсутствии return в теле функции, она все равно вернёт undefined.



Порядок выполнения кода
Когда интерпретатор встречает вызов функции (или метода), он приостанавливает выполнение текущего кода и начинает выполнять код из тела функции. 
После того как весь код функции будет выполнен, интерпретатор выходит из тела функции, возвращаясь в то место, откуда пришел и продолжает выполнять код, 
следующий после вызова функции.

function multiply(x, y, z) {
  console.log(`Результат умножения равен ${x * y * z}`);
}
console.log("Лог до вызова функции multiply");
multiply(2, 3, 5); // Результат умножения равен 30
console.log("Лог после вызова функции multiply");

// Последовательность логов в консоли
// "Лог до вызова функции multiply"
// "Результат умножения равен 30"
// "Лог после вызова функции multiply"



Параметры по умолчанию
Иногда необходимо объявить функцию, у параметров которой будут значения отличные от undefined, даже если для них не передали аргументы. 
Это делается очень простым и очевидным образом, достаточно указать значение по умолчанию прямо при объявлении параметров в подписи функции. 
При такой записи, если для параметра не передано значение аргумента, используется значение по умолчанию.

function count(countFrom = 0, countTo = 10, step = 1) {
  console.log(`countFrom = ${countFrom}, countTo = ${countTo}, step = ${step}`);
  for (let i = countFrom; i <= countTo; i += step) {
    console.log(i);
  }
}

count(1, 5); // countFrom = 1, countTo = 5, step = 1
count(2); // countFrom = 2, countTo = 10, step = 1
count(); // countFrom = 0, countTo = 10, step = 1




Псевдомассив arguments
Доступ к списку всех аргументов можно получить при помощи специальной переменной arguments, которая доступна только внутри функции и хранит все аргументы 
как псевдомассив.
Псевдомассив - коллекция, со свойством length и возможностью обратиться к элементу по индексу, но отсутствием большинства методов для работы с массивом.
Рассмотрим пример использования arguments в функции, которая умножает любое количество аргументов:

function multiply() {
  let total = 1;

  for (const argument of arguments) {
    total *= argument;
  }

  return total;
}

console.log(multiply(1, 2, 3)); //  6
console.log(multiply(1, 2, 3, 4)); //  24
console.log(multiply(1, 2, 3, 4, 5)); //  120





Преобразование псевдомассива
Обычно псевдомассив необходимо преобразовать в полноценный массив, так как у псевдомассива нет методов массива, например slice() или includes(). 
На практике применяют несколько основных способов.

1) Используя метод Array.from(), который создаст массив из псевдомассива.

function fn() {
  // В переменной args будет полноценный массив
  const args = Array.from(arguments);
}

2) Используя операцию ... (rest) - она позволяет собрать произвольное количество элементов, в нашем случае аргументов, в массив и сохранить его в переменную. 
Собираем все аргументы используя операцию rest прямо в подписи функции.

function fn(...args) {
  // В переменной args будет полноценный массив
}

или

3) Используя операцию ... (spread) - она позволяет распылить произвольное количество элементов, в нашем случае аргументов, в массив

function add() {
  const arr = [...arguments]    // В переменной arr будет полноценный массив
}
Операция rest более детально рассматривается дальше в курсе, здесь показано одно из ее возможных применений.





Паттерн «Ранний возврат»
Оператор if...else - это основной способ создания ветвлений. Тем не менее, сложные вложенные ветвления делают код запутанным для понимания.

Создадим функцию, которая обрабатывает снятие денег с личного счета в банке. Она получает сумму для снятия и текущий баланс счета, после чего, 
в зависимости от условия, выполняет тот или иной блок кода.

function withdraw(amount, balance) {
  if (amount === 0) {
    console.log("Для проведения операции введите сумму больше нуля");
  } else if (amount > balance) {
    console.log("Недостаточно средств на счету");
  } else {
    console.log("Операция снятия средств проведена успешно");
  }
}

withdraw(0, 300); // "Для проведения операции введите сумму больше нуля"
withdraw(500, 300); // "Недостаточно средств на счету"
withdraw(100, 300); // "Операция снятия средств проведена успешно"

Даже в таком простом примере есть группа вложенных условных операторов, среди которых не сразу можно выделить понять логику выполнения кода.

В функции может быть больше одного оператора return. Главное помнить, что выполнение функции прерывается когда интерпретатор встречает возврат, 
и весь код после него будет проигнорирован в текущем вызове функции.

Паттерн «Ранний возврат» - это способ использовать возможность досрочного возврата из функции с помощью оператора return. 
Используя этот приём мы получаем более чистый, плоский и понятный код, который легче рефакторить.

Выделим все проверки условий в отдельные операторы if, после чего добавим код, идущий в теле else. В идеальном случае, должен получиться плоский 
список условных операторов, идущих один за другим, а в конце блок, который выполнится только в том случае, если не выполнится ни один if.

function withdraw(amount, balance) {
  // Если  условие выполняется, вызывается console.log и выход из функции. Код идущий после тела if не выполнится.
  if (amount === 0) {
    console.log("Для проведения операции введите сумму больше нуля");
    return;
  }
  // Если условие первого if не выполнилось, его тело пропускается и интерпретатор доходит до второго if.
  // Если условие выполняется, вызывается console.log и выход из функции. Код идущий после тела if  не выполнится.
  if (amount > balance) {
    console.log("Недостаточно средств на счету");
    return;
  }
  // Если ни один из предыдущих if не выполнился, интерпретатор доходит до этого кода и выполняет его.
  console.log("Операция снятия средств проведена");
}

withdraw(0, 300); // "Для проведения операции введите сумму больше нуля"
withdraw(500, 300); // "Недостаточно средств на счету"
withdraw(100, 300); // "Операция снятия средств проведена"





Функциональное выражение
Функциональное выражение (function expression) - обычное объявление переменной, значение которой будет функция. Альтернативный способ объявления функции.

// Объявление функции (function declaration)
function multiply(x, y, z) {
  console.log(`Результат умножения равен ${x * y * z}`);
}

// Функциональное выражение (function expression)
const multiply = function (x, y, z) {
  console.log(`Результат умножения равен ${x * y * z}`);
};

Различие в том, что функциональное выражение нельзя вызвать до места его создания, только после, потому что это буквально объявление const переменной.

// ❌ Ошибка! Не работает вызов до объявления
multiply(1, 2, 3);

const multiply = function (x, y, z) {
  console.log(`Результат умножения равен ${x * y * z}`);
};

// ✅ Работает вызов после объявления
multiply(4, 5, 6);

A объявление функции можно вызвать до места её создания в коде.

// ✅ Работает вызов до объявления
multiply(1, 2, 3);

function multiply(x, y, z) {
  console.log(`Результат умножения равен ${x * y * z}`);
}

// ✅ Работает вызов после объявления
multiply(4, 5, 6);

ИНТЕРЕСНО
Не важно какой синтаксис использовать, главное чтобы код в проекте был однородным. То есть необходимо стараться не мешать объявления функции 
с функциональными выражениями.
*/

/**
  |============================
  | Стек вызовов
  |============================
*/
/* 
При вызове функции, внутри её тела могут вызываться другие функции, а в них другие и т. д. 
JavaScript однопоточный язык, то есть в одну единицу времени может выполняться только одна инструкция. 
Это значит, что уже вызванные функции, которые не закончили свое выполнение, должны ждать выполнения функций вызванных внутри себя, для того, 
чтобы продолжить свою работу.

function fnA() {
  console.log("Лог внуртри функции fnA до вызова fnB");
  fnB();
  console.log("Лог внуртри функции fnA после вызова fnB");
}

function fnB() {
  console.log("Лог внутри функции fnB");
}

console.log("Лог перед вызовом fnA");
fnA();
console.log("Лог после вызова fnA");

// "Лог перед вызовом fnA"
// "Лог внуртри функции fnA до вызова fnB"
// "Лог внутри функции fnB"
// "Лог внуртри функции fnA после вызова fnB"
// "Лог после вызова fnA"

Необходим механизм хранения списка функций, которые были вызваны, но еще не закончили свое выполнение и механизм управления порядком выполнения этих функций - 
и именно за это отвечает стек вызовов (call stack).

Стек
Стек - структура данных, которая работает по принципу LIFO (Last-In-First-Out), то есть последним пришёл - первым вышел. Последнее, что добавляется на стек, 
будет удалено из него первым, значит можно добавить или удалить элементы только из верхушки стека.

Представьте стек как массив у которого есть только методы pop и push, то есть можно добавить или удалить только элемент в конце коллекции.




Стек вызовов (call stack) - это механизм для отслеживания текущего местонахождения интерпретатора в коде, который вызывает несколько функций. 
Какая из функций выполняется на данный момент, какие функции вызываются изнутри выполняемой функции, какая будет вызвана следующей и т. д.

Когда скрипт вызывает функцию, интерпретатор добавляет её в стек вызовов и начинает выполнение.
Любые функции, вызванные выполняемой функцией, добавляются в стек вызовов и выполняются, как только происходит их вызов.
Когда выполнение функции завершено, интерпретатор снимает её со стека вызовов и возобновляет выполнение кода с той точки, где остановился до этого. 
То есть начинает выполняться функция, запись которой лежит следующей на стеке.

Stack frame (кадр стека, запись стека) - структура которая добавляется на стек при вызове функции. Хранит служебную информацию, например имя функции 
и номер строки, в которой произошел вызов.

function bar() {
  console.log("bar");
}

function baz() {
  console.log("baz");
}

function foo() {
  console.log("foo");
  bar();
  baz();
}

foo();

При выполнении этого кода сначала вызывается foo(), затем внутри foo() вызывается bar(), а затем baz(). Вызовы console.log() так же учитываются, ведь это функция. 




Переполнение стека вызовов
Стек вызовов не безграничный, ему отводится конечный объем памяти. Иногда в консоли можно увидеть ошибку "Uncaught RangeError: Maximum call stack size exceeded" - 
переполнение стека (stack overflow).

Это может произойти при неправильном использовании рекурсии или зацикливании вызовов функций, то есть, если идут бесконечные вызовы функций и результат 
не возвращается, то стек увеличивается. По достижению предела количества записей стека и возникнет такая ошибка и скрипт «падает».
*/

/**
  |============================
  | Объекты
  |============================
*/
/* 
Объекты позволяют описать и сгруппировать характеристики некоторой сущности - пользователя, книги, продукта в магазине, чего угодно. 
Объекты ещё называют словарями, то есть они содержат термины (свойства) и их определения (значения).

Создание объекта
Для объявления используются фигурные скобки {} - литерал объекта.

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  isPublic: true,
  rating: 8.38,
};

При создании объекту можно добавить свойства, каждое из которых описывается парами ключ:значение. Ключ ещё называют именем свойства и это всегда строка. 
Значением свойства могут быть любые типы: примитивы, массивы, объекты, були, функции и т. п. Свойства разделяются запятой.

Правила именования ключей просты:

Если ключ заключен в кавычки, то это может быть произвольная строка.
Если кавычек нет, то вступают ограничения - имя без пробелов, начинается на букву или символы _ и $.



Вложенные свойства
Значением свойства может быть другой объект, для того чтобы хранить вложенные и группированные данные. Например, статистика пользователя социальной сети 
состоит из количества последователей, просмотров и лайков, и хранить эти данные удобнее всего в виде объекта. Тоже самое с местоположением, отдельно страна и город.

const user = {
  name: "Jacques Gluke",
  tag: "jgluke",
  location: {
    country: "Jamaica",
    city: "Ocho Rios",
  },
  stats: {
    followers: 5603,
    views: 4827,
    likes: 1308,
  },
};

В будущем это можно будет использовать для поиска пользователей по стране, городу, минимальному или максимальному количеству последователей и т. д.



Обращение к свойствам через точку
Первый способ получить доступ к свойству объекта это синтаксис обьект.имя_свойства. 
Синтаксис «через точку» используется в большинстве случаев и подходит тогда, когда мы заранее знаем имя (ключ) свойства к которому хотим получить доступ.

На место обращения будет возвращено значение свойства с таким именем.
Если в объекте нет свойства с таким именем, на место обращения вернётся undefined.
const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  isPublic: true,
  rating: 8.38,
};

const bookTitle = book.title;
console.log(bookTitle); // 'The Last Kingdom'

const bookGenres = book.genres;
console.log(bookGenres); // ['historical prose', 'adventurs']

const bookPrice = book.price;
console.log(bookPrice); // undefined




Обращение к вложенным свойствам
Для доступа к вложенным свойствам используется цепочка обращейний «через точку». 
Например, если необходимо получить значение страны пользователя, записываем user.location.country, где user.location это обращение (путь) к объекту 
в свойстве location, а user.locaton.country обращение к свойству country в этом объекте. То есть «точка» указывает следующую вложенность.

const user = {
  name: "Jacques Gluke",
  tag: "jgluke",
  location: {
    country: "Jamaica",
    city: "Ocho Rios",
  },
  hobbies: ["swiming", "music", "sci-fi"],
};

const location = user.location;
console.log(location); // Объект location

const country = user.location.country;
console.log(country); // 'Jamaica'

Если значение свойства это массив, то в нашем примере user.hobbies обращение к этому массиву. 
Далее можно получить доступ к его элементам через квадратные скобки и индекс или использовать свойства и методы.

const hobbies = user.hobbies;
console.log(hobbies); // ['swiming', 'music', 'sci-fi']

const firstHobby = user.hobbies[0];
console.log(firstHobby); // 'swiming'

const numberOfHobbies = user.hobbies.length;
console.log(numberOfHobbies); // 3





Обращение к свойствам через квадратные скобки
Второй способ получить доступ к свойству объекта это синтаксис обьект["имя свойства"]. Похоже на обращение к элементу массива с отличием в том, 
что в скобках указывается не индекс элемента, а имя свойства как строка.

Синтаксис «квадратных скобок» используется значительно реже, в случае когда имя свойства заранее неизвестно или хранится в переменной, например 
как значение параметра функции.

На место обращения будет возвращено значение свойства с таким именем.
Если в объекте нет свойства с таким именем, на место обращения вернётся undefined.
const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  isPublic: true,
  rating: 8.38,
};

const bookTitle = book["title"];
console.log(bookTitle); // 'The Last Kingdom'

const bookGenres = book["genres"];
console.log(bookGenres); // ['historical prose', 'adventurs']

const propKey = "author";
const bookAuthor = book[propKey];
console.log(bookAuthor); // 'Bernard Cornwell'




Изменение значения свойства
После того как объект создан, значение его свойств можно изменить. Для этого необходимо обратиться к ним по имени, например «через точку», и присвоить новое значение.

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  isPublic: true,
  rating: 8.38,
};

book.rating = 9;
book.isPublic = false;
book.genres.push("драма");

console.log(book.rating); // 9
console.log(book.isPublic); // false
console.log(book.genres); // ['historical prose', 'adventures', 'драма']




Добавление свойств
Операция добавления нового свойства после создания объекта ничем не отличается от изменения значения уже существующего свойства. 
Если при записи значения по имени, такого свойства в объекте нет, оно будет создано.

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  isPublic: true,
  rating: 8.38,
};

book.pageCount = 836;
book.originalLanguage = "en";
book.translations = ["ua", "ru"];

console.log(book.pageCount); // 836
console.log(book.originalLanguage); // 'en'
console.log(book.translations); // ['ua', 'ru']





Короткие свойства
Иногда при создании объекта значение свойства необходимо взять из переменной или параметра функции с таким же именем как и само свойство.

Синтксис в следующем примере слишком громоздкий, потому что приходится дублировать имя свойства и имя переменной в которой хранится необходимое значение.

const name = "Генри Сибола";
const age = 25;

const user = {
  name: name,
  age: age,
};

console.log(user.name); // "Генри Сибола"
console.log(user.age); // 25

Синтаксис коротких свойств (shorthand properties) решает эту проблему, позволяя использовать имя переменной как имя свойства, а её значение как значение свойства.

const name = "Генри Сибола";
const age = 25;

const user = {
  name,
  age,
};

console.log(user.name); // "Генри Сибола"
console.log(user.age); // 25

То есть при объявлении объекта достаточно указать только имя свойства, а значение будет взято из переменной с аналогичным именем.





Вычисляемые свойства
Бывают ситуации когда при объявлении обьекта необходимо добавить свойство с именем которое мы заранее не знаем, потому что оно хранится как значение 
переменной или как результат выполнения функции.

Раньше для этого необходимо было сначала создать объект, а потом добавлять свойства через квадратные скобки, что не совсем удобно.

const propName = "name";
const user = {
  age: 25,
};

user[propName] = "Генри Сибола";
console.log(user.name); // 'Генри Сибола'

Синтаксис вычисляемых свойств (computed properties) помогает избежать лишнего кода и в некоторых случаях упростить его. 
Значением вычисляемого свойства может быть любое валидное выражение.

const propName = "name";
const user = {
  age: 25,
  // Имя этого свойства будет взято из значения переменной propName
  [propName]: "Генри Сибола",
};

console.log(user.name); // 'Генри Сибола'




Методы объекта
До сих пор мы рассматривали объекты только как хранилища взаимосвязанных данных, например информация о книге и т. п. 
Объекты-хранилища обычно находятся в массиве таких же объектов, который представляет коллекцию однотипных элементов.

Объекты могут хранить не только данные, но и функции для работы с этими данными - методы. 
Если значение свойства это функция, такое свойство называется методом объекта.

// ✅ Логически и синтаксически сгруппированные сущности
const bookShelf = {
  books: ["The Last Kingdom", "Dream Guardian"],
  // Это метод объекта
  getBooks() {
    console.log("Этот метод будет возвращать все книги - свойство books");
  },
  // Это метод объекта
  addBook(bookName) {
    console.log("Этот метод будет добавлять новую книгу в свойство books");
  },
};

// Вызовы методов
bookShelf.getBooks();
bookShelf.addBook("Новая книга");

Такие объекты можно назвать «моделями». Они связывают данные и методы для работы с этими данными. 
Например, можно было объявить переменную books и две функции getBooks() и addBook(bookName), но тогда это были бы три независимые сущности 
без явной синтаксической, и со слабой логической связью.

// ❌ Слабосвязанные, независмые сущности
const books = [];
function getBooks() {}
function addBook() {}




Доступ к свойствам объекта в методах
Методы используются для работы со свойствами объекта, их изменения. 
Для доступа к объекту в методе используется не имя переменной, например bookShelf, а ключевое слово this - контекст. Значением this будет объект перед «точкой», то есть объект который вызвал этот метод, в нашем случае это ссылка на объект bookShelf.

const bookShelf = {
  books: ["The Last Kingdom"],
  getBooks() {
    console.log(this);
  },
};

// Перед точкой стоит объект bookShelf,
// поэтому при вызове метода, this будет хранить ссылку на него.
bookShelf.getBooks(); // {books: ['The Last Kingdom'], getBooks: f}

Для того чтобы получить доступ к свойствам объекта в методах, мы обращаемся к нему через this и дальше как обычно - «через точку» к свойствам.

const bookShelf = {
  books: ["The Last Kingdom"],
  getBooks() {
    return this.books;
  },
  addBook(bookName) {
    this.books.push(bookName);
  },
  removeBook(bookName) {
    const bookIndex = this.books.indexOf(bookName);
    this.books.splice(bookIndex, 1);
  },
};

console.log(bookShelf.getBooks()); // ["The Last Kingdom"]
bookShelf.addBook("The Mist");
bookShelf.addBook("Dream Guardian");
console.log(bookShelf.getBooks()); // ['The Last Kingdom', 'The Mist', 'Dream Guardian']
bookShelf.removeBook("The Mist");
console.log(bookShelf.getBooks()); // ['The Last Kingdom', 'Dream Guardian']

Будет логично задуматься - почему бы не использовать при обращении к свойствам имя объекта, ведь мы явно не собираемся его менять. 
Дело в том, что имя объекта штука ненадежная, методы одного объекта можно копировать в другой (с другим именем), а в будущем узнаем что часто 
при создании объекта мы заранее вовсе не знаем имени. Использование this гарантирует, что метод работает именно с тем объектом, который его вызвал.

*/
/**
  |============================
  | Ccылки на методы с this
  |============================
*/
/*
Если свойством объекта является метод, использующий this, на него можно делать ссылку в других объектах. При этом конструкция метода this будет использовать 
уже новый объект в качестве истоника.
*/

/**
  |============================
  | Удаление свойств объекта - delete obj.valueKey;
  |============================
*/
/* 
delete obj.firstValueKey;
delete obj.secondValueKey;
*/

/**
  |============================
  | Перебор объекта
  |============================
*/
/* 
В отличии от массива или строки, объект это не итерируемая сущность, то есть его нельзя перебрать циклами for или for...of.




Цикл for...in
Для перебора объектов используется специальный цикл for...in, который перебирает ключи объекта object.

for (key in object) {
  // инструкции
}

Переменная key доступная только в теле цикла. На каждой итерации в неё будет записано значение ключа (имя) свойства. 
Для того чтобы получить значение свойства с таким ключом (именем), используется синтаксис квадратных скобок.

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  rating: 8.38,
};

for (const key in book) {
  // Ключ
  console.log(key);
  // Значение свойства с таким ключом
  console.log(book[key]);
}



Метод hasOwnProperty()
Разберём концепцию собственных и несобственных свойств объекта и научимся правильно использовать цикл for...in.

const animal = {
  legs: 4,
};
const dog = Object.create(animal);
dog.name = "Манго";

console.log(dog); // {name: 'Манго'}
console.log(dog.name); // 'Манго'
console.log(dog.legs); // 4

Метод Object.create(animal) создаёт и возвращает новый объект, связывая его с объектом animal. 
Поэтому можно получить значение свойства legs обратившись к нему как dog.legs, хотя его нет в объекте dog - это несобственное свойство из объекта animal.

Оператор in, который используется в цикле for...in, не делает различия между собственными и несобственными свойствами объекта. 
Эта особенность мешает, так как мы всегда хотим перебрать только собственные свойства. Для того чтобы узнать есть в объекте собственное свойство или нет, 
используется метод hasOwnProperty(key), который возвращает true или false.

// ❌ Возвращает true для всех свойств
console.log("name" in dog); // true
console.log("legs" in dog); // true

// ✅ Возвращает true только для собственных свойств
console.log(dog.hasOwnProperty("name")); // true
console.log(dog.hasOwnProperty("legs")); // false

Поэтому при переборе циклом for...in необходимо на каждой итерации добавить проверку на собственное свойство. 
Даже если сейчас мы уверены в том что у объекта нет несобственных свойств, это оградит от возможных ошибок в будущем.

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  rating: 8.38,
};

for (const key in book) {
  // Если это собственное свойство - выполняем тело if
  if (book.hasOwnProperty(key)) {
    console.log(key);
    console.log(book[key]);
  }

  // Если это не собственное свойство - ничего не делаем
}




Метод Object.keys()
У встроенного класса Object есть несколько полезных методов для работы с объектами. 
Первый из них это Object.keys(obj), который принимает объект и возвращает массив ключей его собственных свойств. 
Если в объекте нет свойств, метод вернёт пустой массив.

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  rating: 8.38,
};
const keys = Object.keys(book);
console.log(keys); // ['title', 'author', 'genres', 'rating']

Скомбинировав результат Object.keys() и цикл for...of можно удобно перебрать собственные свойства объекта, не прибегая к использованию архаического цикла for...in 
с проверками принадлежности свойств.

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  rating: 8.38,
};
const keys = Object.keys(book);

for (const key of keys) {
  // Ключ
  console.log(key);
  // Значение свойства
  console.log(book[key]);
}

Мы перебираем массив ключей объекта и на каждой итерации получаем значение свойства с таким ключом.





Метод Object.values()
Если метод Object.keys(obj) возвращает массив ключей собственных свойств обьекта, то метод Object.values(obj) возвращает массив значений его собственных свойств. 
Если в объекте нет свойств, метод Object.values(obj) вернёт пустой массив.

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  rating: 8.38,
};
const keys = Object.keys(book);
console.log(keys); // ['title', 'author', 'rating']

const values = Object.values(book);
console.log(values); // ['The Last Kingdom', 'Bernard Cornwell', 8.38]

Массив значений свойств также можно перебрать циклом for...of, например для получения общей суммы числовых значений.

Допустим перед нами стоит задача посчитать общее количество продуктов в объекте формата имя-продукта: количество. Тогда подойдет метод Object.values() для того, 
чтобы получить массив всех значений и потом удобно их сложить.

const goods = {
  apples: 6,
  grapes: 3,
  bread: 4,
  cheese: 7,
};

const values = Object.values(goods); // [6, 3, 4, 7]

let total = 0;

for (const value of values) {
  total += value;
}

console.log(total); // 20




Метод Object.entries()
Метод Object.entries(obj) возвращает массив записей, каждым элементом которого будет еще один массив из 2-х элементов: имени свойства и значения этого свойства 
из объекта obj.

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  rating: 8.38,
};
const keys = Object.keys(book);
console.log(keys); // ['title', 'author', 'rating']

const values = Object.values(book);
console.log(values); // ['The Last Kingdom', 'Bernard Cornwell', 8.38]

const entries = Object.entries(book);
console.log(entries);
// [["title", "The Last Kingdom"], ["author", "Bernard Cornwell"], ["rating", 8.38]]

ИНТЕРЕСНО
На практике метод Object.entries(obj) используется редко, только для каких-то очень специфичных задач. 
В 99% случаев будет использован метод Object.keys() или Object.values().
*/

/**
  |============================
  | Массив обьектов
  |============================
*/
/* 
В стандартный набор повседневных задач разработчика входит манипуляция массивом однотипных объектов. 
Это значит что все объекты в массиве гарантированно будут иметь одинаковый набор свойств, но с разными значениями.

const books = [
  {
    title: "The Last Kingdom",
    author: "Bernard Cornwell",
    rating: 8.38,
  },
  {
    title: "На берегу спокойных вод",
    author: "Роберт Шекли",
    rating: 8.51,
  },
  {
    title: "Сон смешного человека",
    author: "Федор Достоевский",
    rating: 7.75,
  },
];

Для перебора такого массива используется стандартный цикл for...of. 
Значения свойств каждого объекта можно получить используя синтаксис «через точку», так как в каждом объекте набор свойств и их имена будут одинаковые, 
отличаются только значения.

for (const book of books) {
  // Объект книги
  console.log(book);
  // Название
  console.log(book.title);
  // Автор
  console.log(book.author);
  // Рейтинг
  console.log(book.rating);
}

Например, получим список названий всех книг в коллекции books.

const bookNames = [];

for (const book of books) {
  bookNames.push(book.title);
}

console.log(bookNames); // ["The Last Kingdom", "На берегу спокойных вод", "Сон смешного человека"]

Узнаем средний рейтинг всей нашей коллекции. Для этого сложим все рейтинги, после чего разделим это значение на количество книг в коллекции.

let totalRating = 0;

for (const book of books) {
  totalRating += book.rating;
}

const averageRating = (totalRating / books.length).toFixed(1);
console.log(averageRating); // 8.2
*/

/**
  |============================
  | Синтаксис spread и rest
  |============================
*/
/* 
В современном стандарте появился новый синтаксис для работы с итерируемыми сущностями, такими как строка, массив или объект. 
Его функционал и название зависит от места применения.



spread: передача аргументов
Операция ... (spread) позволяет распылить коллекцию элементов (массив, строку или объект) в место, где ожидается набор отдельных значений. 
Конечно есть некоторые ограничения, например нельзя распылить массив в объект и наоборот.

Можно привести аналогию с ящиком яблок. Поставив ящик на пол не вынимая из него яблоки, получим аналог массива значений. 
Если высыпать яблоки из ящика на пол, произойдёт распыление - набор отдельных значений.

Отличие всего одно - в JavaScript распыление не изменяет оригинальную коллекцию, то есть делается копия каждого элемента. 
После распыления останется и ящик полный яблок, и копия каждого яблока на полу.

Например, метод Math.max(аргументы) ищет и возвращает самый большой из аргументов (чисел), то есть ожидает не массив значений, а произвольное количество аргументов.

const temps = [14, -4, 25, 8, 11];

// В консоли будет массив
console.log(temps);
// ❌ Так не сработает, потому что передаём целый массив
console.log(Math.max(temps)); // NaN

// В консоли будет набор отдельных чисел
console.log(...temps);
// ✅ Распылим коллекцию элементов как отдельные аргументы
console.log(Math.max(...temps)); // 25

То есть запись Math.max(...[14, -4, 25, 8, 11]), после интерпретации превращается в Math.max(14, -4, 25, 8, 11) - синтаксис ... возвращает распакованный массив, 
то есть распыляет его элементы как отдельные аргументы.




spread: создание нового массива
Операция ... (spread) позволяет создать копию массива или «склеить» произвольное количество массивов в один новый. 
Раньше для этого использовали методы slice() и concat(), но операция распыления позволяет сделать тоже самое в более краткой форме.

const temps = [14, -4, 25, 8, 11];

// Это точная, но независимая копия массива temps
const copyOfTemps = [...temps];
console.log(copyOfTemps); // [14, -4, 25, 8, 11]

В примере выше у нас есть ящик яблок temps и мы хотим сделать его точную копию. Берём пустой ящик и пересыпаем в него яблоки из исходного ящика temps - распыляем 
его в другую коллекцию. При этом ящик temps не изменится, в нём все ещё будут яблоки, а в новом ящике - их точные копии.

В следующем примере мы ссыпаем яблоки из двух ящиков в один новый. Оригинальные ящики (массивы) не изменятся, а в новом будут копии всех их яблок (элементов). 
Порядок распыления важен - он влияет на порядок элементов в новой коллекции.

const lastWeekTemps = [14, 25, 11];
const currentWeekTemps = [23, 17, 18];
const allTemps = [...lastWeekTemps, ...currentWeekTemps];
console.log(allTemps); // [14, 25, 11, 23, 17, 18]




spread: создание нового объекта
Операция ... (spread) позволяет распылить свойства произвольного количества объектов в один новый.

const first = { propA: 5, propB: 10 };
const second = { propC: 15 };
const third = { ...first, ...second };
console.log(third); // { propA: 5, propB: 10, propC: 15 }

Порядок распыления имеет значение. Имена свойств объекта уникальные, поэтому свойства распыляемого объекта могут перезаписать значение уже существующего свойства, 
если их имена совпадают.

const first = { propA: 5, propB: 10, propC: 50 };
const second = { propC: 15, propD: 20 };

const third = { ...first, ...second };
console.log(third); // { propA: 5, propB: 10, propC: 15, propD: 20 }

const fourth = { ...second, ...first };
console.log(fourth); // { propA: 5, propB: 10, propC: 50, propD: 20 }

Если бы яблоки в ящике имели наклейки с метками, то в одном ящике не может быть двух яблок с одинаковыми метками. 
Поэтому при пересыпании второго ящика, все яблоки, метки которых совпадут с теми что уже есть в новом, заменят те что уже есть.

Во время распыления можно добавлять свойства в произвольное место. Главное помнить про уникальность имени свойства и о том, что его значение может быть перезаписано.

const first = { propA: 5, propB: 10, propC: 50 };
const second = { propC: 15 };

const third = { propB: 20, ...first, ...second };
console.log(third); // { propA: 5, propB: 10, propC: 15 }

const fourth = { ...first, ...second, propB: 20 };
console.log(fourth); // { propA: 5, propB: 20, propC: 15 }

const fifth = { ...first, propB: 20, ...second };
console.log(fifth); // { propA: 5, propB: 20, propC: 15 }






rest: сбор всех аргументов функции
Операция ... (rest) позволяет собрать группу независимых элементов в новую коллекцию. 
Синтаксически это близнец операции распыления, но отличить их просто - распыление это когда ... находится в правой части операции присваивания, 
а сбор это когда ... находится в её левой части.

Вернёмся к аналогии с яблоками. Если на полу лежат яблоки и у нас есть пустой ящик, то операция rest позволит «собрать» яблоки в ящик. 
При этом оригинальные яблоки останутся на полу, а в ящике будет копия каждого яблока.

Одна из областей применения операции rest это создание функций которые могут принимать произвольное количество аргументов.

// Как объявить параметры функции так,
// чтобы можно было передать любое кол-во аргументов?
function multiply() {
  // ...
}

multiply(1, 2);
multiply(1, 2, 3);
multiply(1, 2, 3, 4);

Если убрать весь «синтаксический шум» и посмотреть на аргументы и параметры функции, то аргументы находятся в правой части операции присваивания, 
а параметры в левой, потому что значения аргументов присваиваются объявленным параметрам. Значит можно «собрать» все аргументы функции в один 
параметр используя операцию rest.

function multiply(...args) {
  console.log(args); // массив всех аргументов
}

multiply(1, 2);
multiply(1, 2, 3);
multiply(1, 2, 3, 4);

Имя параметра может быть произвольным. Чаще всего его называют args, restArgs или otherArgs, сокращённое от arguments.





rest: сбор части аргументов функции
Операция ... (rest) также позволяет собрать в массив только ту часть аргументов, которая необходима, объявив параметры до «сбора».

function multiply(firstNumber, secondNumber, ...otherArgs) {
  console.log(firstNumber); // Значение первого аргумента
  console.log(secondNumber); // Значение второго аргумента
  console.log(otherArgs); // Массив остальных аргументов
}

multiply(1, 2);
multiply(1, 2, 3);
multiply(1, 2, 3, 4);

Все агументы, для которых будут объявлены параметры, передадут им свои значения, остальные аргументы будут помещены в массив. 
Операция rest собирает все оставшиеся аргументы и поэтому должна идти последней в подписи функции, иначе будет ошибка.
*/

/**
  |============================
  | Деструктуризация объектов
  |============================
*/
/* 
При разработке программ данные приходят, как правило, в виде массивов и объектов, значения которых необходимо записать в локальные переменные. 
Для того, чтобы делать это максимально просто, в современном стандарте есть синтаксис деструктуризирующего присваивания.



Деструктуризация объектов
Сложные данные всегда представлены объектом. Множественные обращения к свойствам объекта визуально загрязняют код.

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  isPublic: true,
  rating: 8.38,
};

const accessType = book.isPublic ? "публичном" : "закрытом";
const message = `Книга ${book.title} автора ${book.author} с рейтингом ${book.rating} находится в ${accessType} доступе.`;


Деструктуризация позволяет «распаковать» значения свойств объекта в локальные переменные. Это делает код в месте их использования менее «шумным».

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  isPublic: true,
  rating: 8.38,
};

// Деструктуризируем
const { title, author, isPublic, rating, coverImage } = book;
console.log(coverImage); // undefined

const accessType = isPublic ? "публичном" : "закрытом";
const message = `Книга ${title} автора ${author} с рейтингом ${rating} находится в ${accessType} доступе.`;

Деструктуризация всегда находится в левой части операции присвоения. Переменным внутри фигурных скобок присваиваются значения свойств объекта. 
Если имя переменной и имя свойства совпадают, то происходит присваивание, в противном случае ей будет присвоено undefined. 
Порядок объявления переменных в фигурных скобках не важен.




Значения по умолчанию
Для того чтобы избежать присвоения undefined при деструктуризации несуществующих свойств объекта, можно задать переменным значения по умолчанию, 
которые будут присвоены только в случае когда в объекте нет свойства с таким именем.

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
};

// Добавим картинку обложки если её нет в объекте книги
const {
  title,
  coverImage = "https://via.placeholder.com/640/480",
  author,
} = book;

console.log(title); // The Last Kingdom
console.log(author); // Bernard Cornwell
console.log(coverImage); // https://via.placeholder.com/640/480




Изменение имени переменной
При деструктуризации можно изменить имя переменной в которую распаковывается значение свойства. 
Сначала пишем имя свойства из которого хотим получить значение, после чего ставим двоеточие и пишем имя переменной в которую необходимо поместить значение 
этого свойства.

const firstBook = {
  title: "The Last Kingdom",
  coverImage:
    "https://images-na.ssl-images-amazon.com/images/I/51b5YG6Y1rL.jpg",
};

const {
  title: firstTitle,
  coverImage: firstCoverImage = "https://via.placeholder.com/640/480",
} = firstBook;

console.log(firstTitle); // The Last Kingdom
console.log(firstCoverImage); // https://images-na.ssl-images-amazon.com/images/I/51b5YG6Y1rL.jpg

Такая запись читается как «Создать переменную firstTitle, в которую поместить значение свойства title из объекта firstBook» и т. д.




Деструктуризация в циклах
При переборе массива объектов циклом for...of получаеются множественные обращения к свойствам объекта.

const books = [
  {
    title: "The Last Kingdom",
    author: "Bernard Cornwell",
    rating: 8.38,
  },
  {
    title: "На берегу спокойных вод",
    author: "Роберт Шекли",
    rating: 8.51,
  },
];

for (const book of books) {
  console.log(book.title);
  console.log(book.author);
  console.log(book.rating);
}

Для того чтобы сократить количество повторений можно деструктуризировать свойства объекта в локальные переменные в теле цикла.

for (const book of books) {
  const { title, author, rating } = book;

  console.log(title);
  console.log(author);
  console.log(rating);
}

Если в объекте немного свойств, деструктуризацию можно выполнить прямо в месте объявления переменной book.

for (const { title, author, rating } of books) {
  console.log(title);
  console.log(author);
  console.log(rating);
}




Глубокая деструктуризация
Для деструктуризации свойств вложенных объектов используются те же принципы, что и в трёх предыдущих упражнениях.

const user = {
  name: "Jacques Gluke",
  tag: "jgluke",
  stats: {
    followers: 5603,
    views: 4827,
    likes: 1308,
  },
};

const {
  name,
  tag,
  stats: { followers, views: userViews, likes: userLikes = 0 },
} = user;

console.log(name); // Jacques Gluke
console.log(tag); // jgluke
console.log(followers); // 5603
console.log(userViews); // 4827
console.log(userLikes); // 1308
*/

/**
  |============================
  | Деструктуризация с rest ...
  |============================
*/
/* 
Если деструктуризация осуществляется из объекта - получаем объект
function foo({name, age, ...props})     // props - объект


Если деструктуризация осуществляется из массива - получаем массив
function foo([name, age, ...props])     // props - массив
*/

/**
  |============================
  | Деструктуризация массивов
  |============================
*/
/* 
Деструктуризирующее присваивание можно использовать и для массивов, но с некоторыми особенностями.

Вместо фигурных скобок {} используются квадратные [].
Переменным, указанным в квадратных скобках [], будут последовательно присваиваться значения элементов массива.
Например, есть массив цветов из которого нужно в отдельные переменные получить значения каждой составляющей цвета.

const rgb = [200, 255, 100];
const [red, green, blue] = rgb;

console.log(`R:${red},G:${green},B:${blue}`); // "R:200,G:255,B:100"

После ключевого слова const или let ставим открывающую и закрывающую квадратные скобки, как при объявлении массива. 
Внутри скобок, через запятую, указываем имена переменных, в которые будут помещены значения массива.

В результате такой записи будут созданы 3 переменные и в них будут помещены элементы в нумерованном порядке - от 0 и до конца массива.

При деструктуризации массивов, значение переменной может быть присвоено после ее объявления. На практике это используется редко.

const rgb = [200, 255, 100];
let red, green, blue;

[red, green, blue] = rgb;

console.log(`R:${red},G:${green},B:${blue}`); // "R:200,G:255,B:100"

Если переменных больше чем элементов массива, им будет присвоено undefined, поэтому можно указывать значения по умолчанию.

const rgb = [200, 100, 255];

const [red, green, blue, alfa = 0.3] = rgb;

console.log(`R:${red},G:${green},B:${blue},Alfa:${alfa}`); // "R:200,G:100,B:255,Alfa:0.3"

Иногда из массива необходимо деструктуризировать только первые N элементов, а остальные сохранить в одну переменную в виде массива. 
При деструкции массива можно распаковать и присвоить оставшуюся часть элементов массива переменной, используя операцию ... (rest).

const rgb = [200, 255, 100];

const [red, ...colors] = rgb;

console.log(red); // "200"
console.log(colors); // [255, 100]

Элементы можно пропускать. Допустим, из массива rgb необходимо взять только последнее значение. 
На практике эта возможность используется редко.

const rgb = [200, 100, 255];

const [, , blue] = rgb;

console.log(`Blue: ${blue}`); // "Blue: 255"
*/

/**
  |============================
  | Паттерн «Объект параметров»
  |============================
*/
/* 
Если функция принимает более двух-трёх аргументов, очень просто запутаться в какой последовательности что передавать. 
В результате получается очень неочевидный код в месте её вызова.

function doStuffWithBook(title, numberOfPages, downloads, rating, public) {
  // (код функии)
  console.log(title);
  console.log(numberOfPages);
  // И так далее
}

doStuffWithBook("The Last Kingdom", 736, 10283, 8.38, true);
// ❌ Что такое 736? Что такое 10283? Что такое true?


Паттерн «Объект параметров» помогает решить эту проблему, заменяя набор параметров всего одним - объектом с именованными свойствами.

function doStuffWithBook(book) {
  // (код функии)
  console.log(book.title);
  console.log(book.numberOfPages);
  // И так далее
}

Тогда во время её вызова передаём один объект с необходимыми свойствами.

// ✅ Всё понятно
doStuffWithBook({
  title: "The Last Kingdom",
  numberOfPages: 736,
  downloads: 10283,
  rating: 8.38,
  isPublic: true,
});

Ещё один плюс в том, что можно деструктуризировать объект в параметре book. Это можно сделать в теле функции.

function doStuffWithBook(book) {
  const { title, numberOfPages, downloads, rating, isPublic } = book;
  console.log(title);
  console.log(numberOfPages);
  // И так далее
}

Или сразу в сигнатуре (подписи) функции, разницы нет.

function doStuffWithBook({
  title,
  numberOfPages,
  downloads,
  rating,
  isPublic,
}) {
  console.log(title);
  console.log(numberOfPages);
  // И так далее
}
*/

/**
  |============================
  | Object.freeze(obj), set, get
  |============================
*/
/* 
Object.freeze(obj) не допускает любые изменения объекта obj


Используется часто вместе с сеттерами и геттерами (set, get), которыми можно устанавливать правила для внесения изменений в объект.
set name(newName) {
  return
}
get name() {
  return this.name
}
*/

/**
  |============================
  | Оператор опциональной (безопасной) последовательности ?.
  |============================
*/

/* 
Оператор опциональной последовательности ?. позволяет получить значение свойства, находящегося на любом уровне вложенности в цепочке связанных между собой объектов, 
без необходимости проверять каждое из промежуточных свойств в ней на существование. ?. работает подобно оператору ., за исключением того, что не выбрасывает исключение,
если объект, к свойству или методу которого идёт обращение, равен null или undefined. В этих случаях он возвращает undefined.

Таким образом, мы получаем более короткий и понятный код при обращении к вложенным по цепочке свойствам объекта, когда есть вероятность, что какое-то из них отсутствует.

const countPlayers = Object.keys(obj)?.length;

const dogName = adventurer.dog?.name;
*/

/**
  |============================
  | Безопасная деструктуризация с использованием пустых значений по умолчанию = {}
  |============================
*/
/* 
При деструктуризации и глубокой деструктуризации объектов, которые используются как аргументы, вероятна работа с объектом, не имеющим всех деструктуризируемых свойств.
В этом случае будет осуществояться деструктуризация их undefined свойств, что приведет к ошибке. 
Поэтому рекомендуется задавать значения по умолчанию для таких свойств и объектов, например, - = {} - пустой объект. В таком случае при деструктуризаии 
из таких свойств и объектов будем получать не ошибку, а значения переменных undefined.

function displayProductInfo({name, price, category, details: {brand, color, weight} = {},} = {}) {
  console.log(name);
}
*/

/**
  |============================
  | Колбэк-функции
  |============================
*/
/* 
Функции не отличаются от чисел, строк или массивов - это просто специальный тип данных (объект высшего порядка), значение, которое можно хранить в переменной 
или передавать как аргумент в другую функцию.

function greet(name) {
  return `Добро пожаловать ${name}.`;
}

// Вызываем функцию greet и выводим результат в консоль
console.log(greet("Манго")); // Добро пожаловать Манго.

// Выводим функцию greet в консоль не вызывая её
console.log(greet); // ƒ greet() { return `Добро пожаловать ${name}.`; }

В первом логе мы вызываем функцию greet при помощи круглых скобок и в консоль выводится результат её выполнения. 
Во втором логе передаётся ссылка на функцию, а не результат вызова (отсуствуют круглые скобки), поэтому в консоль выводится её тело. 
Это значит, что функцию можно присвоить в переменную или передать как аргумент другой функции.

Функция обратного вызова (callback, колбэк) - это функция, которая передаётся другой функции в качестве аргумента и та, в свою очередь, вызывает переданную функцию.

Функция высшего порядка(higher order function) - функция, принимающая в качестве параметров другие функции или возвращающая функцию как результат.

// Колбэк-функция
function greet(name) {
  console.log(`Добро пожаловать ${name}.`);
}

// Функция высшего порядка
function registerGuest(name, callback) {
  console.log(`Регистрируем гостя ${name}.`);
  callback(name);
}

registerGuest("Манго", greet);

Мы передали ссылку на функцию greet как аргумент, поэтому она будет присвоена в параметр callback и вызвана внури функции registerGuest через круглые скобки. 
Имя параметра для колбэка может быть произвольным, главное помнить, что значением будет функция.




Инлайн колбэки
Если колбэк-функция маленькая и нужна только для передачи аргументом, её можно объявить прямо при вызове функции в которую передаём колбэк. 
Такая функция будет доступна только как значение параметра и больше нигде в коде.

function registerGuest(name, callback) {
  console.log(`Регистрируем гостя ${name}.`);
  callback(name);
}

// Передаём инлайн функцию greet как колбэк
registerGuest("Манго", function greet(name) {
  console.log(`Добро пожаловать ${name}.`);
});

// Передаём инлайн функцию notify как колбэк
registerGuest("Поли", function notify(name) {
  console.log(`Уважаемый(ая) ${name}, ваш номер будет готов через 30 минут.`);
});




Несколько колбэков
Функция может принимать произвольное количество колбэков. Например, представим что мы пишем логику принятия звонков для телефона. 
Программа должна включить автоответчик если абонент недоступен, или соединить звонок в противном случае. 
Доступность абонента будем имитировать генератором случайного числа, чтобы между разными вызовами функции можно было получить различные результаты.

function processCall(recipient) {
  // Имитируем доступность абонента случайным числом
  const isRecipientAvailable = Math.random() > 0.5;

  if (!isRecipientAvailable) {
    console.log(`Абонент ${recipient} недоступен, оставьте сообщение.`);
    // Логика активации автоответчика
  } else {
    console.log(`Соединяем с ${recipient}, ожидайте...`);
    // Логика принятия звонка
  }
}

processCall("Манго");

Проблема такого подхода в том, что функция processCall делает слишком много и привязывает проверку доступности абонента к двум заранее определённым действиям. 
Что если в будущем вместо автоответчика нужно будет оставлять голограмму?

Мы могли бы написать функцию так, чтобы она возвращала какое-то значение и потом по результату её выполнения делать проверки и выполнять нужный код. 
Но проверки не относятся к внешнему коду и будут его засорять.

Выполним рефакторинг функции так, чтобы она принимала два колбэка onAvailable и onNotAvailable, и вызывала их по условию.

function processCall(recipient, onAvailable, onNotAvailable) {
  // Имитируем доступность абонента случайным числом
  const isRecipientAvailable = Math.random() > 0.5;

  if (!isRecipientAvailable) {
    onNotAvailable(recipient);
    return;
  }

  onAvailable(recipient);
}

function takeCall(name) {
  console.log(`Соединяем с ${name}, ожидайте...`);
  // Логика принятия звонка
}

function activateAnsweringMachine(name) {
  console.log(`Абонент ${name} недоступен, оставьте сообщение.`);
  // Логика активации автоответчика
}

function leaveHoloMessage(name) {
  console.log(`Абонент ${name} недоступен, записываем голограмму.`);
  // Логика записи голограммы
}

processCall("Манго", takeCall, activateAnsweringMachine);
processCall("Поли", takeCall, leaveHoloMessage);

Колбэки применяются для обработки действий пользователя на странице, при обработке запросов на сервер, выполнения заранее неизвестных функций и т. п. 
В этом и заключается их суть - это функции предназначенные для отложенного выполнения.




Абстрагирование повторения
Абстракция - скрытие деталей реализации. Позволяет думать о задачах на более высоком (абстрактном) уровне. Функции это хороший способ построения абстракций.

Например, скрипт выполняет какое-то действие определенное количество раз. Для этого можно написать цикл for.

for (let i = 0; i < 10; i += 1) {
  console.log(i);
}

Можем ли мы абстрагировать «делать что-то N раз» как функцию? - да, напишем функцию, которая вызывает console.log() N раз.

function repeatLog(n) {
  for (let i = 0; i < n; i += 1) {
    console.log(i);
  }
}

repeatLog(5);

Но что, если мы хотим сделать что-то, кроме логирования чисел? Поскольку «делать что-то» можно представить как функцию, а функции - это просто значения, 
мы можем передать действие как аргумент.

function printValue(value) {
  console.log(value);
}

function prettyPrint(value) {
  console.log("Logging value: ", value);
}

function repeat(n, action) {
  for (let i = 0; i < n; i += 1) {
    action(i);
  }
}

// Передаем printValue как callback-функцию
repeat(3, printValue);
// 0
// 1
// 2

// Передаем prettyPrint как callback-функцию
repeat(3, prettyPrint);
// Logging value: 0
// Logging value: 1
// Logging value: 2
*/

/**
  |============================
  | Метод forEach
  |============================
*/
/* 
Перебирающий метод массива который используется как замена циклов for и for...of при работе с коллекцией данных.

массив.forEach(function callback(element, index, array) {
  // Тело коллбек-функции
});

Поэлементно перебирает массив.
Вызызвает коллбек-функцию для каждого элемента массива.
Ничего не возвращает.
Аргументы коллбек-функции это значение текущего элемента element, его индекс index и сам исходный массив array. 
Объявлять можно только те параметры которые нужны, чаще всего это элемент, главное не забывать про их порядок.

const numbers = [5, 10, 15, 20, 25];

// Классический for
for (let i = 0; i < numbers.length; i += 1) {
  console.log(`Индекс ${i}, значение ${numbers[i]}`);
}

// Перебирающий forEach
numbers.forEach(function (number, index) {
  console.log(`Индекс ${index}, значение ${number}`);
});

Единственным случаем, когда стоит использовать циклы for или for...of для перебора массива, это задачи с прерыванием выполнения цикла. 
Прервать выполнение метода forEach нельзя, он всегда перебирает массив до конца.

*/

/**
  |============================
  | Стрелочные функции
  |============================
*/
/* 
Стрелочные функции имеют сокращённый, более лаконичный синтаксис, что уменьшает объем кода, особенно когда функция маленькая или если она используется как коллбек.

Все стрелки создаются как функциональное выражение, и если функция не анонимна, то она должна быть присвоена переменной.

// Обычное объявление функции
function classicAdd(a, b, c) {
  return a + b + c;
}

// Тоже самое как стрелочная функция
const arrowAdd = (a, b, c) => {
  return a + b + c;
};

Ключевое слово function не используется, вместо этого сразу идёт объявление параметров, за которыми следует символ => и тело функции.

Если параметров несколько, то они перечисляются через запятую в круглых скобках, между знаками равно = и стрелкой =>.

const add = (a, b, c) => {
  return a + b + c;
};

Если параметр один, его объявление может быть без круглых скобок.

const add = a => {
  return a + 5;
};

Если параметров нет, то обязательно должны быть пустые круглые скобки.

const greet = () => {
  console.log("Привет!");
};

Если используем деструктуризацию, то обязательно должны быть  круглые скобки, даже если параметр всего один.
const greet = ({a}) => {
  return a + 5;
};



Неявный возврат
В стрелочной функции после символа => идёт её тело. Здесь может быть два варианта: с фигурными скобками и без них.

const add = (a, b, c) => {
  console.log(a, b, c);
  return a + b + c;
};

Если фигурные скобки есть, и функция должна возвращать какое-то значение, необходимо явно поставить return. Это называется явный возврат (explicit return). 
Такой синтаксис используется в том случае, если в теле функции нужно выполнить ещё какие-то инструкции кроме возврата значения.

const add = (a, b, c) => a + b + c;

Если фигурных скобок нет, то возвращается результат выражения стоящего после =>. Это называется неявный возврат (implicit return). 
В примере вернётся результат выражения сложения параметров a, b и c.

Синтаксис неявного возврата сильно сокращает «шум» объявления функции с телом и возвращаемым выражением, но подходит только в случае когда в теле функции 
не нужно выполнять никаких дополнительных инструкций кроме возврата значения.

// До
function classicAdd(a, b, c) {
  return a + b + c;
}

// После
const arrowAdd = (a, b, c) => a + b + c;




Псевдомассив arguments
У стрелочных функций нет локальной переменной arguments, содержащей все аргументы. Если необходимо собрать все аргументы в массив, используется операция rest.

const add = (...args) => {
  console.log(args);
};

add(1, 2, 3); // [1, 2, 3]






Стрелочные функции как коллбеки
Анонимные стрелочные функции отлично подходят как коллбеки для перебирающих методов массива из-за более краткого синтаксиса объявления, 
особенно если не нужно тело функции.

const numbers = [5, 10, 15, 20, 25];

// Объявление функции
numbers.forEach(function (number, index) {
  console.log(`Индекс ${index}, значение ${number}`);
});

// Анонимная стрелочная функция
numbers.forEach((number, index) => {
  console.log(`Индекс ${index}, значение ${number}`);
});

Стрелочную коллбек-функцию также можно объявлять отдельно и передавать на неё ссылку. 
Это стоит делать если одна функция используется в нескольих местах программы или если она громоздкая.

const numbers = [5, 10, 15, 20, 25];

const logMessage = (number, index) => {
  console.log(`Индекс ${index}, значение ${number}`);
};

numbers.forEach(logMessage);
*/

/**
  |============================
  | Разновидности кода
  |============================
*/
/* 
Императивное программирование
Описывает процесс вычисления в виде заданной последовательности инструкций, изменяющих состояние программы. Описание того, как что-то выполняется.
Императивный стиль программирования - это такой, который дает машине набор детальных инструкций для выполнения задачи. 
Например цикл for, который предоставляет точные указания для итерации по индексам массива.
Можно провести аналогию с рецептом приготовления блюда. Рецепт - это набор пошаговых инструкций для получения желаемого результата.


Декларативное программирование
Описывает то, что мы хотим получить в результате, а не как это сделать. Порядок выполнения и способ достижения не важен.
Когда мы пишем HTML-код, то декларативно, при помощи тегов и атрибутов, описываем то, что хотим получить в результате. 
Браузер читает этот код и сам выполняет все необходимые операции по созданию HTML-элементов и помещению их на страницу.
Можно провести аналогию с меню ресторана. Это декларативный набор возможных к заказу блюд, детали приготовления и подачи которых скрыты.
Декларативное описание задачи более наглядно и легче формулируется. Мы говорим, что хотим сделать, вызвав метод или функцию. 
Ее реализация, скорее всего использует императивный код, но он скрыт внутри и не усложняет понимание основного кода.



Императивный vs декларативный
Рассмотрим разницу подходов на примере базовой операции фильтрации коллекции. Напишем код перебора и фильтрации массива чисел по какому-то критерию.

// Императивный подход
const numbers = [1, 2, 3, 4, 5];
const filteredNumbers = [];

for (let i = 0; i < numbers.length; i += 1) {
  if (numbers[i] > 3) {
    filteredNumbers.push(numbers[i]);
  }
}

console.log(filteredNumbers); // [4, 5]


// Декларативный подход
const numbers = [1, 2, 3, 4, 5];
const filteredNumbers = numbers.filter(value => value > 3);
console.log(filteredNumbers); // [4, 5]

Метод filter() скрывает в себе логику перебора коллекции и вызывает callback-функцию, которую мы ему передаем для каждого элемента, 
возвращая массив элементов, подошедших под критерий.
*/

/**
  |============================
  | Чистые функции
  |============================
*/
/* 
Функция с побочными эффектами - это функция которая в процессе выполнения может изменять или использовать глобальные переменные, 
изменять значение аргументов ссылочного типа, выполнять операции ввода-вывода и т. п.

const dirtyMultiply = (array, value) => {
  for (let i = 0; i < array.length; i += 1) {
    array[i] = array[i] * value;
  }
};

const numbers = [1, 2, 3, 4, 5];
dirtyMultiply(numbers, 2);
// Произошла мутация исходных данных - массива numbers
console.log(numbers); // [2, 4, 6, 8, 10]

Функция dirtyMultiply(array, value) умножает каждый элемент массива array на число value. Она изменяет (мутирует) исходный массив по ссылке.



Чистая функция (pure function) - это функция результат которой зависит только от значений переданных аргументов. 
При одинаковых аргументах она всегда возвращает один и тот же результат и не имеет побочных эффектов, то есть не изменяет значения аргументов.

Напишем реализацию чистой функции умножения элементов массива, возвращающей новый массив, не изменяя исходный.

const pureMultiply = (array, value) => {
  const newArray = [];

  array.forEach(element => {
    newArray.push(element * value);
  });

  return newArray;
};

const numbers = [1, 2, 3, 4, 5];
const doubledNumbers = pureMultiply(numbers, 2);

// Не произошло мутации исходных данных
console.log(numbers); // [1, 2, 3, 4, 5]
// Функция вернула новый массив с изменёнными данными
console.log(doubledNumbers); // [2, 4, 6, 8, 10]
*/

/**
  |============================
  | Перебирающие методы массива
  |============================
*/
/* 
В JavaScript есть методы массивов пришедшие из функциональных языков. Большинство из них это чистые функции. 
Они создают новый массив, заполняют его, применяя к значению каждого элемента указанную коллбек-функцию, после чего возвращают этот новый массив.

Все перебирающие методы массивов имеют схожий синтаксис. Исходный массив array, вызов метода method и callback-функция callback в качестве аргумента метода.

array.method(callback[currentValue, index, array])

В большинстве методов, аргументами callback-функции являются значение элемента currentValue (первый параметр), позиция элемента index (второй параметр) 
и сам исходный массив array (третий параметр).

array.method((item, idx, arr) => {
  // логика которая будет применяться на каждой итерации
});

Все параметры, кроме значения элемента item, необязательны. Названия параметров могут быть любые, но есть неофициальные соглашения.

array.method(item => {
  // логика которая будет применяться на каждой итерации
});
*/

/**
  |============================
  | Метод map()
  |============================
*/
/* 
Метод map(callback) используется для трансформации массива. Он вызывает коллбек-функцию для каждого элемента исходного массива, а результат её работы записывает 
в новый массив, который и будет результатом выполнения метода.

массив.map((element, index, array) => {
  // Тело коллбек-функции
});

Поэлементно перебирает оригинальный массив.
Не изменяет оригинальный массив.
Результат работа коллбек-функции записывается в новый массив.
Возвращает новый массив такой же длины.
Его можно использовать для того, чтобы изменить каждый элемент массива. Оригинальный массив используется как эталон, на базе которого можно сделать другую коллекцию.

const planets = ["Земля", "Марс", "Венера", "Юпитер"];

const planetsInUpperCase = planets.map(planet => planet.toUpperCase());
console.log(planetsInUpperCase); // ['ЗЕМЛЯ', 'МАРС', 'ВЕНЕРА', 'ЮПИТЕР']

const planetsInLowerCase = planets.map(planet => planet.toLowerCase());
console.log(planetsInLowerCase); // ['земля', 'марс', 'венера', 'юпитер']

// Оригинальный массив не изменился
console.log(planets); // ['Земля', 'Марс', 'Венера', 'Юпитер']

Использование анонимных стрелочных функций с неявным возвратом сильно сокращает «шум» объявления коллбек-функции, делая код чище и проще для восприятия.

Массив объектов
Мы уже знаем что повседневная задача это манипуляция массивом объектов. Например, получить массив значений свойства из всех объектов. 
Есть массив студентов, а нужно получить отдельный массив их имён.

const students = [
  { name: "Манго", score: 83 },
  { name: "Поли", score: 59 },
  { name: "Аякс", score: 37 },
  { name: "Киви", score: 94 },
  { name: "Хьюстон", score: 64 },
];

const names = students.map(student => student.name);
console.log(names); // ['Манго', 'Поли', 'Аякс', 'Киви', 'Хьюстон']

Используя метод map() можно перебрать массив объектов, и в коллбек-функции вернуть значение свойства каждого из них.
*/

/**
  |============================
  | В чем разница между Map и ForEach?
  |============================
*/
/* 
forEach() —  выполняет указанную функцию для каждого элемента массива.
map()  — создаёт новый массив с результатом вызова указанной функции для каждого элемента массива.

Функция forEach() фактически ничего не возвращает (undefined). Она просто вызывает указанную функцию для каждого элемента вашего массива. 
Этот каллбек разрешает мутировать вызывающий массив.
В то времк как, map() вызовет указанную функцию для каждого элемента массива. Разница в том, что map() использует возвращаемые значения и фактически 
возвращает новый массив того же размера.

Функция map() выделяет память и сохраняет возвращаемые значения. 
forEach() же в свою очередь отбрасывает возвращаемые значения и всегда возвращает undefined . 
forEach() позволяет функции обратного вызова мутировать текущий массив. В то время как map() вместо этого вернет новый массив.
*/

/**
  |============================
  | Метод flatMap()
  |============================
*/
/* 
Метод flatMap(callback) аналогичен методу map(), но применяется в случаях когда результат это многомерный массив который необходимо «разгладить».

массив.flatMap((element, index, array) => {
  // Тело коллбек-функции
});

В массиве students хранится список студентов со списком предметов которые посещает студент в свойстве courses. Несколько студентов могут посещать один и тот же предмет. Необходимо составить список всех предметов которые посещает эта группа студентов, пока даже повторяющихся.

const students = [
  { name: "Манго", courses: ["математика", "физика"] },
  { name: "Поли", courses: ["информатика", "математика"] },
  { name: "Киви", courses: ["физика", "биология"] },
];

students.map(student => student.courses);
// [['математика', 'физика'], ['информатика', 'математика'], ['физика', 'биология']]

students.flatMap(student => student.courses);
// ['математика', 'физика', 'информатика', 'математика', 'физика', 'биология'];

Он вызывает коллбек-функцию для каждого элемента исходного массива, а результат её работы записывает в новый массив. 

Отличие от map() в том, что новый массив «разглаживается» на глубину равную единице (одна вложенность). Этот разглаженный массив и есть результат работы flatMap().
*/

/**
  |============================
  | Метод Flat(n)
  |============================
*/
/* 
Метод Flat(n) Разглаживает массив на заданную глубину - n

const arr1 = [0, 1, 2, [3, [4, [5]]]]
const result = arr`.flat(3)
console.log(result)        //    


Определяем глубину n с помощью рекурсивной функции
const arr = [0, 1, 2, [3, [4, [5]]]]
function findDepth(arr) {
  let depth = 0;
  for (const item of arr) {
    if (Array.isArray(item)) {
      depth += 1;
      depth += findDepth(item);
    }
  }
  return depth;
}


*/

/**
  |============================
  | Метод filter()
  |============================
*/
/* 
Метод filter(callback) используется для единственной операции - фильтрации массива, то есть когда необходимо выбрать более одного элемента из коллекции 
по какому-то критерию.

массив.filter((element, index, array) => {
  // Тело коллбек-функции
});

Не изменяет оригинальный массив.
Поэлементно перебирает оригинальный массив.
Возвращает новый массив.
Добавляет в возвращаемый массив элементы которые удовлетворяют условию коллбек-функции.
Если коллбек вернул true элемент добавляется в возвращаемый массив.
Если коллбек вернул false элемент не добавляется в возвращаемый массив.
Если ни один элемент не удовлетворил условию, возвращает пустой массив.


const values = [51, -3, 27, 21, -68, 42, -37];

const positiveValues = values.filter(value => value >= 0);
console.log(positiveValues); // [51, 27, 21, 42]

const negativeValues = values.filter(value => value < 0);
console.log(negativeValues); // [-3, -68, -37]

const bigValues = values.filter(value => value > 1000);
console.log(bigValues); // []

// Оригинальный массив не изменился
console.log(values); // [51, -3, 27, 21, -68, 42, -37]

То есть метод filter вызывает коллбек-функцию для каждого элемента исходного массива и если результат её выполнения true, текущий элемент добавляет в новый массив.

Фильтрация уникальных элементов
Используя метод filter() можно выполнить фильтрацию массива так, что в нём останутся только уникальные элементы. 
Этот приём работает только с массивом примитивных значений - не объектов.

Вернёмся к группе студентов и массиву всех посещаемых предметов, которые мы получили методом flatMap().

const students = [
  { name: "Манго", courses: ["математика", "физика"] },
  { name: "Поли", courses: ["информатика", "математика"] },
  { name: "Киви", courses: ["физика", "биология"] },
];

const allCourses = students.flatMap(student => student.courses);
// ['математика', 'физика', 'информатика', 'математика', 'физика', 'биология'];

В переменной allCourses хранится массив всех посещаемых предметов, которые могут повторяться. 
Задача заключается в том, чтобы сделать новый массив, в котором будут только уникальные предметы, то есть без повторений.

const uniqueCourses = allCourses.filter(
  (course, index, array) => array.indexOf(course) === index
);

Используя array.indexOf(course) выполняем поиск первого совпадения текущего элемента course и получаем его индекс в оригинальном массиве всех курсов. 
В параметре index хранится индекс текущего элемента course при переборе массива методом filter.

Если результат indexOf() и значение index равны - это уникальный элемент, потому что это первый раз когда такое значение встречается в массиве 
и на текущей итерации фильтр обрабатывает именно его.

# Массив всех курсов
['математика', 'физика', 'информатика', 'математика', 'физика', 'биология'];

Для элемента 'математика' под индексом 0:

indexOf() вернёт 0, потому что ищет первое совпадение.
Значение параметра index будет 0.
Они равны, значит это уникальный элемент.
Для элемента 'математика' под индексом 3:

indexOf() вернёт 0, потому что ищет первое совпадение.
Значение параметра index будет 3.
Они не равны, значит это повторяющийся - не уникальный элемент.



Массив объектов
При работе с массивом объектов выполняется фильтрация по значению какого-то свойства. В результате получается новый массив отфильтрованных объектов.

Например, есть массив студентов с баллами за тест. Необходимо отфильтровать лучших (балл выше 80), худших (балл ниже 50) и средних студентов (балл от 50 до 80).

const LOW_SCORE = 50;
const HIGH_SCORE = 80;
const students = [
  { name: "Манго", score: 83 },
  { name: "Поли", score: 59 },
  { name: "Аякс", score: 37 },
  { name: "Киви", score: 94 },
  { name: "Хьюстон", score: 64 },
];

const best = students.filter(student => student.score >= HIGH_SCORE);
console.log(best); // Массив объектов с именами Манго и Киви

const worst = students.filter(student => student.score < LOW_SCORE);
console.log(worst); // Массив с одним объектом Аякс

// В коллбек-функции удобно деструктуризировать свойства объекта
const average = students.filter(
  ({ score }) => score >= LOW_SCORE && score < HIGH_SCORE
);
console.log(average); // Массив объектов с именами Поли и Хьюстон
*/

/**
  |============================
  | Метод find()
  |============================
*/
/* 

Если метод filter(callback) используется для поиска всех элементов удовлетворяющим условию, то метод find(callback) позволяет найти и вернуть первый подходящий элемент,
после чего перебор массива прекращается. То есть он ищет до первого совпадения.

массив.find((element, index, array) => {
  // Тело коллбек-функции
});

Не изменяет оригинальный массив.
Поэлементно перебирает оригинальный массив.
Возвращает первый элемент удовлетворяющий условию, то есть когда коллбек возвращает true.
Если ни один элемент не подошёл, то есть для всех элементов коллбек вернул false, метод возвращает undefined.
Метод find() используется для одной задачи - поиска элемента по уникальному значению свойства. 
Например, поиск пользователя по почте, автомобиля по серийному номеру, книги по названию и т. п.

const colorPickerOptions = [
  { label: "red", color: "#F44336" },
  { label: "green", color: "#4CAF50" },
  { label: "blue", color: "#2196F3" },
  { label: "pink", color: "#E91E63" },
  { label: "indigo", color: "#3F51B5" },
];

colorPickerOptions.find(option => option.label === "blue"); // { label: 'blue', color: '#2196F3' }
colorPickerOptions.find(option => option.label === "pink"); // { label: 'pink', color: '#E91E63' }
colorPickerOptions.find(option => option.label === "white"); // undefined
*/

/**
  |============================
  | Метод findIndex()
  |============================
*/
/* 

Метод findIndex(callback) это современная замена методу indexOf(). Позволяет выполнять поиск по более сложным условиям чем просто равенство. 
Используется как для поиска в массиве примитивов, так и в массиве обьектов.

массив.findIndex((element, index, array) => {
  // Тело коллбек-функции
});

Не изменяет оригинальный массив.
Поэлементно перебирает оригинальный массив.
Возвращает индекс первого элемента удовлетворяющего условию, то есть когда коллбек возвращает true.
Если ни один элемент не подошёл, то есть для всех элементов коллбек вернул false, метод возвращает -1.
const colorPickerOptions = [
  { label: "red", color: "#F44336" },
  { label: "green", color: "#4CAF50" },
  { label: "blue", color: "#2196F3" },
  { label: "pink", color: "#E91E63" },
  { label: "indigo", color: "#3F51B5" },
];

colorPickerOptions.findIndex(option => option.label === "blue"); // 2
colorPickerOptions.findIndex(option => option.label === "pink"); // 3
colorPickerOptions.findIndex(option => option.label === "white"); // -1
*/

/**
  |============================
  | Методы every() и some()
  |============================
*/
/* 

Метод every()
Проверяет проходят ли все элементы массива тест предоставляемый коллбек-функцией. Возвращает true или false.

массив.every((element, index, array) => {
  // Тело коллбек-функции
});

Не изменяет оригинальный массив.
Поэлементно перебирает оригинальный массив.
Возвращает true если все элементы массива удовлетворяют условию.
Возвращает false если хотябы один элемент массив не удовлетворяет условию.
Перебор массива прекращается если коллбек возвращает false.
// Все элементы больше либо равны нулю? - да
[1, 2, 3, 4, 5].every(value => value >= 0); // true

// Все элементы больше либо равны нулю? - нет
[1, 2, 3, -10, 4, 5].every(value => value >= 0); // false



Метод some()
Проверяет проходит ли хотя бы один элемент массива тест предоставляемый коллбек-функцией. Возвращает true или false.

массив.some((element, index, array) => {
  // Тело коллбек-функции
});

Не изменяет оригинальный массив.
Поэлементно перебирает оригинальный массив.
Возвращает true если хотя бы один элемент массива удовлетворяет условию.
Возвращает false если ни один элемент массив не удовлетворяет условию.
Перебор массива прекращается если коллбек возвращает true.
// Есть хотя бы один элемент больше либо равный нулю? - да
[1, 2, 3, 4, 5].some(value => value >= 0); // true

// Есть хотя бы один элемент больше либо равный нулю? - да
[-7, -20, 3, -10, -14].some(value => value >= 0); // true

// Есть хотя бы один элемент меньше нуля? - нет
[1, 2, 3, 4, 5].some(value => value < 0); // false

// Есть хотя бы один элемент меньше нуля? - да
[1, 2, 3, -10, 4, 5].some(value => value < 0); // true




Массив объектов
При работе с массивом объектов проверяется значение какого-то их свойства 
Например, есть массив объектов фруктов, необходимо узнать все ли фрукты есть в наличии и есть ли в наличии хоть какие-то фрукты более 0 штук.

const fruits = [
  { name: "apples", amount: 100 },
  { name: "bananas", amount: 0 },
  { name: "grapes", amount: 50 },
];

// every вернет true только если всех фруктов будет больше чем 0 штук
const allAvailable = fruits.every(fruit => fruit.amount > 0); // false

// some вернет true если хотябы одного фрукта будет больше чем 0 штук
const anyAvailable = fruits.some(fruits => fruits.amount > 0); // true
*/

/**
  |============================
  | Метод reduce()
  |============================
*/
/* 
Метод reduce(callback, initialValue) используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата, как аккумулятор. 
Немного сложнее других в усвоении, но результат стоит того.

массив.reduce((previousValue, element, index, array) => {
  // Тело коллбек-функции
}, initialValue);

Не изменяет оригинальный массив.
Поэлементно перебирает оригинальный массив.
Возвращает что угодно.
Делает что угодно.
Легче всего представить его работу на примере подсчёта суммы элементов массива.

const total = [2, 7, 3, 14, 6].reduce((previousValue, number) => {
  return previousValue + number;
}, 0);

console.log(total); // 32

Первый параметр коллбек-функции (previousValue) это аккумулятор, то есть промежуточный результат. 
Значение которое вернёт коллбек-функция на текущей итерации, будет значением этого параметра на следующей.

Вторым аргументом для reduce() можно передать необязательное начальное значение аккумулятора - параметр initialValue.

# Вначале метод reduce() создаёт внутреннюю переменную-аккумулятор и присваивает ей значение параметра initialValue или первого элемента
перебираемого массива, если initialValue не задан.
previousValue = 0

# Далее коллбек-функция вызывается для каждого элемента массива. Текущее значение параметра previousValue это то, что вернула коллбек-функция на прошлой итерации.
Итерация 1 -> previousValue = 0 -> number = 2 -> return 0 + 2 -> return 2
Итерация 2 -> previousValue = 2 -> number = 7 -> return 2 + 7 -> return 9
Итерация 3 -> previousValue = 9 -> number = 3 -> return 9 + 3 -> return 12
Итерация 4 -> previousValue = 12 -> number = 14 -> return 12 + 14 -> return 26
Итерация 5 -> previousValue = 26 -> number = 6 -> return 26 + 6 -> return 32

# После того как весь массив перебран, метод reduce() возвращает значение аккумулятора.
Результат - 32

То есть метод reduce() используется когда необходимо взять «много» и привести к «одному». В повседневных задачах его применение сводится к работе с числами.




Массив объектов
При работе с массивом объектов выполняется редуцирование по значению какого-то свойства. Например, есть массив студентов с баллами за тест. 
Необходимо получить средний бал.

const students = [
  { name: "Манго", score: 83 },
  { name: "Поли", score: 59 },
  { name: "Аякс", score: 37 },
  { name: "Киви", score: 94 },
  { name: "Хьюстон", score: 64 },
];

// Название аккумулятора может быть произвольным, это просто параметр функции
const totalScore = students.reduce((total, student) => {
  return total + student.score;
}, 0);

const averageScore = totalScore / students.length;




Продвинутый reduce
Допустим у нас есть следующая задача: из массива постов твиттера отдельного пользователя необходимо посчитать сумму всех лайков. 
Можно перебрать циклом for или forEach, каждое из этих решений потребует дополнительного кода. А можно использовать reduce.

const tweets = [
  { id: "000", likes: 5, tags: ["js", "nodejs"] },
  { id: "001", likes: 2, tags: ["html", "css"] },
  { id: "002", likes: 17, tags: ["html", "js", "nodejs"] },
  { id: "003", likes: 8, tags: ["css", "react"] },
  { id: "004", likes: 0, tags: ["js", "nodejs", "react"] },
];

// Пройдем по всем элементам коллекции и прибавим значения свойства likes к аккумулятору, начальное значение которого укажем 0.

const likes = tweets.reduce((totalLikes, tweet) => totalLikes + tweet.likes, 0);

console.log(likes); // 32

// Наверное подсчет лайков не одиночная операция, поэтому напишем функцию для подсчета лайков из коллекции

const countLikes = tweets => {
  return tweets.reduce((totalLikes, tweet) => totalLikes + tweet.likes, 0);
};

console.log(countLikes(tweets)); // 32

Заметили свойство tags у каждого поста? Продолжая тему reduce, мы соберем в массив все теги, которые встречаются в постах.

const tweets = [
  { id: "000", likes: 5, tags: ["js", "nodejs"] },
  { id: "001", likes: 2, tags: ["html", "css"] },
  { id: "002", likes: 17, tags: ["html", "js", "nodejs"] },
  { id: "003", likes: 8, tags: ["css", "react"] },
  { id: "004", likes: 0, tags: ["js", "nodejs", "react"] },
];

// Пройдем по всем элементам коллекции и добавим значения свойства tags к аккумулятору, начальное значение которого укажем пустым массивом [].
// На каждой итерации пушим в аккумулятор все элементы tweet.tags и возвращаем его.

const tags = tweets.reduce((allTags, tweet) => {
  allTags.push(...tweet.tags);

  return allTags;
}, []);

console.log(tags);

// Наверное сбор тегов не одиночная операция, поэтому напишем функцию для сбора тегов из коллекции
const getTags = tweets =>
  tweets.reduce((allTags, tweet) => {
    allTags.push(...tweet.tags);

    return allTags;
  }, []);

console.log(getTags(tweets));


После того, как мы собрали все теги из постов, хорошо бы было посчитать количество уникальных тегов в массиве. И снова reduce тут как тут.

const tweets = [
  { id: "000", likes: 5, tags: ["js", "nodejs"] },
  { id: "001", likes: 2, tags: ["html", "css"] },
  { id: "002", likes: 17, tags: ["html", "js", "nodejs"] },
  { id: "003", likes: 8, tags: ["css", "react"] },
  { id: "004", likes: 0, tags: ["js", "nodejs", "react"] },
];

const getTags = tweets =>
  tweets.reduce((allTags, tweet) => {
    allTags.push(...tweet.tags);

    return allTags;
  }, []);

const tags = getTags(tweets);

// Вынесем callback-функцию отдельно, а в reducе передадим ссылку на нее. Это стандартная практика если callback-функция довольно большая.
// Если в объекте-аккумуляторе acc нету своего свойства с ключем tag, то создаем его и записывает ему значение 0. В противном случае увеличиваем значение на 1.

const getTagStats = (acc, tag) => {
  if (!acc.hasOwnProperty(tag)) {
    acc[tag] = 0;
  }

  acc[tag] += 1;

  return acc;
};

// Начальное значение аккумулятора это пустой объект {}

const countTags = tags => tags.reduce(getTagStats, {});

const tagCount = countTags(tags);
console.log(tagCount);
*/

/**
  |============================
  | Метод sort()
  |============================
*/
/* 
Метод sort() сортирует элементы массива, но в отличии от остальных перебирающих методов, он сортирует исходный массив.

Сортирует и изменяет исходный массив.
Возвращает изменённый массив, то есть ссылку на отсортированный исходный.
По умолчанию сортирует по возрастанию.
Сортировка происходит путём приведения значений к строке и сравнения порядковых номеров в таблице Unicode.
Такой массив чисел будет отсортирован по возврастанию.

const scores = [61, 19, 74, 35, 92, 56];
scores.sort();
console.log(scores); // [19, 35, 56, 61, 74, 92]

Но, так как по умолчанию значения приводятся к строке, стандартная сортировка чисел работает необычно. 
Поэтому в следующем упражнении мы рассмотрим как задавать свой порядок сортировки.

const scores = [27, 2, 41, 4, 7, 3, 75];
scores.sort();
console.log(scores); // [2, 27, 3, 4, 41, 7, 75]

Массив строк сортируется по алфавиту.

const students = ["Вика", "Андрей", "Олег", "Юля", "Борис", "Катя"];
students.sort();
console.log(students); // [ 'Андрей', 'Борис', 'Вика', 'Катя', 'Олег', 'Юля' ]

При этом порядковый номер заглавных букв меньше чем у прописных.

const letters = ["b", "B", "a", "A", "c", "C"];
letters.sort();
console.log(letters); // ['A', 'B', 'C', 'a', 'b', 'c']




Из-за того, что сортируется исходный массив, нарушается принцип чистоты функций и нельзя удобно сделать несколько производных коллекций на базе исходной. 
Например, сделать коллекцию отсортированную по возрастанию, а другую по убыванию. Поэтому перед сортировкой делают полную копию исходного массива и сортируют уже её.

const scores = [61, 19, 74, 35, 92, 56];
const ascendingScores = [...scores].sort();

console.log(scores); // [61, 19, 74, 35, 92, 56]
console.log(ascendingScores); // [19, 35, 56, 61, 74, 92]




Свой порядок сортировки чисел
Для указания своего порядка сортировки методу sort(compareFunction) нужно передать коллбек-функцию с двумя параметрами. 
Это функция сравнения (compare function), порядок сортировки зависит от её результата. Метод sort() будет вызывать её для произвольных двух элементов.

массив.sort((a, b) => {
  // Тело коллбек-функции
});

a - первый элемент для сравнения.
b - второй элемент для сравнения.
Если вызов compareFunction(a, b) возвращает любое отрицательное значение, то есть a меньше b, сортировка поставит a перед b. Это сортировка по возрастанию.

const scores = [61, 19, 74, 35, 92, 56];
const ascendingScores = [...scores].sort((a, b) => a - b);
console.log(ascendingScores); // [19, 35, 56, 61, 74, 92]

Если вызов compareFunction(a, b) возвращает любое положительное значение больше нуля, то есть b больше a, сортировка поставит b перед a. Это сортировка по убыванию.

const scores = [61, 19, 74, 35, 92, 56];
const descendingScores = [...scores].sort((a, b) => b - a);
console.log(descendingScores); // [92, 74, 61, 56, 35, 19]

Eсли вызов compareFunction(a, b) вернёт 0, сортировка оставит a и b неизменными по отношению друг к другу, но отсортирует их по отношению ко всем другим элементам. 
Но вообще не важно, что возвращать, если их взаимный порядок не имеет значения.




Свой порядок сортировки строк
Для сортировки строк в алфавитном порядке, по возрастанию или убыванию, используется метод строк localeCompare().

firstString.localeCompare(secondString)

Он вызывается на строке которую нужно сравнить (firstString) с той, что передана ему как аргумент (secondString).

"a".localeCompare("b"); // -1
"b".localeCompare("a"); // 1
"a".localeCompare("a"); // 0
"b".localeCompare("b"); // 0

Возвращает отрицательное значение если firstString должна быть перед secondString.
Возвращает положительное значение больше нуля если firstString должна быть после secondString.
Если строки одинаковы, возвращается ноль.
Это удобно использовать при сортировке строк, так как метод sort() ожидает такие же значения от коллбек-функции.

const students = ["Вика", "Андрей", "Олег", "Юля", "Борис", "Катя"];

const inAlphabetOrder = [...students].sort((a, b) => a.localeCompare(b));
console.log(inAlphabetOrder); // ['Андрей', 'Борис', 'Вика', 'Катя', 'Олег', 'Юля']

const inReversedOrder = [...students].sort((a, b) => b.localeCompare(a));
console.log(inReversedOrder); // ['Юля', 'Олег', 'Катя', 'Вика', 'Борис', 'Андрей']




Сортировка объектов
При работе с массивом объектов сортировка выполняется по числовому или строчному значению какого-то свойства. 
Например, есть группа студентов с баллами за тест. Необходимо отсортировать массив объектов по возрастанию и убыванию количества баллов, и по имени студента.

const students = [
  { name: "Манго", score: 83 },
  { name: "Поли", score: 59 },
  { name: "Аякс", score: 37 },
  { name: "Киви", score: 94 },
];

const inAscendingScoreOrder = students.sort(
  (firstStudent, secondStudent) => firstStudent.score - secondStudent.score
);

const inDescendingScoreOrder = students.sort(
  (firstStudent, secondStudent) => secondStudent.score - firstStudent.score
);

const inAlphabeticalOrder = students.sort((firstStudent, secondStudent) =>
  firstStudent.name.localeCompare(secondStudent.name)
);
*/

/**
  |============================
  | Цепочки методов
  |============================
*/
/* 
Есть массив объектов с именами, баллами и посещаемыми предметами каждого студента.

const students = [
  { name: "Манго", score: 83, courses: ["математика", "физика"] },
  { name: "Поли", score: 59, courses: ["информатика", "математика"] },
  { name: "Аякс", score: 37, courses: ["физика", "биология"] },
  { name: "Киви", score: 94, courses: ["литература", "информатика"] },
];

Необходимо получить массив их имён отсортированный по возрастанию баллов за тест. 
Для этого мы отсортируем копию массива методом sort(), после чего методом map() составим массив значений свойства name из сортированного массива.

const sortedByAscendingScore = [...students].sort((a, b) => a.score - b.score);
const names = sortedByAscendingScore.map(student => student.name);

console.log(names); // ['Аякс', 'Поли', 'Манго', 'Киви']

Проблема в том, что у нас появляются промежуточные переменные после каждой операции кроме финальной. 
Переменная sortedByAscendingScore лишняя и необходима только для хранения промежуточного результата.

Избавиться от таких «мёртвых» переменных можно группируя вызовы методов в цепочки. Каждый следующий метод будет выполняться на результате работы предыдущего.

const names = [...students]
  .sort((a, b) => a.score - b.score)
  .map(student => student.name);

console.log(names); // ['Аякс', 'Поли', 'Манго', 'Киви']

Делаем копию исходного массива перед сортировкой.
На копии вызываем метод sort().
К результату работы метода sort() применяем метод map().
Переменной names присваивается результат работы метода map().



Получим сортированный по алфавиту массив уникальных посещаемых предметов.

const uniqueSortedCourses = students
  .flatMap(student => student.courses)
  .filter((course, index, array) => array.indexOf(course) === index)
  .sort((a, b) => a.localeCompare(b));

console.log(uniqueSortedCourses); // ['биология', 'информатика', 'литература', 'математика', 'физика']

На исходном массиве вызываем flatMap() и делаем разглаженный массив всех курсов.
К результату метода flatMap() применяем метод filter() для фильтрации уникальных элементов.
На результате метода filter() вызываем sort().
Переменной uniqueSortedCourses присваивается результат работы метода sort().
Цепочка методов может быть произвольной длины, но обычно не более 2-3 операций. 
Во-первых, перебирающие методы используются для сравнительно простых операций над коллекцией. 
Во-вторых, вызов каждого последующего метода, это дополнительный перебор массива, что при достаточном количестве, может сказаться на производительности.


*/

/**
  |============================
  | Комментарии и инструкции к коду 
  |============================
*/
/* 
Перед кодом функции, метода прописываем /**
VS Code автоматически предложит расшифровать и прокомментировать параметры функций и методов
*/

/**
  |============================
  | Контекст выполнения функции
  |============================
*/
/* 
Можно с уверенностью сказать, что ключевое слово this это одна из самых запутанных концепций JavaScript на старте обучения. 
Новички часто подставляют this методом научного тыка до тех пор, пока скрипт не сработает.

Контекст в JavaScript похож на контекст в предложении:

Петя бежит быстро, потому что Петя пытается поймать поезд.
Петя бежит быстро, потому что он пытается поймать поезд.
Второе предложение звучит лаконичнее. Предметом предложения является Петя и мы можем сказать, что контекст предложения - это Петя, 
потому что он в центре внимания в это конкретное время в предложении. Даже местоимение «кто» относится к Пете.

И точно так же объект может быть текущим контекстом исполнения функции.

// Петя бежит быстро, потому что Петя пытается поймать поезд.
const petya = {
  username: "Petya",
  showName() {
    console.log(petya.username);
  },
};

petya.showName();

Обращение к свойствам объекта внутри методов, используя имя самого объекта, аналогично использованию Петя вместо он.

Внутри функций можно использовать зарезервированное ключевое слово this. Во время исполнения функции, в this записывается ссылка на объект, 
в контексте которого она была вызвана. Таким образом, в теле функции мы можем получить доступ к свойствам и методам этого объекта.

// Петя бежит быстро, потому что он (this) пытается поймать поезд.
const petya = {
  username: "Petya",
  showName() {
    console.log(this.username);
  },
};

petya.showName();

Разберем пример с коллекцией книг.

const bookShelf = {
  authors: ["Бернард Корнуэлл", "Роберт Шекли"],
  getAuthors() {
    return this.authors;
  },
  addAuthor(authorName) {
    this.authors.push(authorName);
  },
};

console.log(bookShelf.getAuthors()); // ["Бернард Корнуэлл", "Роберт Шекли"]
bookShelf.addAuthor("Ли Танит");
console.log(bookShelf.getAuthors()); // ["Бернард Корнуэлл", "Роберт Шекли", "Ли Танит"]

Методы getAuthors и addAuthor это функции (методы объекта), которые вызываются в контексте объекта bookShelf. 
Во время их выполнения в this записывается ссылка на объект bookShelf и мы можем обратиться к его свойствам и методам.
*/

/**
  |============================
  | Правила определения this
  |============================
*/
/* 
Необходимо усвоить всего одно правило для определения this - значение контекста внутри функции (не стрелочной) определятся не в момент ее создания, 
а в момент вызова. То есть значение this определяется тем, как вызывается функция, а не где она была объявлена.

this в глобальной области видимости
В глобальной области видимости, если скрипт выполняется не в строгом режиме, this ссылается на объект window. 
В строгом режиме значение this, в глобальной области видимости, будет undefined.

function foo() {
  console.log(this);
}

foo(); // window без "use strict" и undefined с "use strict"




this в методе объекта
Если функция была вызвана как метод объекта, то контекст будет ссылаться на объект, частью которого является метод.

const petya = {
  username: "Petya",
  showThis() {
    console.log(this);
  },
  showName() {
    console.log(this.username);
  },
};

petya.showThis(); // {username: "Petya", showThis: ƒ, showName: ƒ}
petya.showName(); // 'Petya'

Разберем более сложный пример для лучшего понимания.

Сначала создадим функцию в глобальной области видимости и вызовем ее.
После чего присвоим ее в свойство объекта и вызовем как метод этого объекта.

function showThis() {
  console.log("this in showThis: ", this);
}

// Вызываем в глобальном контексте
showThis(); // this in showThis: Window

const user = {
  username: "Mango",
};

// Записываем ссылку на функцию в свойство объекта
// Обратите внимание, что это не вызов - нет ()
user.showContext = showThis;

// Вызываем функцию в контексте объекта this будет указывать на текущий объект, в контексте которого осуществляется вызов, а не на глобальный объект.

user.showContext(); // this in showThis: {username: "Mango", showContext: ƒ}





this в callback-функциях
При передаче методов объекта как колбэк-функций, контекст не сохраняется. 
Колбэк это ссылка на метод, которая присваивается как значение параметра, вызываемого без объекта.

const customer = {
  firstName: "Jacob",
  lastName: "Mercer",
  getFullName() {
    return `${this.firstName} ${this.lastName}`;
  },
};

function makeMessage(callback) {
  // callback() это вызов метода getFullName без объекта
  console.log(`Обрабатываем заявку от ${callback()}.`);
}

makeMessage(customer.getFullName); // Будет ошибка при вызове функции

ИНТЕРЕСНО
Решение этой проблемы рассматривается в секции про метод bind() и методы объекта.





this в стрелочных функциях
Стрелочные функции не имеют своего this. В отличии от обычных функций, изменить значение this внутри стрелки после её объявления нельзя.

ИНТЕРЕСНО
Контекст внутри стрелки определяется местом её объявления, а не вызова и ссылается на контекст родительской функции.

Стрелочные функции также игнорируют наличие строгого режима. Если стрелка запомнила глобальный контекст, то this в ней будет содержать ссылку на 
window независимо от того, выполняется скрипт в строгом режиме или нет.

const showThis = () => {
  console.log("this in showThis: ", this);
};

showThis(); // this in showThis: window

const user = {
  username: "Mango",
};
user.showContext = showThis;

user.showContext(); // this in showThis: window

Ограничивая стрелочные функции постоянным контекстом, JavaScript-движки могут лучше их оптимизировать, в отличие от обычных функций, 
значение this которых может быть изменено.

Пример не практичный, но отлично показывает как работает контекст для стрелок. Значение контекста берется из родительской области видимости.

const hotel = {
  username: "Resort hotel",
  showThis() {
    const foo = () => {
      // Стрелки запоминают контекст во время объявления,
      // из родительской области видимости
      console.log("this in foo: ", this);
    };

    foo();
    console.log("this in showThis: ", this);
  },
};

hotel.showThis();
// this in foo: {username: 'Resort hotel', showThis: ƒ}
// this in showThis: {username: 'Resort hotel',showThis: ƒ}
*/

/**
  |============================
  | Методы функций
  |============================
*/
/* 
Бывают ситуации когда функцию нужно вызвать в контексте какого-то объекта, при этом функция не является его методом. 
Для этого у функций есть методы call, apply и bind.




Метод call()
foo.call(obj, arg1, arg2, ...)

Метод call вызовет функцию foo так, что в this будет ссылка на объект obj, а также передаст аргументы arg1, arg2 и т. д.

function greetGuest(greeting) {
  console.log(`${greeting}, ${this.username}.`);
}

const mango = {
  username: "Манго",
};
const poly = {
  username: "Поли",
};

greetGuest.call(mango, "Добро пожаловать"); // Добро пожаловать, Манго.
greetGuest.call(poly, "С приездом"); // С приездом, Поли.




Метод apply
Метод apply это аналог метода call за исключением того, что синтаксис передачи аргументов требует не перечисление, а массив, даже если аргумент всего один.

foo.call(obj, arg1, arg2, ...)

foo.apply(obj, [arg1, arg2, ...])

Метод apply вызовет функцию foo так, что в this будет ссылка на объект obj, а также передаст элементы массива как отдельные аргументы arg1, arg2 и т. д.

function greetGuest(greeting) {
  console.log(`${greeting}, ${this.username}.`);
}

const mango = {
  username: "Манго",
};
const poly = {
  username: "Поли",
};

greetGuest.apply(mango, ["Добро пожаловать"]); // Добро пожаловать, Манго.
greetGuest.apply(poly, ["С приездом"]); // С приездом, Поли.





Метод bind()
Методы call и apply вызывают функцию «на месте», то есть сразу. Но в случае колбэк-функций, когда необходимо не сразу вызвать функцию, 
а передать ссылку на неё, причём с привязанным контекстом, используется метод bind.

foo.bind(obj, arg1, arg2, ...)

Метод bind создаёт и возвращает копию функции foo с привязанным контекстом obj и аргументами arg1, arg2 и т. д. 
Получается копия функции которую можно передать куда угодно и вызвать когда угодно.

function greet(clientName) {
  return `${clientName}, добро пожаловать в «${this.service}».`;
}

const steam = {
  service: "Steam",
};
const steamGreeter = greet.bind(steam);
steamGreeter("Манго"); // "Манго, добро пожаловать в «Steam»."

const gmail = {
  service: "Gmail",
};
const gmailGreeter = greet.bind(gmail);
gmailGreeter("Поли"); // "Поли, добро пожаловать в «Gmail»."




bind() и методы объекта
При передаче методов объекта как колбэк-функций, контекст не сохраняется. Колбэк это ссылка на метод, которая присваивается как значение параметра,
вызываемого без объекта.

const customer = {
  firstName: "Jacob",
  lastName: "Mercer",
  getFullName() {
    return `${this.firstName} ${this.lastName}`;
  },
};

function makeMessage(callback) {
  // callback() это вызов метода getFullName без объекта
  console.log(`Обрабатываем заявку от ${callback()}.`);
}

makeMessage(customer.getFullName); // Будет ошибка при вызове функции

В строгом режиме, значение this в методе getFullName, при вызове как колбэк-функции callback(), будет undefined. 
При обращении к свойствам firstName и lastName будет ошибка, так как undefined это не объект.

Метод bind используется для привязки контекста при передаче методов объекта как колбэк-функций. 
Передадим колбэком не оригинальный метод getFullName, а его копию с привязанным контекстом к объекту customer.

// ❌ Было
makeMessage(customer.getFullName); // Будет ошибка при вызове функции

// ✅ Стало
makeMessage(customer.getFullName.bind(customer)); // Обрабатываем заявку от Jacob Mercer.
*/

/**
  |============================
  | Объектно-ориентированное программирование
  |============================
*/
/* 
Процедурное программирование - набор не связанных явно функций и переменных для хранения и обработки информации. Этот подход прост и прямолинеен 
и подходит для задач где нет тесно связанных сущностей (данных и функций для их обработки).

Рассмотрим пример процедурного кода где есть переменные и функция для подсчета результата.

const baseSalary = 30000;
const overtime = 10;
const rate = 20;

const getWage = (baseSalary, overtime, rate) => {
  return baseSalary + overtime * rate;
};

getWage(baseSalary, overtime, rate);



Объектно-ориентированное программирование (ООП) - методология, основанная на представлении программы в виде совокупности объектов, каждый из которых 
содержит данные (свойства) и методы для взаимодействия с ними.

Используем ООП, собрав данные в объект employee.

const employee = {
  baseSalary: 30000,
  overtime: 10,
  rate: 20,
  getWage() {
    return this.baseSalary + this.overtime * this.rate;
  },
};

employee.getWage();

При таком подходе у метода нет параметров, используются свойства объекта, которые задаются при создании объекта и, возможно, так же изменяются другими методами. 
На выходе получаем сущность с простым интерфейсом, что понижает сложность программы.

ИНТЕРЕСНО
Идеологически, ООП - это подход к программированию как к моделированию, решающий основную задачу - структурирование информации с точки зрения управляемости, 
что существенно улучшает контроль процесса моделирования.




Сущности ООП
Представьте себе, что мы проектируем автомобиль. У него будет двигатель, четыре колеса, бензобак и т. д. 
Автомобиль должен иметь возможность заводиться, набирать и сбавлять скорость. Мы знаем как взаимодействует двигатель и колёса, 
то есть согласно каким законам взаимодействуют разные части машины.



Класс
Мы описываем все запчасти из которых состоит автомобиль, то каким образом эти запчасти взаимодействуют между собой и что должен сделать водитель, 
чтобы машина затормозила, включились фары и другое. Результатом нашей работы будет некоторый эскиз (шаблон, схема). Мы только что разработали то, что в 
ООП называется класс.


Класс - способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт).

В нашем случае, класс описывает сущность – автомобиль. Свойствами класса будут двигатель, колеса, фары и т. д. 
Методами класса будут открыть дверь, завести двигатель, увеличить скорость и т. п.



Экземпляр
Мы спроектировали чертежи и машины, разработанные по ним, сходят с конвейера. Каждая из них точно повторяет чертеж, все системы взаимодействуют именно так, 
как мы спроектировали, но каждая машина уникальна. Они все имеют номер кузова и двигателя, но все номера разные, автомобили различаются цветом, 
отделкой салона. Эти автомобили являются экземплярами класса.

Экземпляр (объект) - это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом. 
Это то, что создано по чертежу, то есть по описанию из класса.

Говоря простым языком, объект имеет конкретные значения свойств и методы, работающие с этими свойствами на основе правил, заданных в классе. 
В данном примере, если класс - это некоторый абстрактный автомобиль на чертеже, то объект - это конкретный автомобиль, стоящий у нас под окнами.




Интерфейс
Когда мы подходим к автомату с кофе или садимся за руль автомобиля, существует некоторый набор элементов управления, с которыми мы можем взаимодействовать.

Интерфейс - это набор свойств и методов класса, доступных для использования при работе с экземпляром.
По сути, интерфейс описывает класс, чётко определяя все возможные действия над ним. Хороший пример интерфейса - приборная панель автомобиля, 
которая позволяет вызвать такие методы как увеличение скорости, торможение, поворот, переключение передач, включение фар и т. п.

При описании интерфейса класса очень важно соблюсти баланс между гибкостью и простотой. Класс с простым интерфейсом будет легко использовать, 
но будут существовать задачи, которые с помощью него решить будет не под силу.

Если интерфейс будет гибким, то скорее всего, он будет состоять из достаточно сложных методов с большим количеством параметров, 
которые будут позволять делать очень многое, но его использование будет сопряжено с большими сложностями и риском совершить ошибку, что-то перепутав.
*/

/**
  |============================
  | Прототипное наследование
  |============================
*/
/* 
Прототипное наследование
ООП в JavaScript построено на прототипном наследовании. Объекты можно организовать в цепочки так, чтобы свойство не найденное в одном объекте, 
автоматически искалось бы в другом. Связующим звеном выступает специальное скрытое свойство [[Prototype]], которое в консоли браузера отображается как __proto__.



Прототип объекта



Метод Object.create(obj) создаёт и возвращает новый объект, связывая его с объектом obj.

const animal = {
  legs: 4,
};
const dog = Object.create(animal);
dog.name = "Манго";

console.log(dog); // { name: 'Манго', __proto__: animal }
console.log(animal.isPrototypeOf(dog)); // true

Объект, на который указывает ссылка в __proto__, называется прототипом. В нашем примере объект animal это прототип для объекта dog. 
Метод isPrototypeOf() проверяет является ли объект animal прототипом для dog и возвращает true или false.

console.log(dog.hasOwnProperty("name")); // true
console.log(dog.name); // 'Манго'

console.log(dog.hasOwnProperty("legs")); // false
console.log(dog.legs); // 4

Обращение dog.name работает очевидным образом - возвращает собственное свойство name объекта dog. 
При обращении к dog.legs интерпретатор ищет свойство legs в объекте dog, не находит и продолжает поиск в объекте по ссылке из dog.__proto__, 
то есть, в данном случае, в объекте animal - его прототипе.

То есть прототип - это резервное хранилище свойств и методов объекта, автоматически используемое при их поиске. 
У объекта, который выступает прототипом может также быть свой прототип, у того свой, и так далее.

Поиск свойства выполняется до первого совпадения. Интерпретатор ищет свойство по имени в объекте, если не находит, то обращается к свойству __proto__, 
т. е. переходит по ссылке к объекту-прототипу, а затем и прототипу прототипа. Если интерпретатор доберется до конца цепочки и не найдет свойства с таким именем, 
то вернёт undefined.

ИНТЕРЕСНО
В спецификации свойство __proto__ обозначено как [[Prototype]]. Двойные квадратные скобки здесь важны, они указывают на то, что это внутреннее, служебное свойство.



Метод hasOwnProperty()
После того как мы узнали о том, как происходит поиск свойств объекта, должно стать понятно, почему цикл for...in не делает различия между свойствами объекта 
и его прототипа.

const animal = { eats: true };
const dog = Object.create(animal);
dog.barks = true;

for (const key in dog) {
  console.log(key); // barks, eats
}

Именно поэтому мы используем метод obj.hasOwnProperty(prop), который возвращает true, если свойство prop принадлежит самому объекту obj, а не его прототипу, 
иначе false.

const animal = {
  eats: true,
};
const dog = Object.create(animal);
dog.barks = true;

for (const key in dog) {
  if (!dog.hasOwnProperty(key)) continue;

  console.log(key); // barks
}




Метод Object.keys(obj) вернет массив только собственных ключей объекта obj, поэтому на практике используют именно его, а не for...in.

const animal = {
  eats: true,
};
const dog = Object.create(animal);
dog.barks = true;

const dogKeys = Object.keys(dog);

console.log(dogKeys); // ['barks']
*/

/**
  |============================
  | Классы
  |============================
*/
/* 
Синтаксис литерала объекта позволяет создать один объект. Но часто нужно создать много однотипных объектов с одинаковым набором свойств, 
но разными значениями и методами для взаимодействия с ними. Всё это нужно сделать динамичекски, во время выполнения программы. 
Для этого используют классы - специальный синтаксис объявления функции для создания объектов.





Объявление класса
Объявление класса начинается с ключевого слова class, после которого идёт имя класса и фигурные скобки - его тело. 
Классы принято называть с большой буквы, а в самом названии отражать тип создаваемого объекта (существительное).

class User {
  // Тело класса
}

const mango = new User();
console.log(mango); // {}

const poly = new User();
console.log(poly); // {}

Результат вызова new User() это объект, который называется экземпляр класса, потому что содержит данные и поведение, описываемые классом.

ИНТЕРЕСНО
Как строить класс, зависит от того, что вам нужно. В нашем случае, класс представляет собой пользователя, поэтому мы добавим туда поля для имени и почты.





Конструктор класса
Для инициализации экземпляра в классе есть метод constructor. Если он не объявлен, создаётся конструктор по умолчанию - пустая функция, которая не изменяет экземпляр.

class User {
  // Синтаксис объявления метода класса
  constructor(name, email) {
    // Инициализация свойств экземпляра
    this.name = name;
    this.email = email;
  }
}

const mango = new User("Манго", "mango@mail.com");
console.log(mango); // { name: 'Манго', email: 'mango@mail.com' }

const poly = new User("Поли", "poly@mail.com");
console.log(poly); // { name: 'Поли', email: 'poly@mail.com' }

Вызов класса с оператором new приводит к созданию нового объекта и вызову конструктора в контексте этого объекта. 
То есть this внутри конструктора будет ссылаться на новосозданный объект. Это позволяет добавлять каждому объекту свойства с одинаковыми именами, но разными значениями.

Свойства name и email называются публичные свойства, потому что они будут собственными свойствами объекта-экземпляра и к ним можно будет получить доступ 
обратившись через точку.





Объект параметров
Класс может принимать большое количество входных данных для свойств будущего объекта. 
Поэтому к ним также можно применить паттерн «Объект параметров, передавая один объект с логично именованными свойствами, вместо несвязанного набора аргументов.

class User {
  // Деструктуризируем объект
  constructor({ name, email }) {
    this.name = name;
    this.email = email;
  }
}

const mango = new User({
  name: "Манго",
  email: "mango@mail.com",
});
console.log(mango); // { name: "Манго", email: "mango@mail.com" }

const poly = new User({
  name: "Поли",
  email: "poly@mail.com",
});
console.log(poly); // { name: "Поли", email: "poly@mail.com" }






Методы класса
Для работы со свойствами будущего экземпляра используются методы класса - функции которые будут доступны экземпляру в его прототипе.

class User {
  constructor({ name, email }) {
    this.name = name;
    this.email = email;
  }

  // Метод getEmail
  getEmail() {
    return this.email;
  }

  // Метод changeEmail
  changeEmail(newEmail) {
    this.email = newEmail;
  }
}





Приватные свойства
Инкапсуляция - это концепция позволяющая скрыть внутренние детали класса. 
Пользователь класса должен получать доступ только к публичному интерфейсу - набору публичных свойств и методов класса.

В классах инкапсуляция реализуется приватными свойствами, доступ к которым можно получить только внутри класса.

Допустим, почта пользователя должна быть недоступна для прямого изменения из вне, то есть приватна. 
Добавляя к имени свойства символ # мы делаем его приватным. Объявление приватного свойства до инициализации в конструкторе - обязательно.

class User {
  // Необязательное объявление публичных свойств
  name;
  // Обязательное объявление приватных свойств
  #email;

  constructor({ name, email }) {
    this.name = name;
    this.#email = email;
  }

  getEmail() {
    return this.#email;
  }

  changeEmail(newEmail) {
    this.#email = newEmail;
  }
}

const mango = new User({
  name: "Манго",
  email: "mango@mail.com",
});
mango.changeEmail("mango@supermail.com");
console.log(mango.getEmail()); // mango@supermail.com
console.log(mango.#email); // Будет ошибка, это приватное свойство

Методы класса также могут быть приватными, то есть доступны только в теле класса. Для этого перед их именем необходимо поставить символ #.






Геттеры и сеттеры
Геттеры и сеттеры - это более краткий синтаксис объявления методов для взаимодействия со свойствами. 
Геттер и сеттер имитируют обычное публичное свойство класса, но позволяют изменять другие свойства более удобным способом. 
Геттер выполняется при попытке получить значение свойства, а сеттер - при попытке его изменить.

Геттеры и сеттеры хорошо использовать для простых операций чтения и изменения значения свойств, особенно приватных, как их публичный интерфейс. 
Для работы со свойством которое хранит массив или объект они не подойдут.

class User {
  #email;

  constructor({ name, email }) {
    this.name = name;
    this.#email = email;
  }

  // Геттер email
  get email() {
    return this.#email;
  }

  // Сеттер email
  set email(newEmail) {
    this.#email = newEmail;
  }
}

Мы объявили геттер и сеттер email поставив перед именем свойства ключевые слова get и set. 
Внутри этих методов мы или возвращаем значение приватного свойства #email или изменяем его значение. Геттер и сеттер идут впаре и должны называться одинаково.

const mango = new User({ name: "Манго", email: "mango@mail.com" });
console.log(mango.email); // mango@mail.com
mango.email = "mango@supermail.com";
console.log(mango.email); // mango@supermail.com

При обращении к mango.email вызызвается геттер get email() {...} и выполняется его код. 
ри попытке записи mango.email = "mango@supermail.com" вызывается сеттер set email(newEmail) {...} и строка "mango@supermail.com" будет значением параметра newEmail.

Плюс в том, что это методы, а значит при записи можно выполнить дополнительный код, например с какими-то проверками, 
в отличии от выполнениях этой же операции напрямую со свойством.

set email(newEmail) {
  if(newEmail === "") {
    console.error("Ошибка! Почта не может быть пустой строкой!");
    return;
  }

  this.#email = newEmail;
}





Статические свойства
Кроме публичных и приватных свойств будущего экземпляра, в классе можно объявить его собственные свойства, доступные только классу, 
но не его экземплярам - статические свойства (static). Они полезны для хранения информации относящейся к самому классу.

Добавим классу пользователя приватное свойство role - его роль, определяющую набор прав, например администратор, редактор, просто пользователь и т п. 
Возможные роли пользователей будем хранить как статическое свойство Roles - объект со свойствами.

Статические свойства объявляются в теле класса. Перед именем свойства добавляется ключевое слово static.

class User {
  // Объявление и инициализация статического свойства
  static Roles = {
    ADMIN: "admin",
    EDITOR: "editor",
  };

  #email;
  #role;

  constructor({ email, role }) {
    this.#email = email;
    this.#role = role;
  }

  get role() {
    return this.#role;
  }

  set role(newRole) {
    this.#role = newRole;
  }
}

const mango = new User({
  email: "mango@mail.com",
  role: User.Roles.ADMIN,
});

console.log(mango.Roles); // undefined
console.log(User.Roles); // { ADMIN: "admin", EDITOR: "editor" }

console.log(mango.role); // "admin"
mango.role = User.Roles.EDITOR;
console.log(mango.role); // "editor"

Статические свойства также могут быть приватные, то есть доступные только внутри класса. 
Для этого имя свойства должно начинаться с символа #, также как приватные свойства. 
Обращение к приватному статическому свойству вне тела класса вызовет ошибку.





Статические методы
В классе можно объявить не только методы будущего экземпляра, но и методы доступные только классу - статические методы, которые могут быть как публичные так и приватные. 
Синтаксис объявления аналогичен статическим свойствам, за исключением того что значением будет метод.

class User {
  static #takenEmails = [];

  static isEmailTaken(email) {
    return User.#takenEmails.includes(email);
  }

  #email;

  constructor({ email }) {
    this.#email = email;
    User.#takenEmails.push(email);
  }
}

const mango = new User({ email: "mango@mail.com" });

console.log(User.isEmailTaken("poly@mail.com"));
console.log(User.isEmailTaken("mango@mail.com"));

Особенность статических методов в том, что во время их вызова ключевое слово this ссылается на сам класс. 
Это значит что статический метод может получить доступ к статическим свойствам класса, но не к свойствам экземпляра. 
Логично, потому что статические методы вызывает сам класс, а не его экземпляры.





Наследование классов
Ключевое слово extends позволяет реализовать наследование классов, когда один класс (дочерний, производный) наследует свойства и методы другого класса (родителя).

class Child extends Parent {
  // ...
}

В выражении class Child extends Parent дочерний класс Child наследует (расширяет) от родительского класса Parent.

Это означает, что мы можем объявить базовый класс, который хранит общие характеристики и методы для группы производных классов, 
которые наследуют свойства и методы родителя, но также добавляют свои уникальные.

Например, в приложении есть пользователи разных ролей - администратор, писатель статей, контент менеджер и т. п. 
У каждого типа пользователя есть набор общих характеристик, например почта и пароль, но также есть и уникальные.

Сделав независимые классы для каждого типа пользователя мы получим дублирование общих свойств и методов, и при необходимости изменить например 
название свойства, придётся проходить по всем классам, это неудобно и трудозатратно.

Вместо этого можно сделать общий класс User, который будет хранить набор общих свойств и методов, после чего сделать классы для каждого типа пользователя 
которые наследуют этот набор от класса User. При необходимости изменить что-то общее, достаточно будет поменять только код класса User.

class User {
  #email;

  constructor(email) {
    this.#email = email;
  }

  get email() {
    return this.#email;
  }

  set email(newEmail) {
    this.#email = newEmail;
  }
}

class ContentEditor extends User {
  // Тело класса ContentEditor
}

const editor = new ContentEditor("mango@mail.com");
console.log(editor); // { email: "mango@mail.com" }
console.log(editor.email); // "mango@mail.com"

Класс ContentEditor наследует от класса User его конструктор, геттер и сеттер email, а также одноимённое публичное свойство. 
Важно помнить что приватные свойства и методы класса-родителя не наследуются классом-ребёнком.





Конструктор дочернего класса
Первым делом в конструкторе дочернего класса необходимо вызвать специальную функцию super(аргументы) - 
это псевдоним конструктора родительского класса. 
В противном случае, при попытке обратиться к this в конструкторе дочернего класса, будет ошибка. 
При вызове конструктора класса родителя передаём необходимые ему аргументы для инициализации свойств.

class User {
  #email;

  constructor(email) {
    this.#email = email;
  }

  get email() {
    return this.#email;
  }

  set email(newEmail) {
    this.#email = newEmail;
  }
}

class ContentEditor extends User {
  constructor({ email, posts }) {
    // Вызов конструктора родительского класса User
    super(email);
    this.posts = posts;
  }
}

const editor = new ContentEditor({ email: "mango@mail.com", posts: [] });
console.log(editor); // { email: 'mango@mail.com', posts: [] }
console.log(editor.email); // 'mango@mail.com'





Методы дочернего класса
В дочернем классе можно объявлять методы которые будут доступны только его экземплярам.

// Представим что выше есть объявление класса User

class ContentEditor extends User {
  constructor({ email, posts }) {
    super(email);
    this.posts = posts;
  }

  addPost(post) {
    this.posts.push(post);
  }
}

const editor = new ContentEditor({ email: "mango@mail.com", posts: [] });
console.log(editor); // { email: 'mango@mail.com', posts: [] }
console.log(editor.email); // 'mango@mail.com'
editor.addPost("post-1");
console.log(editor.posts); // ['post-1']
*/

/**
  |============================
  | Копирование объектов
  |============================
*/

/* 
При копровании объектов есть определенные сложности. Дело в том что многие доступные методы копирования подрзумевают только коирование первого уровня свойств 
(ключей) объекта.
Вложенные функции и объекты являются самостятельными узами, на них распространяется правила "копирования по ссылке, а не по значению".
Соответственно в новом объекте они не будут скопированны, а на них просто будут созданы ссылки.

Варианты копирования первого уровня вложенности:

const admin = JSON.parse(JSON.stringify(user)) // копирование объекта user в admin
const admin = Object.({}, user) // копирование объекта user в admin
const admin = {...user} // копирование объекта user в admin



Вариант полного копирования объекта с полноценным копированием всех вложенных функций и объектов - глубокое копирование с помощью рекурсии (рекурсия объекта)

const deepClone = obj => {
  if (obj === null) return null;
  // Создаем поверхностный клона оригинала.
  let clone = Object.assign({}, obj);

  // Определяем, какие пары ключ-значение
  // необходимо глубоко клонировать.
  Object.keys(clone).forEach(
    key =>
      (clone[key] =
        typeof obj[key] === "object" ? deepClone(obj[key]) : obj[key])
  );

  // Проверяем является ли obj массивом и не пустой ли он.
  return Array.isArray(obj) && obj.length
    // Если obj массив и он не пуст, тогда
    // указываем объекту clone длину исходного массива что бы
    // конвертировать clone в массив и вернуть его.
    ? (clone.length = obj.length) && Array.from(clone)
    // Если obj пустой массив,
    : Array.isArray(obj)
    // то возвращаем его
    ? Array.from(obj)
    // в других случаях obj это объект и мы возвращаем копию clone.
    : clone;
};

// Пример:

const a = { foo: "bar", obj: { a: 1, b: 2 } };
const b = deepClone(a);
// a !== b true
// a.obj !== b.obj true


*/

/**
  |============================
  | Объектная модель документа
  |============================
*/
/* 
Когда мы работаем с браузером, доступный функционал состоит из нескольких модулей, так как JavaScript сам по себе не имеет инструментов для работы с браузером.

Объектная модель документа (Document Object Model) - независимый от языка интерфейс для работы с HTML-документом. 
Содержит набор свойств и методов позволяющих искать, создавать и удалять элементы, реагировать на действия пользователя и многое другое. 
То есть соединяет страницу с языком программирования.

DOM это отражение HTML-документа - древовидная структура, в которой каждый узел это JavaScript-объект со свойствами и методами, 
представляющий часть HTML-документа. Каждый элемент в документе, весь документ в целом, заголовок, ссылка, абзац - это части DOM этого документа, 
поэтому все они могут быть изменены из JavaScript-кода.

Объектная модель браузера (Browser Object Model) - независимый от языка интерфейс для работы с вкладкой браузера. 
Содержит набор свойств и методов, позволяющих получить доступ непосредственно к текущей вкладке и ряду функций браузера. 
Включает объект работы с историей навигации, местоположением и многое другое.



HTML-документ и DOM
Согласно DOM-модели, каждый тег образует отдельный элемент-узел, каждый фрагмент текста - текстовый элемент. 
HTML-документ это иерархическое дерево, в котором у каждого элемента (кроме корневого) есть только один родитель, т. е. элемент, 
внутри которого он располагается. Это дерево образуется за счет вложенной структуры тегов и текстовых элементов.

Чтобы отобразить HTML-документ, браузер сначала преобразовывает его в формат, который он понимает - DOM. 
У движка браузера есть специальный фрагмент кода - HTML-парсер, который используется для преобразования HTML в DOM.

В HTML вложенность определяет отношения родитель-ребенок между элементами. В DOM объекты связаны в древовидной структуре данных, фиксируя эти отношения.
Браузер строит DOM постепенно, как только приходят первые фрагменты кода, он начинает парсить HTML, добавляя узлы в древовидную структуру.

После того как DOM-дерево построено, в нем можно найти элемент с помощью JavaScript и выполнять с ним какие-то действия, так как каждый элемент 
имеет интерфейс с множеством свойств и методов.



DOM-дерево
Визуализируем дерево HTML-документа используя сервис генератора DOM-дерева.

<!DOCTYPE html>
<html>
  <head>
    <title>Document title</title>
  </head>
  <body>
    <h1>Page title</h1>
    <ul>
      <li><a href="#">Link 1</a></li>
      <li><a href="#">Link 2</a></li>
    </ul>
  </body>
</html>

DOCTYPE: html
HTML
-HEAD
--#text:
--TITLE
---#text: Document title
--#text:
-#text:
BODY
-#text:
-H1
--#text: Page title
-#text:
-UL
--#text:
--LI
---A href="#"
----#text: Link 1
--#text:
--LI
---A href="#"
----#text: Link 2
--#text:
-#text:

В этом дереве два типа узлов.

Узлы-элементы (element node) - образуются тегами, естественным образом одни элементы вложены в другие. 
Структура дерева образована исключительно за счет них.

Текстовые узлы (text node) - образуются текстом внутри элементов. Текстовый узел содержит только строку текста и не может иметь потомков, 
то есть он всегда на самом нижнем уровне иерархии. Пробелы и переносы строк - это тоже текстовые узлы.

ИНТЕРЕСНО
Из этого правила есть исключения: пробелы до head игнорируются, а любое содержимое после body не создаёт элемент, браузер переносит его в конец body.
*/

/**
  |============================
  | Навигация по DOM
  |============================
*/
/* 
DOM предоставляет широкий спектр возможностей при работе с элементом и его содержимым, но для этого на него сначала нужно получить ссылку. 
Доступ к DOM начинается с объекта document, от него можно добраться до любых элементов.

ИНТЕРЕСНО
document это часть глобального объекта window, который доступен в скрипте, когда он выполняется в браузере. Также как alert, console.log, prompt и многие другие.

Элементы DOM-дерева имеют иерархическое отношение друг к другу. Для описания отношений используются термины предок (ancestor), потомок (descendant), 
родитель (parent), ребенок (child) и сосед (sibling).

Самый верхний элемент называется корневым (root node).
Каждый элемент, кроме корневого, имеет только одного родителя.
У элемента может быть сколько угодно детей.
Соседи - это элементы с общим родителем.
Дочерние элементы (дети) - элементы, которые лежат непосредственно внутри текущего (первая вложенность).
Потомки – все элементы, которые лежат внутри текущего, вместе с их детьми, детьми их детей и так далее. То есть всё поддерево.

Для навигации по этой иерархии у элементов есть следующие свойства.

elem.parentNode - выберет родителя elem.
elem.childNodes - псевдомассив, хранит все дочерние элементы, ВКЛЮЧАЯ ТЕКСТОВЫЕ.
elem.children - псевдомассив, хранит только дочерние узлы-элементы, то есть соответствующие тегам, БЕЗ УЧЕТА ТЕКСТОВЫХ ЭЛЕМЕНТОВ
elem.firstChild - выберет первый дочерний элемент внутри elem, ВКЛЮЧАЯ ТЕКСТОВЫЕ узлы.
elem.firstElementChild - выберет первый дочерний узел-элемент внутри elem БЕЗ УЧЕТА ТЕКСТОВЫХ ЭЛЕМЕНТОВ.
elem.lastChild - выберет последний дочерний элемент внутри elem, ВКЛЮЧАЯ ТЕКСТОВЫЕ узлы.
elem.lastElementChild - выберет последний дочерний узел-элемент внутри elem БЕЗ УЧЕТА ТЕКСТОВЫХ ЭЛЕМЕНТОВ.
elem.previousSibling - выберет элемент «слева» от elem (его предыдущего соседа) ВКЛЮЧАЯ ТЕКСТОВЫЕ узлы.
elem.previousElementSibling - выберет узел-элемент «слева» от elem (его предыдущего соседа) БЕЗ УЧЕТА ТЕКСТОВЫХ ЭЛЕМЕНТОВ..
elem.nextSibling - выберет элемент «справа» от elem (его следующего соседа) ВКЛЮЧАЯ ТЕКСТОВЫЕ узлы
elem.nextElementSibling - выберет узел-элемент «справа» от elem (его следующего соседа) БЕЗ УЧЕТА ТЕКСТОВЫХ ЭЛЕМЕНТОВ..

ИНТЕРЕСНО
DOM-коллекции, такие как childNodes и children - псевдомассивы (NodeList), у них нет большинства методов массива.
*/

/**
  |============================
  | Поиск элементов
  |============================
*/
/* 
Итак, мы уже знаем что DOM-элемент - это объект со свойствами и методами. 
Самое время научиться быстро находить элемент по произвольному CSS-селектору. 

Группа методов elem.querySelector* это современный стандарт для поиска элементов. Они позволяют найти элемент или группу элементов по CSS-селектору любой сложности.

element.querySelector(selector);

Используется если необходимо найти только один, чаще всего уникальный элемент.

Возвращает ПЕРВЫЙ найденный элемент внутри element, соответствующий CSS-селектору selector.
Если ничего не найдено, вернет null.
element.querySelectorAll(selector);

Используется если необходимо найти коллекцию элементов, то есть получить массив ссылок на элементы с одинаковым селектором. 
Например, все элементы списка с классом menu-item.

Возвращает псевдомассив всех элементов внутри element, удовлетворяющих CSS-селектору selector.
Если ничего не найдено, вернет пустой массив.




Метод getElementById:
Также позволяет получить єлемент по ID

const title = ducument.getElementById(`title`);
console.log(`title`) // возвращает HTML
console.dir(`title`) // возвращает объект элемента

ВАЖНО !!!!! Метод дает "ЖИВУЮ" коллекцию, обновляемую после создания переменной title




Превращение коллекции NodeList в массив Arr

Вариант 1

const items = document.querySelectorAll(`.js-item`)
console.log(items)    //     NodeList(3) [li.js-item, li.js-item, li.js-item]

const arr = Array.from(items);
console.log(arr)      //     (3) [li.js-item, li.js-item, li.js-item]      //       каждый li.js-item -     объект


Вариант 2

const items = document.querySelectorAll(`.js-item`)
console.log(items)    //     NodeList(3) [li.js-item, li.js-item, li.js-item]
const arr = [...items]
onsole.log(arr)      //     (3) [li.js-item, li.js-item, li.js-item]      //       каждый li.js-item -     объект



*/

/**
  |============================
  | Свойства и атрибуты
  |============================
*/
/* 
Во время построения DOM-дерева, некоторые стандартные HTML-атрибуты становятся свойствами элементов. Посмотрим на несколько часто использующихся свойств.

value - содержит текущий текстовый контент элементов форм.
checked - хранит состояние чекбокса или радиокнопки.
name - хранит значение, указанное в HTML-атрибуте name.
src - путь к изображению тега <img>.


Свойство textContent и value

Свойство textContent
elem.textContent возвращает текстовый контент внутри текстового элемента. 
Доступно для чтения и записи. Не зависимо что будет передано в textContent, данные всегда будут записаны как текст.

Свойство value
elem.value возвращает текстовый контент внутри элемента комуникации с пользователем. 
Доступно для чтения и записи. Не зависимо что будет передано в textContent, данные всегда будут записаны как текст.


Свойство classList
В свойстве classList хранится объект с методами для работы с классами элемента.

elem.classList.contains("cls") - возвращает true или false в зависимости от того, есть ли у элемента класс cls.
elem.classList.add("cls") - добавляет класс cls в список классов элемента.
elem.classList.remove("cls") - удаляет класс cls из списка классов элемента.
elem.classList.toggle("cls") - если класса cls нет, то добавляет его, если есть, наоборот удаляет.
elem.classList.replace("oldClass", "newClass") - заменяет существующий класс oldClass на указанный newClass.




Свойство style
Используется для чтения и изменения инлайновых стилей. Возвращает объект CSSStyleDeclaration, который содержит список всех свойств, определенных только 
во встроенных стилях элемента, а не весь CSS. При записи свойства записываются в camelCase, то есть background-color превращается в element.style.backgroundColor и т. д.

const button = document.querySelector(".btn");

button.style.backgroundColor = "teal";
button.style.fontSize = "24px";
button.style.textAlign = "center";

console.log(button.style); // inline styles object

ИНТЕРЕСНО
На практике стилизация элементов выполняется добавленим CSS-классов. 
Свойство style используется для добавления каких-то динамических стилей, например во время анимации.





Атрибуты
DOM-элементам соответствуют HTML-теги у которых есть текстовые атрибуты. 
Доступ к атрибутам осуществляется при помощи стандартных методов. Эти методы работают со значением, которое находится в HTML.

elem.hasAttribute(name) - проверяет наличие аттрибута, возвращает true или false.
elem.getAttribute(name) - получает значение атрибута и возвращает его.
elem.setAttribute(name, value) - устанавливает атрибут.
elem.removeAttribute(name) - удаляет атрибут.
elem.attributes - свойство, возвращает объект всех атрибутов элемента.




data-атрибуты
Позволяют добавить тегу произвольный атрибут и получить его значение в JavaScript. 
Эту возможность используют для того, чтобы упростить написание кода, например связать данные и разметку по уникальному идентификатору, 
указать тип действия кнопки и т. п.

<button type="button" data-action="save">Save</button>
<button type="button" data-action="close">Close</button>


Для создания атрибута и установки его значения
const btn = document.querySelector(`js-btn`);
btn.setAttribute(`data-btn-id`, `1`)
btn.setAttribute(`data-btn-name`, `click`)


Для получения значения data-атрибута используется свойство dataset, после которого идет имя атрибута. То есть data- отбрасывается, 
а остальное имя записывается как имя свойства объекта.

const saveBtn = document.querySelector('button[data-action="save"]');
console.log(saveBtn.dataset.action); // "save"

const closeBtn = document.querySelector('button[data-action="close"]');
console.log(closeBtn.dataset.action); // "close"

*/

/**
  |============================
  | Создание и удаление элементов
  |============================
*/
/* 
DOM API позволяет не только выбирать или изменять уже существующие, но и удалять, а так же создавать новые элементы, после чего добавлять их в документ.

Создание
document.createElement(tagName);

Создает элемент с именем tagName и возвращает ссылку на него как результат своего выполнения. 
tagName - это строка, указывающая тип создаваемого элемента. Элемент создается в памяти, в DOM его еще нет.

const heading = document.createElement("h1");
console.log(heading); // <h1></h1>

heading.textContent = "This is a heading";
console.log(heading); // <h1>This is a heading</h1>

const image = document.createElement("img");
image.src = "https://placeimg.com/640/480/nature";
image.alt = "Nature";
console.log(image); // <img src="https://placeimg.com/640/480/nature" alt="Nature" />






Добавление
Чтобы созданный элемент был отображен на странице, его необходимо добавить к уже существующему элементу в DOM-дереве. 
Допустим, что добавляем в некий элемент element, для этого есть методы.

element.append(el1, el2, ...) - добавляет один или несколько элементов после всех детей элемента element.
element.prepend(el1, el2, ...) - добавляет один или несколько элементов перед всеми детьми элемента element.
element.after(el1, el2, ...) - добавляет один или несколько элементов после элемента element.
element.before(el1, el2, ...) - добавляет один или несколько элементов перед элементом element.
Во всех этих методах, el это элементы или строки, в любом сочетании и количестве. Строки добавляются как текстовые узлы.

ИНТЕРЕСНО
Если элемент для вставки уже находится в DOM, то он изымается из своего старого места и добавляется в новое. 
Отсюда вытекает правило - один и тот же элемент не может быть одновременно в двух местах.

const list = document.querySelector(".usernames");

// Adds an item to the end of the list
const lastItem = document.createElement("li");
lastItem.textContent = "Poly";
list.append(lastItem);

// Adds an item to the beginning of the list
const firstItem = document.createElement("li");
firstItem.textContent = "Ajax";
list.prepend(firstItem);

// Adds a title before the list
const title = document.createElement("h2");
title.textContent = "USERNAMES";
list.before(title);

// Adds a paragraph after the list
const text = document.createElement("p");
text.textContent =
  "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Nostrum tenetur assumenda fugiat maxime, soluta aspernatur quasi nihil in asperiores ad distinctio illo et debitis error iure voluptate numquam maiores nisi. Lorem ipsum dolor sit amet, consectetur adipisicing elit. Nostrum tenetur assumenda fugiat maxime, soluta aspernatur quasi nihil in asperiores ad distinctio illo et debitis error iure voluptate numquam maiores nisi!";
list.after(text);




Удаление
elem.remove();

Для того, чтобы удалить элемент используется метод remove(). Он вызывается на самом элементе elem, который необходимо удалить
const text = document.querySelector('.text');
text.remove();




Оптимизация работы с DOM
Современные браузеры стараются оптимизировать процесс отрисовки страницы без вмешательства разработчика. 
Тем не менее, изменение DOM-дерева это дорогая операция, поэтому необходимо стараться минимизировать количество обращений к DOM.

Repaint - происходит, когда изменения затронули стили влияющие на внешний вид элемента, но не на геометрию. 
Например opacity, background-color, visibility и outline. Браузер отрисовывает элемент заново, с учётом нового стиля. 
Также проверяется видимость других элементов, один или более могут оказаться скрыты под изменившим внешний вид.

Reflow - происходит когда изменения затрагивают содержимое, структуру документа, положение элементов. 
Идет пересчет позиционирования и размеров, что ведет к перерисовке части или всего документа. 
Изменение размера одного родительского контейнера повлияет на всех его детей и предков. 
Имеет значительно большее влияние на производительность, чем repaint.

Все вышеперечисленные операции блокируют браузер. Страница не может выполнять никакие другие операции в то время, когда происходит reflow или repaint. 

Причинами могут быть:

Манипуляции с DOM (добавление, удаление, изменение, перестановка элементов)
Изменение содержимого, в т.ч. текста в полях форм
Расчёт или изменение CSS-свойств
Добавление и удаление таблиц стилей
Манипуляции с атрибутом class
Манипуляции с окном браузера (изменения размеров, прокрутка)
Активация псевдоклассов (например :hover)
*/

/**
  |============================
  | Свойство innerHTML
  |============================
*/
/* 
Еще один способ создать DOM-элементы и поместить их в дерево - это использовать строки с тегами и позволить браузеру сделать всю тяжелую работу. 
У такого подхода есть свои плюсы и минусы.




Чтение
Свойство innerHTML хранит содержимое элемента, включая теги, в виде строки. Возвращаемое значение это всегда валидный HTML-код.

const article = document.querySelector(".article");
console.log(article.innerHTML);

const title = document.querySelector(".article .title");
console.log(title.innerHTML);

const text = document.querySelector(".article .text");
console.log(text.innerHTML);

const link = document.querySelector(".article .link");
console.log(link.innerHTML);




Изменение
Свойство innerHTML доступно как для чтения, так и для записи. Если записать в него строку с HTML-тегами, то браузер во время парсинга строки 
превратит их в валидные элементы и добавит в DOM-дерево.

const title = document.querySelector(".article .title");
title.innerHTML = 'New and <span class="accent">improved</span> title';


ИНТЕРЕСНО
Если в свойство innerHTML записать пустую строку, то содержимое элемента будет очищено. Это простой и быстрый способ удаления всего содержимого.



При таком подходе, в отличии от document.createElement(), мы не получаем ссылку на созданный DOM-элемент. 
Это первый шаг на пути к шаблонизации - создания большого количества однотипной разметки с разными данными по заранее определённому шаблону. 
Например, как в списке товаров интернет магазина и т. п.

Однотипная (шаблонная) разметка создается из массива данных. Приём заключается в переборе этого массива и составлении одной строки с HTML тегами, 
которую потом записываем в innerHTML элемента.

const technologies = ["HTML", "CSS", "JavaScript", "React", "Node"];
const list = document.querySelector(".list");

const markup = technologies
  .map((technology) => `<li class="list-item">${technology}</li>`)
  .join("");

// Check the console, you'll see a single string with HTML tags
console.log(markup);

// Adding all the markup in one operation
list.innerHTML = markup;


Добавление
Изменение elem.innerHTML полностью удалит и пересоздаст всех потомков элемента elem. 
Если элемент изначально не пустой, то будут дополнительные затраты на сериализацию уже существующей разметки, а это плохо.

const article = document.querySelector(".article");
const htmlString = `<p class="article-text">Nullam quis ante. Vestibulum dapibus nunc ac augue. In consectetuer turpis ut velit.</p>
   <a class="link" href="#">Read more...</a>`;

// Replace += with = operator. See the difference? 
// Article title is lost because we overwrite element content.
article.innerHTML += htmlString;


ИНТЕРЕСНО
Используйте свойство elem.innerHTML для добавления только в случае когда элемент elem пустой или если надо полностью заменить его содержимое.


СПОСОБ 
добавления контента в конец HTML 

container.innerHTML += li





Метод insertAdjacentHTML()
Современный метод для добавления строки с HTML-тегами до, после или внутрь элемента. Решает проблему innerHTML с повторной сериализацией содержимого элемента 
при добавлении разметки к уже существующей.

elem.insertAdjacentHTML(position, string);

Аргумент position - это строка, позиция относительно элемента elem. Принимает одно из четырёх значений.

"beforebegin" - перед elem
"afterbegin" - внутри elem, перед всеми детьми
"beforeend" - внутри elem, после всех детей
"afterend" - после elem

const list = document.querySelector(".list");

const newTechnologies = ["React", "TypeScript", "Node.js"];
const markup = newTechnologies
  .map((technology) => `<li class="list-item new">${technology}</li>`)
  .join("");

list.insertAdjacentHTML("beforeend", markup);
list.insertAdjacentHTML("beforebegin", "<h2>Popular technologies</h2>");


ИНТЕРЕСНО
"beforebegin" и "afterend" работают только в том случае, если elem уже находится в DOM-дереве.
*/

/**
  |============================
  | Подключение скриптов
  |============================
*/
/* 
Загрузка и выполнение скрипта указанного в теге <script> без каких-либо атрибутов, блокируют обработку HTML-документа и построение DOM. Это проблема.

<script src="path-to-script.js"></script>

Когда анализатор встречает такой тег, обработка HTML-документа приостанавливается и начинается загрузка файла скрипта указанного в атрибуте src. 
После загрузки скрипт выполняется, и только потом возобновляется обработка HTML. Это называется «блокирующий» скрипт.

Атрибуты defer и async были введены чтобы дать разработчикам возможность лучше контролировать как загружать скрипты и когда именно их выполнять.

Атрибут defer
<script defer src="path-to-script.js"></script>

Атрибут defer указывает браузеру загружать файл скрипта в фоновом режиме, паралельно обработке HTML-документа и построению DOM. 
Скрипт будет выполнен только после того как HTML-документ обработан, а DOM построен. 
Такие скрипты не блокируют построение DOM-дерева и гарантированно выполняются в том порядке, в котором указаны в HTML-документе.

https://textbook.edu.goit.global/javascript-yk5evp/v2/img/lesson-11/defer.png


Атрибут async
<script async src="path-to-script.js"></script>

Загрузка скрипта с атрибутом async не блокирует построение DOM, но он выполняется сразу после загрузки. 
Это значит, что такие скрипты могут заблокировать построение DOM, и выполняются в произвольном порядке.

https://textbook.edu.goit.global/javascript-yk5evp/v2/img/lesson-11/async.png


*/

/**
  |============================
  | События
  |============================
*/
/* 
Событие это сигнал от браузера о том, что на веб-странице что-то произошло. 
События используются для реакции на действия пользователя и исполнения кода связанного с определенным событием. 
Существует много видов событий: мыши, клавиатуры, элементов форм, загрузки изображений, буфера обмена, изменение стадии CSS анимации или перехода, 
изменение размеров окна и много других.

Одно действие может вызывать несколько событий. Например, клик вызывает сначала mousedown, а затем mouseup и click. 
В тех случаях, когда одно действие генерирует несколько событий, их порядок фиксирован. То есть, обработчики вызовутся в порядке mousedown → mouseup → click.

Для того, чтобы элемент реагировал на действия пользователя, ему необходимо добавить слушателя (обработчик) события. 
То есть функцию, которая будет вызвана, как только событие произошло.




Метод addEventListener()
Добавляет слушателя события на элемент.

element.addEventListener(event, handler, options);

event - имя события, строка, например "click".
handler - коллбэк-функция которая будет вызвана при наступлении события.
options - необязательный объект параметров с расширенными настройками.
const button = document.querySelector(".my-button");

button.addEventListener("click", () => {
  console.log("Button was clicked");
});



ВАЖНО !!!!!!
использовать в качестве колбека именованную функцию, чтобы ее можно было отозвать !!!!!!
button.addEventListener("click", handleClick);



Для коллбэка можно (и желательно) использовать отдельную функцию и передавать на неё ссылку. Именованная функция повышает читаемость кода.

const button = document.querySelector(".my-button");

const handleClick = () => {
  console.log("Button was clicked");
};

button.addEventListener("click", handleClick);

На одном элементе может быть сколько угодно обработчиков событий, даже событий одного типа. Коллбэк-функции будут вызываться в порядке регистрации их в коде.

const multiBtn = document.querySelector("#multiple");

const firstCallback = () => {
  console.log("First callback!");
};
const secondCallback = () => {
  console.log("Second callback!");
};
const thirdCallback = () => {
  console.log("Third callback!");
};

multiBtn.addEventListener("click", firstCallback);
multiBtn.addEventListener("click", secondCallback);
multiBtn.addEventListener("click", thirdCallback);




Метод removeEventListener()
Удаляет слушателя события с элемента. Аргументы аналогичны методу addEventListener().

element.removeEventListener(event, handler, options);

Для удаления нужно передать ссылку именно на ту коллбэк-функцию, которая была назначена в addEventListener(). 
В таком случае для коллбэков используют отдельную функцию и передают её по имени (ссылку).

const addListenerBtn = document.querySelector('.js-add');
const removeListenerBtn = document.querySelector('.js-remove');
const btn = document.querySelector(".target-btn");

const handleClick = () => {
  console.log("click event listener callback");
};

addListenerBtn.addEventListener("click", () => {
  btn.addEventListener("click", handleClick);
  console.log("click event listener was added to btn");
});

removeListenerBtn.addEventListener("click", () => {
  btn.removeEventListener("click", handleClick);
  console.log("click event listener was removed from btn");
});




Ключевое слово this
Если коллбэком будет функция которая использует this, по умолчанию контекст внутри неё будет ссылаться на DOM-элемент на котором висит слушатель.

const mango = {
  username: "Mango",
  showUsername() {
    console.log(this);
    console.log(`My username is: ${this.username}`);
  },
};

const btn = document.querySelector(".js-btn");

// ✅ Работает
mango.showUsername();

// ❌ this будет ссылаться на button если использовать showUsername как callback
btn.addEventListener("click", mango.showUsername); // не работает

// ✅ Не забывайте привязывать контекст методов объекта
btn.addEventListener("click", mango.showUsername.bind(mango));
*/

/**
  |============================
  | Объект события
  |============================
*/
/* 
Чтобы обработать событие, недостаточно знать о том, что это клик или нажатие клавиши, могут понадобиться детали. 
Например текущее значение текстового поля, элемент, на котором произошло событие, встроенные методы и другое.

Каждое событие представляет собой объект, который содержит информацию о деталях события и автоматически передается первым аргументом в обработчик события. 
Все события происходят от базового класса Event.

const handleClick = event => {
  console.log(event);
};

button.addEventListener("click", handleClick);

Параметр event это и есть обьект события, который автоматически передается первым аргументом при вызове коллбэк функции. 
Мы можем называть его как угодно, но обычно его объявляют как e, evt или event.

Некоторые свойства объекта события:

event.type - тип события.
event.currentTarget - элемент, на котором выполняется обработчик события.

-------------------------------
const button = document.querySelector(".btn");

const handleClick = (event) => {
  console.log("event: ", event);
  console.log("event type: ", event.type);
  console.log("currentTarget: ", event.currentTarget);
};

button.addEventListener("click", handleClick);
-------------------------------



Действия браузера по умолчанию
Некоторые события вызывают действие браузера встроенное по умолчанию как реакция на определенный тип события. 
Например клик по ссылке инициирует переход на новый адрес, указанный в href, а отправка формы перезагружает страницу. 
Чаще всего это поведение нежелательно и его необходимо отменить.

Для отмены действия браузера по умолчанию на объекте события есть стандартный метод preventDefault().


const form = document.querySelector(".register-form");

form.addEventListener("submit", (event) => {
  event.preventDefault();
  const {
    elements: { username, password }
  } = event.currentTarget;
  console.log(username.value, password.value);
});
*/

/**
  |============================
  | События клавиатуры
  |============================
*/
/* 
Есть два основных события клавиатуры: keydown и keyup. В отличии от других, события клавиатуры обрабатываются на документе, а не на конкретном элементе. 
Объекты событий клавиатуры происходят от базового класса KeyboardEvent.

document.addEventListener("keydown", event => {
  console.log("Keydown: ", event);
});

document.addEventListener("keyup", event => {
  console.log("Keyup: ", event);
});

При нажатии клавиши сначала происходит keydown, после чего keyup, когда клавишу отжали. На практике, в основном обрабатывают только событие keydown, 
так как оно происходит быстрее чем keyup и пользователь раньше видит результат нажатия. События keydown и keyup срабатывают при нажатии любой клавиши, 
включая служебные (Ctrl, Shift, Alt, Escape и другие).

ИНТЕРЕСНО
Раньше было еще одно событие клавиатуры - keypress. Многие посты на форумах и блогах по-прежнему могут его использовать, но будьте осторожны - 
оно устарело и поддержка в новых браузерах может прекратиться в любой момент.




Свойства key и code
Свойство key возвращает символ сгенерированный нажатием клавиши, принимая во внимание состояние клавиш модификаторов, например Shift, а так же текущий язык. 
Свойство code возвращает код физической клавиши на клавиатуре и не изменяется между языками.

document.addEventListener("keydown", event => {
  console.log("key: ", event.key);
  console.log("code: ", event.code);      //       Чаще всего нужно использовать свойство code
});




Клавиши-модификаторы
Для обработки комбинации клавиш, например Ctrl + s или любую другую, на объекте события есть свойства ctrlKey, altKey, shiftkey и metaKey, 
хранящие булевое значение сигнализирующее о том, была зажата клавиша-модификатор или нет.

document.addEventListener("keydown", event => {
  event.preventDefault();

  if ((event.ctrlKey || event.metaKey) && event.code === "KeyS") {
    console.log("«Ctrl + s» or «Command + s» combo");
  }
});

Некоторые комбинации клавиш могут конфликтовать с поведением браузера по умолчанию. 
Например, Ctrl + d или Command + d делает закладку. Нужно стараться проектировать систему комбинаций страницы так, чтобы она не пересекалась 
со встроенной в браузер. Но, в крайнем случае, поведение по умолчанию можно отменить вызвав метод event.preventDefault().

ИНТЕРЕСНО
Не так давно, вместо свойств key и code использовали свойство keyCode. Многие посты на форумах и блогах по-прежнему могут использовать его, 
но будьте осторожны - оно устарело, не используйте свойство keyCode.



Switch при работе с событиями клавиатуры
document.addEventListener("keydown", handlerKey)

function handlerKey(evt) {
  switch (evt.code) {
    case "ArrowLeft":
    alert("Left")
    break;
    case "ArrowRight"
    break;
  }
}

*/

/**
  |============================
  | События элементов форм
  |============================
*/
/* 
Событие submit
Отправка формы происходит при клике по кнопке с атрибутом type="submit" или нажатии клавиши Enter, находясь в каком-нибудь её текстовом поле. 
Событие submit можно применить для валидации (проверки) формы перед отправкой, так как на объекте события есть много полезных свойств связанных 
с элементами формы. Сабмит формы перезагружает страницу, поэтому не забывайте отменять действие по умолчанию методом preventDefault().


const registerForm = document.querySelector(".form");

registerForm.addEventListener("submit", handleSubmit);

function handleSubmit(event) {
  event.preventDefault();
  const form = event.currentTarget;
  const login = form.elements.login.value;
  const password = form.elements.password.value;
  
  if (login === "" || password === "") {
    return console.log("Please fill in all the fields!");
  }

  console.log(`Login: ${login.value}, Password: ${password.value}`);
  form.reset();
}

ИНТЕРЕСНО
Свойство elements DOM-элемента формы содержит обьект со ссылками на все её элементы у которых есть атрибут name. 
Поэтому в примере мы получаем значение полей обращаясь к login.value и password.value.



FormData
FormData это объект, представляющий данные HTML формы.

function handlerSubmit(evt){
  evt.preventDefault();
  const formData = new FormData(evt.currentTarget)
  const data = {};

  formData.forEach((value, key) => {
    data[key] = value
  })

  console.log(data)           //       email - email@gmail.com     password - qwerty
 
  console.log(formData)       //       FormData {} [[Prototype]]: FormData   //    Здесь на прототипе есть разные методы (get, getAll ...)
}





Событие change
Происходит после изменения элемента формы. Для текстовых полей или textarea событие произойдёт не при каждом вводе символа, а при потере фокуса, 
что не всегда удобно. Например, пока вы набираете что-то в текстовом поле - события нет, но как только фокус пропал, произойдет событие change. 
Для остальных элементов, например select, чекбоксов и радио-кнопок, событие change срабатывает сразу при выборе значения.

const select = document.querySelector(".pizza-select");
const textOutput = document.querySelector(".text-output");
const valueOutput = document.querySelector(".value-output");

select.addEventListener("change", setOutput);

function setOutput(event) {
  const selectedOptionValue = event.currentTarget.value;
  const selectedOptionIndex = event.currentTarget.selectedIndex;
  const selectedOptionText =
    event.currentTarget.options[selectedOptionIndex].text;

  textOutput.textContent = selectedOptionText;
  valueOutput.textContent = selectedOptionValue;
}


ИНТЕРЕСНО
Обратите внимание на полезные свойства при работе с элементом <select> в примере. Разберитесь что хранится в свойствах value, selectedIndex и options.




Событие input
Происходит только на текстовых полях и textarea, и создаётся каждый раз при изменении значения элемента, не дожидаясь потери фокуса. 
На практике input это самое главное событие для работы с текстовыми полями формы.


const textInput = document.querySelector(".text-input");
const output = document.querySelector(".output");

textInput.addEventListener("input", (event) => {
  output.textContent = event.currentTarget.value;
});




События focus и blur
Элемент получает фокус при клике мыши или переходе клавишей Tab. Момент получения фокуса и потери очень важен, при получении фокуса мы можем 
подгрузить данные для автозаполнения, начать отслеживать изменения и т. п. При потере фокуса - проверить введённые данные.

При фокусировке элемента происходит событие focus, а когда фокус исчезает, например пользователь кликает в другом месте экрана, происходит событие blur. 
Активировать или отменить фокус можно программно, вызвав в коде одноименные методы focus() и blur() у элемента.

const textInput = document.querySelector(".text-input");
const setFocusBtn = document.querySelector('[data-action="set"]');
const removeFocusBtn = document.querySelector('[data-action="remove"]');

setFocusBtn.addEventListener("click", () => {
  textInput.focus();
});

removeFocusBtn.addEventListener("click", () => {
  textInput.blur();
});

textInput.addEventListener("focus", () => {
  textInput.value = "This input has focus";
});

textInput.addEventListener("blur", () => {
  textInput.value = "";
});

Фокус может быть только на одном элементе страницы в единицу времени и текущий элемент, на котором фокус, доступен как document.activeElement.

ИНТЕРЕСНО
Многие элементы не могут получить фокус. Например, если кликнуть по <div>, то фокусировка на нем не произойдет, потому что это не интерактивный элемент.

*/

/**
  |============================
  | Распространение событий
  |============================
*/
/* 
Распространение событий (event propagation) - это термин описывающий жизненный цикл события, который включает в себя три этапа: 
погружение, таргетинг и всплытие. На практике чаще всего используют только фазу всплытия.

При наступлении события, оно проходит через три обязательные фазы:

Capturing phase (погружение) - событие начинается на window и тонет (проходит через все элементы-предки) до самого глубокого целевого элемента 
на котором произошло действие, например клик.
Target phase (таргетинг) - событие дошло до целевого элемента. Этот этап включает только уведомление элемента о том, что на нём произошло действие.
Bubbling phase (всплытие) - заключительная фаза, событие всплывает от самого глубокого, целевого элемента, через все элементы-предки до window.

ИНТЕРЕСНО
Распространение часто неправильно используется как синоним стадии всплытия. Каждый раз, когда происходит событие, происходит его распространение.
*/

/**
  |============================
  | Всплытие событий
  |============================
*/
/* 
При наступлении события, обработчики сначала срабатывают на самом вложенном элементе, затем на его родителе, затем выше и так далее, 
вверх по цепочке вложенности. Этот процесс называется всплытием (event bubbling), потому что события «всплывают» от внутреннего элемента 
вверх через всех предков до window, подобно тому, как всплывает пузырек воздуха в воде.

Рассмотрим пример, так будет понятнее. Есть три вложенных тега <div> с обработчиками клика на каждом из них.

<div id="parent">
  Parent
  <div id="child">
    Child
    <div id="descendant">Descendant</div>
  </div>
</div>


const parent = document.querySelector("#parent");
const child = document.querySelector("#child");
const descendant = document.querySelector("#descendant");

parent.addEventListener("click", () => {
  console.log("Parent click handler");
});

child.addEventListener("click", () => {
  console.log("Child click handler");
});

descendant.addEventListener("click", () => {
  console.log("Descendant click handler");
});

// Descendant click handler
// Child click handler
// Parent click handler

Всплытие гарантирует, что клик по #descendant вызовет обработчик клика, если он есть, сначала на самом #descendant, 
затем на элементе #child, далее на элементе #parent и так далее вверх по цепочке предков до window. 
Поэтому, если в примере кликнуть на #descendant, то последовательно выведутся alert для descendant → child → parent.

ИНТЕРЕСНО
Всплывают почти все события, например события focus и blur не всплывают, поэтому сущестуют их всплывающие аналоги - focusin и focusout.





Свойство event.target
Не зависимо от того где мы поймали событие во время его всплытия, всегда можно узнать где конкретно оно произошло. 
Самый глубокий элемент, который вызывает событие, называется целевым или исходным и доступен как event.target.

event.target - это ссылка на исходный элемент на котором произошло событие, в процессе всплытия он неизменен.
event.currentTarget - это ссылка на текущий элемент до которого дошло всплытие, на нём сейчас выполняется обработчик события.
Если слушатель события зарегистрирован на самом верхнем элементе, то он «поймает» все клики внутри, потому что события будут 
всплывать до этого элемента. Откройте консоль в примере и покликайте, event.target это всегда исходный (и самый глубокий) 
элемент на котором был сделан клик, а event.currentTarget не меняется.

<div id="parent">
  Parent
  <div id="child">
    Child
    <div id="descendant">Descendant</div>
  </div>
</div>


const parent = document.querySelector("#parent");

parent.addEventListener("click", (event) => {
  console.log("event.target: ", event.target);
  console.log("event.currentTarget: ", event.currentTarget);
});


event.target:  <div id=​"descendant">​Descendant​</div>​
event.currentTarget:  <div id=​"parent">​…​</div>​
event.target:  <div id=​"child">​…​</div>​
event.currentTarget:  <div id=​"parent">​…​</div>​
event.target:  <div id=​"parent">​…​</div>​
event.currentTarget:  <div id=​"parent">​…​</div>​
​




Прекращение всплытия
Обычно событие будет всплывать наверх до элемента window, вызывая все обработчики на своем пути. Но любой промежуточный обработчик может решить, 
что событие полностью обработано и остановить всплытие вызвав метод stopPropagation().

<div id="parent">
  Parent
  <div id="child">
    Child
    <div id="descendant">Descendant</div>
  </div>
</div>

const parent = document.querySelector("#parent");
const child = document.querySelector("#child");
const descendant = document.querySelector("#descendant");

parent.addEventListener("click", () => {
  alert(
    "Parent click handler. This alert will not appear when clicking on Descendant, the event will not reach here!"
  );
});

child.addEventListener("click", () => {
  alert(
    "Child click handler. This alert will not appear when clicking on Descendant, the event will not reach here!"
  );
});

descendant.addEventListener("click", (event) => {
  event.stopPropagation();
  alert("Descendant click handler");
});



Если у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены. 
То есть, метод stopPropagation() только препятствует продвижению события дальше. Если необходимо полностью остановить 
обработку события, используется метод stopImmediatePropagation(). Он не только предотвращает всплытие, но и останавливает 
обработку событий на текущем элементе.

ИНТЕРЕСНО
Не прекращайте всплытие без необходимости. Прекращение всплытия создаёт свои подводные камни, которые потом приходится обходить. 
Например, аналитика использует всплытие чтобы отслеживать события на странице.
*/

/**
  |============================
  | Делегирование событий
  |============================
*/
/* 
Всплытие позволяет реализовать один из самых полезных приёмов - делегирование событий (event delegation). 
Он заключается в том, что если есть группа элементов, события которых нужно обрабатывать одинаково, то добавляется один обработчик на их общего предка, 
вместо того чтобы добавлять обработчик каждому элементу. 
Используя свойство event.target можно получить ссылку на целевой элемент, понять на каком именно потомке произошло событие и обработать его.

Рассмотрим делегирование на примере. 
Создаем элемент <div>, добавляем в него произвольное количество кнопок, например 100, и регистриуем каждой из них слушателя события клика 
с функцией handleButtonClick .

Проблема в том, что у нас есть сто слушателей событий. Все они указывают на одну и ту же функцию слушателя, но самих слушателей 100. 
Что если мы переместим всех слушателей на общего предка, элемент <div>?

Теперь есть только один обработчик события клика и браузеру не нужно хранить в памяти сто различных слушателей. 

То есть делегирование сводится к трём простым шагам:

1. Определить общего предка группы элементов для отслеживания событий.
2. Зарегистрировать на элементе-предке обработчик события которое мы хотим отлавливать от группы элементов.
3. В обработчике использовать event.target для выбора целевого элемента.
Такой подход упрощает инициализацию слушателей однотипных элементов. Можно добавлять, удалять или изменять элементы, при этом не нужно вручную 
добавлять или удалять обработчики событий.


Палитра цветов
Будем делать палитру цветов с возможностью выбрать цвет при клике и отображением выбранного цвета. 
Вместо того, чтобы назначать обработчик каждому элементу палитры, которых может быть очень много, повесим один слушатель 
на общего предка div.color-palette. В обработчике события клика используем event.target, чтобы получить элемент на котором произошло событие 
и связанный с ним цвет, который будем хранить в атрибуте data-color.

<p class="output">Selected color: -</p>
<div class="color-palette"></div>


const colorPalette = document.querySelector(".color-palette");
const output = document.querySelector(".output");

colorPalette.addEventListener("click", selectColor);

function selectColor(event) {
  if (event.target.nodeName !== "BUTTON") {
    return;
  }

  const selectedColor = event.target.dataset.color;
  output.textContent = `Selected color: ${selectedColor}`;
  output.style.color = selectedColor;
}

// Some helper functions to render palette items
createPaletteItems();

function createPaletteItems() {
  const items = [];
  for (let i = 0; i < 60; i++) {
    const color = getRandomHexColor();
    const item = document.createElement("button");
    item.type = "button";
    item.dataset.color = color;
    item.style.backgroundColor = color;
    item.classList.add("item");
    items.push(item);
  }
  colorPalette.append(...items);
}

function getRandomHexColor() {
  const letters = "0123456789ABCDEF";
  let color = "#";

  for (let i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random() * 16)];
  }

  return color;
}



ИНТЕРЕСНО
Обязательно проверяем цель клика, чтобы это точно была кнопка, мы не хотим обрабатывать клики в элемент-контейнер. 
Для проверки типа элемента можно испотльзовать свойство nodeName. nodeName - это тип HTML элемента ("DIV", "BUTTON" и т.п.)
if (event.target.nodeName !== "BUTTON") {
    return;

Еще вариант не обрабатывать клики в контейнер:
if(evt.target === evt.currentTarget) {
  return;
}

Еще вариант не обрабатывать клики в контейнер:
if(evt.target.classList.contains("js-box") {
  return;
}


ИНТЕРЕСНО
Как сделать дилигирование из любого элемента в div (например, чтобы в карточке для перенаправления по ссылке можно было кликнуть по
любому элементу - тексу, изображению, заголовку и т. д.)

function handlerClick(evt) {
  if(evt.target === evt.currentTarget) {
  return; }
  const currentProduct = evt.target.closest("js-product-item")

} 

*/

/**
  |============================
  | Throttle і Debounce
  |============================
*/
/* 
Довольно часто необходимо обработать изменение размера окна, скролл, перемещение мыши или текстовый ввод пользователя. 
Это может быть сортировка коллекции и отрисовка результатов, анимация элемента, манипуляции с DOM-деревом и прочее. 
Все это улучшает UX (user experience), но, к сожалению, даёт большую нагрузку на браузер из-за того, что обработчики 
событий срабатывают слишком часто. Такие события неофициально называют «chatty events».

Например, если добавить слушателя события на скролл, то при прокрутке страницы мышкой можно вызвать около 30 событий в секунду. 
Медленная прокрутка (свайп) в смартфоне может вызвать до 100 событий в секунду. Если обработчик события скролла выполняет 
тяжелые вычисления и другие DOM-манипуляции, гарантированно будут проблемы с производительностью.

Throttle и Debounce - это два похожих, но разных по поведению приёма, позволяющих контролировать сколько раз мы разрешаем 
выполнение функции с течением времени. Используем их реализацию из библиотеки Lodash.






Подключение библиотеки
CDN (Content Delivery Network) - это географически распределённая сетевая инфраструктура, обеспечивающая быструю доставку 
контента пользователям веб-сервисов и сайтов. Входящие в состав CDN cерверы географически располагаются таким образом, 
чтобы сделать время ответа для пользователей сайта/сервиса минимальным.

Подключим в проект библиотеку Lodash через CDN. Для этого используем сервис cdnjs.com и добавим ссылку на скрипт 
библиотеки в конец HTML-документа, как показано в примере.


index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Document title</title>
  </head>
  <body>
    <!-- HTML-markup -->

    <!----------------- Lodash library script file adding start ----------------->
    <script
      async
      src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"
      integrity="sha512-WFN04846sdKMIP5LKNphMaWzU7YpMyCU245etK3g/2ARYbPK9Ub18eG+ljU96qKRCWh+quCY7yefSmlkQw1ANQ=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <!----------------- Lodash library script file adding end ----------------->
    <!-- Your script file -->
    <script defer src="path/to/script.js"></script>
  </body>
</html>



Теперь мы можем получить доступ к библиотеке в нашем скрипте. 
При подключении библиотек через CDN, на объект window добавляется свойство в котором хранится то, 
что предоставляет библиотека. Имя этого свойства уникально для библиотеки и описано в её документации. 
Для Lodash это символ нижнего подчёркивания _. Для проверки используем метод add, который просто складывает два числа.

script.js

const result = _.add(2, 3);
console.log(result); // 5
*/

/**
  |============================
  | Throttle
  |============================
*/
/* 
Прием throttle контролирует количество раз которое функция может быть вызвана в течение промежутка времени. 
То есть позволяет вызывать функцию не чаще чем один раз в N миллисекунд, гарантируя ее регулярное выполнение.

Используя throttle мы не контролируем, как часто браузер будет генерировать события. Мы всего-лишь берем контроль 
над частотой выполнения функции обработчика события.


document.addEventListener(
  "scroll",
  _.throttle(() => {
    console.log("Scroll handler call every 300ms");
  }, 300)
);


Реализация из библиотеки Lodash ожидает первым аргументом функцию которую необходимо «затормозить», 
а вторым количество миллисекунд. Возвращает новую функцию для передачи в слушатель события.
*/

/**
  |============================
  | Debounce
  |============================
*/
/* 
Прием debounce гарантирует, что функция будет вызвана только если между событиями будет пауза в N миллисекунд. 
Например, пока пользователь скролит страницу функция не вызовется, но как только он перестал скролить, функция будет вызвана через 
300 миллисекунд. Если скролл возобновится раньше чем через 300 миллисекунд после паузы, функция не вызовется.

Используя debounce мы не управляем тем как часто браузер будет генерировать события, а всего-лишь берем контроль над частотой 
выполнения функции обработчика события.

document.addEventListener(
  "scroll",
  _.debounce(() => {
    console.log("Scroll handler call after 300ms pause");
  }, 300)
);

Реализация из библиотеки Lodash ожидает первым аргументом функцию, а вторым количество миллисекунд. 
Возвращает новую функцию для передачи в слушатель события.




Режимы метода debounce
По умолчанию метод debounce работает в режиме когда функция вызывается через N миллисекунд после паузы между потоками событий. 
Этот режим называется trailing edge (в конце). Есть задачи когда функцию надо вызвать сразу при наступлении первого события в потоке, 
а потом игнорировать все последующие события, до паузы между ними, например в 300 миллисекунд. На старте следующего потока событий 
это поведение повторяется. Такой режим называется leading edge (в начале).


Методу debounce библиотеки Lodash можно передать необязательный третий аргумент - обьект параметров в котором есть два свойства 
leading (по умолчанию false) и trailing (по умолчанию true). Эти настройки изменяют режим и указывают, должна ли функция запускаться 
в начале потока событий или в конце после паузы.

document.addEventListener(
  "scroll",
  _.debounce(
    () => {
      console.log("Scroll handler call on every event stream start");
    },
    300,
    {
      leading: true,
      trailing: false,
    }
  )
);


На практике режим leading может применяться например в случае когда необходимо выполнить функцию отправки запроса на сервер 
при первом клике кнопки, после чего игнорировать все послудующие клики до паузы. 
*/

/**
  |============================
  | Отложенная загрузка
  |============================
*/
/* 
Веб-страницы содержат большое количество изображений, которые раздувают размер страниц и влияют на скорость их загрузки. 
Большинство изображений находятся за пределами первого экрана (за кадром, below the fold), поэтому пользователь увидит их 
только после того как прокрутит страницу. Это значит, что вы возможно загружаете то, что пользователь никогда не увидит, 
но потратит на это время и возможно деньги. Загрузка некритического контента также тратит батарею мобильных устройств и 
другие системные ресурсы.

Термины «above the fold» (в кадре) и «below the fold» (за кадром) пришли из времен до появления цифровых технологий. 
Если вы когда-либо покупали газету в киоске, их обычно складывают пополам, чтобы прохожие могли видеть только верхнюю 
половину первой страницы. Если им не понравится то, что они увидят, они пройдут мимо, и продажи упадут. Вот почему так 
важно размещать наиболее интересный контент в верхней части страницы.



Отложенная загрузка (lazy-loading) - это приём, который откладывает загрузку некритических ресурсов во время загрузки страницы. 
Вместо этого, эти некритические ресурсы загружаются только по необходимости. Это снижает начальный вес ресурсов которые 
необходимо загрузить для отображения страницы, использование системных ресурсов, повышает время её загрузки и последущего 
рендера. Все это положительно сказывается на производительности.

Вы, наверное, уже видели в действии ленивую загрузку. Она выглядит примерно так:

- Вы попадаете на страницу и начинаете прокручивать её по мере чтения содержимого.
- В какой-то момент вы прокручиваете страницу до изображения-заглушки.
- Изображение-заглушка внезапно заменяется настоящим изображением.




Атрибут loading
Раньше разработчикам приходилось полагаться только на возможности JavaScript. Современные браузеры умеют делать это без 
JavaScript, но, к сожалению, не все. HTML-атрибут loading тега <img> поддерживается нативно во всех современных браузерах
кроме Safari и позволяет браузеру отложить загрузку закадровых изображений до тех пор, пока пользователь не прокрутит до 
них страницу.

<img src="my-image.jpg" loading="lazy" alt="Image description" />


Поддерживает три значения:

lazy - браузер выполнит отложенную загрузку изображения.
eager - изображение будет загружено при первой возможности, то есть без отложенной загрузки.
auto - браузер сам определяет, выполнять отложенную загрузку или нет. Значение по умолчанию.

Мы не можем узнать или изменить поведение и механизм определения времени отложенной загрузки изображения браузером. 
Главное, что браузер загрузит такие изображения незадолго до того, как они попадут в область просмотра.

Откройте вкладку Network в инструментах разработчика и выберите фильтр Img, чтобы отображалась только загрузка изображений. 
После этого прокручивайте пример и наблюдайте как будут догружаться закадровые изображения котов. 
Браузеры поддерживающие атрибут loading будут загружать изображения отложенно, а браузеры без поддержки загрузят все изображения сразу.

https://www.edu.goit.global/ru/learn/11043835/2294/2301/textbook

*/

/**
  |============================
  | Библиотека lazysizes
  |============================
*/
/* 
Чтобы обеспечить кроссбраузерность, то есть совместимость с более старыми браузерами, или такими которые еще не поддерживают 
это нативно, можно использовать ряд существующих JavaScript библиотек. 
Одни из самых популярных это lazysizes, vanilla-lazyload и lozad.js. 
Выбор библиотеки сводится к набору предоставляемых возможностей и личным предпочтениям. Мы разберем библиотеку lazysizes.


ИНТЕРЕСНО
Нативная поддержка лучше и более производительна чем использование библиотек, но они гарантированно работают во всех браузерах 
и могут предоставлять расширенные возможности отложенной загрузки которых еще нет в стандарте.

Первое что необходимо сделать это подключить библиотеку в проект используя сервис cdnjs.com.
Тег с ссылкой на скрипт добавляется в конец <body>, также как мы это делали для библиотеки Lodash.

index.html
<body>
  <!-- HTML-markup -->

  <!------------------------------ Lazysizes library script file adding start------------------------------>
  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.3.2/lazysizes.min.js"
    integrity="sha512-q583ppKrCRc7N5O0n2nzUiJ+suUv7Et1JGels4bXOaMFQcamPk9HjdUknZuuFjBNs7tsMuadge5k9RzdmO+1GQ=="
    crossorigin="anonymous"
    referrerpolicy="no-referrer"
  ></script>
  <!------------------------------ Lazysizes library script file adding end ------------------------------>
  <script defer src="path/to/script.js"></script>
</body>


ИНТЕРЕСНО
Библиотека lazysizes самоинициализируется при загрузке на страницу. То есть для базового использования в JavaScript 
ничего делать не надо. Полный список её возможностей приведён в документации.

Всем изображениям которые необходимо загружать отложенно задаём класс lazyload и заменяем атрибут src на data-src. 
Это необходимо библиотеке lazysizes для правильной работы.

index.html
<img class="lazyload" data-src="path/to/my-image.jpg" alt="Generic alt" />

Пока изображение загружается можно показывать заполнитель низкого качества. Эта техника называется LQIP 
(Low Quality Image Placeholder). Есть много вариантов реализации LQIP, но для начала достаточно будет показывать один 
стандартный заполнитель вместо всех изображений. Для этого добавляем атрибут src, значением которого будет ссылка на 
это изображение-заполнитель.

index.html
<img
  class="lazyload"
  src="path/to/lqip-placeholder.jpg"
  data-src="path/to/my-image.jpg"
  alt="Generic alt"
/>

Когда изображение было загружено, библиотека lazysizes добавляет элементу класс lazyloaded. Это можно использовать 
для применения CSS-эффектов в момент загрузки изображения.

styles.css
.blur-up {
  filter: blur(5px);
  transition: filter 400ms;
}

.blur-up.lazyloaded {
  filter: blur(0);
}

После объявления стилей, добавляем класс blur-up тегам <img>.

index.html
<img
  class="lazyload blur-up"
  src="path/to/lqip-placeholder.jpg"
  data-src="path/to/my-image.jpg"
  alt="Generic alt"
/>

Применим все эти шаги на примере, добавив кроссбраузерную поддержку отложенной загрузки изображений нашему сайту про котов. 
Теперь даже Safari выполняет отложенную загрузку изображений.
*/

/**
  |============================
  | Node.js
  |============================
*/

/* 
Node.js - легкая и эффективная среда выполнения JavaScript. Позволяет писать высокопроизводительные серверные приложения и инструменты.
Node.js построен на JavaScript-движке V8 и написан на C++.

Изначально Node.js создавался как серверное окружение для приложений, но разработчики начали использовать его для создания инструментов, 
помогающих автоматизировать выполнение локальных задач. В итоге возникшая вокруг Node.js новая экосистема инструментов, привела 
к трансформации процесса фронтенд-разработки.

Установка
Чтобы установить последнюю стабильную версию, перейдите на официальную страницу, скачайте LTS-инсталлятор и следуйте указаниям. 
Есть установщики для всех популярных операционных систем - Windows, MacOS и Linux.

ИНТЕРЕСНО
Пользователям Windows необходимо выбрать чекбоксы для установки всех дополнительных инструментов кроме Chocolatey. 
Это установит Python и всевозможные вспомогательные утилиты и компиляторы.

После установки в терминале будет доступна команда node. Для того чтобы убедиться, что установка прошла успешно, 
проверьте версию, запустив в консоли команду node с флагом version.

node --version

JavaScript вне браузера
Node.js позволяет выполнять JavaScript-код вне браузера. Откройте любой терминал и выполните команду node, запустится 
REPL (read-eval-print loop) - интерактивная среда выполнения JS-кода. 

ИНТЕРЕСНО
Для того чтобы выйти из REPL, нажмите комбинацию Ctrl + C на Windows и Control + C на MacOS.

Теперь создадим папку node-tut, а в ней файл index.js с кодом, который мы писали в REPL. 
Для запуска нужно открыть терминал и перейти в папку node-tut в которой лежит index.js.

// index.js
const message = "NodeJS in amazing!";
console.log(message);

Теперь в консоли запускаем файл с помощью команды node index.js и получаем тот же результат - вывод строки непосредственно в терминале.

В этом и заключается суть Node.js - возможность выполнять JavaScript вне браузера. 
Таким образом можно писать целые приложения, например бэкенд или утилиты не зависящие от браузера.
*/

/**
  |============================
  | Пакетный менеджер npm
  |============================
*/
/* 
Чтобы использовать все богатство инструментов (или пакетов) Node.js нам нужна возможность устанавливать и управлять ими. 
Для этого создан NPM (node package manager) - пакетный менеджер Node.js. Он устанавливает нужные пакеты и предоставляет 
удобный интерфейс для работы с ними.

NPM состоит из трех основных компонентов:

- Сайт npmjs.com - используется для поиска и ознакомления с документацией пакетов.
- Интерфейс командной строки (CLI) - запускается из терминала и предоставляет набор команд для работы с реестром и пакетами. 
Позволяет создавать скрипты для запуска в терминале.
- Реестр пакетов (registry) - большая общедоступная база данных инструментов разработки (пакетов).

Пакет (package) - небольшая JavaScript библиотека, решающая специфическую задачу. Пакеты пишут сами разработчики и делятся с сообществом. 
Такой подход упрощает жизнь, потому что не нужно изобретать колесо, все колеса уже давно лежат на полках реестра и готовы к использованию.

ИНТЕРЕСНО
Пакеты абстрагируют реализацию функционала, предоставляя разработчику удобный интерфейс. 
Это делает код чище, читабельнее и позволяет легче его поддерживать.


--- Команды NPM ---
Сразу перечислим основные команды и будем последовательно использовать и рассматривать в деталях.

npm init - инициализирует npm в проекте и создает файл package.json
npm install - устанавливает все зависимости перечисленные в package.json
npm list --depth=0 - выведет в терминале список локально установленных пакетов с номерами их версий, без зависимостей
npm install [package-name] - установит пакет локально в папку node_modules
npm uninstall [package-name] - удалит пакет, установленный локально и обновит package.json
npm start и npm test - запустит скрипт start или test, расположенный в package.json
npm run [custom-script] - запустит кастомный скрипт, расположенный в package.json
npm outdated - используется для поиска обновлений, обнаружит совместимые версии программно и выведет список доступных обновлений
npm update - обновит все пакеты до максимально разрешенной версии

Документация NPM

--- Инициализация проекта ---
Каждый проект начинается с создания файла package.json - он отслеживает зависимости, содержит служебную информацию, 
позволяет писать npm-скрипты и служит инструкцией при создании нового проекта на основе уже готовых настроек. 
Создать файл package.json можно npm-командой init, тем самым инициализировав проект в текущей папке.

npm init

Вам будет предложено ввести название проекта, версию, описание и т. д. Можно просто нажимать Enter до тех пор, пока не будет создан 
package.json и размещен в папке проекта. Чтобы не нажимать Enter, пропуская пустые поля, используется команда init с флагом --yes. 
Флаг - дополнительная настройка для команды.

npm init --yes

ИНТЕРЕСНО
У каждого флага есть псевдоним - его сокращённая запись. Псевдоним флага --yes это -y, поэтому комманды npm init --yes и npm init -y 
делают одно и тоже.

Будет создан package.json со значениями по умолчанию. Чтобы установить эти значения, в терминале последовательно выполните следующие 
команды, подставив свое имя и почту.

npm config set init-author-name  "your name"
npm config set init-author-email "your-email@example.com"
npm config set init-author-url   "https://my-domain/user"

Можно редактировать файл package.json вручную или выполнить npm init ещё раз. 
Если открыть package.json в редакторе, он будет выглядеть примерно так. Это всего лишь метаданные о проекте.

package.json
{
  "name": "node-tut",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Alexander Repeta <mycoolemail@mail.com>",
  "license": "ISC",
  "keywords": [],
  "description": ""
}

npm-скрипты
Скрипты позволяют запускать на исполнение установленные пакеты. Используя npm-скрипты, можно создавать целые системы сборки проекта. 
Автоматизируем запуск index.js. Для этого в файле package.json в поле scripts добавим скрипт запуска start.

package.json
{
  "scripts": {
    "start": "node index.js"
  }
}

Теперь мы можем запустить его в терминале командой npm start.

ВНИМАНИЕ
Если создать скрипт с любым другим именем, кроме start или test, он будет запускаться как npm run имя-скрипта - не забудьте run. 
Ознакомтесь с документацией - How npm handles the "scripts" field.



--- Установка пакетов ---
Одна из возможностей, которые предоставляет npm - установка пакетов, которые извлекаются из реестра и распаковываются в папку node_modules 
в корне проекта. После того как файл package.json создан, можно добавить зависимости в проект.

Зависимостью называют npm-пакет, который используется при разработке. Это всевозможные утилиты и библиотеки. 
Установим библиотеку validator.js для валидации строк, например ввода пользователя в поля формы.

npm install validator

NPM загрузил validator и поместил его в node_modules - папку, в которой будут находиться все внешние зависимости.

ВНИМАНИЕ
Не добавляйте папку node_modules в систему контроля версий, у всех разработчиков она будет своя. 
Если вы используете Git, не забывайте добавить папку node_modules в файл .gitignore.

Обратите внимание на созданный файл package-lock.json - это журнал снимков дерева зависимостей проекта. 
Он гарантирует, что команда разработчиков использует одни и те же версии зависимостей. 
NPM автоматически обновляет его при добавлении, удалении и обновлении пакетов.

В package.json появилась новая зависимость в поле dependencies. Это означает, что validator версии 11.1.0 был установлен 
как зависимость и готов к работе. Пакеты постоянно обновляются, ваша версия может отличаться.

package.json
{
  "dependencies": {
    "validator": "^11.1.0"
  }
}

Для того чтобы получить интерфейс пакета в Node.js-коде, необходимо вызвать функцию require("имя-модуля"), 
аргументом передав ей имя модуля без определения пути - это называется абсолютный импорт. 
Путь не нужен, так как по умолчанию поиск модуля будет происходить в папке node_modules. 
Результатом своего выполнения функция вернет интерфейс модуля - объект с методами или просто функцию, зависит от пакета.

index.js
const validator = require("validator");

const validateEmail = email => {
  return validator.isEmail(email);
};

console.log(
  "Is mango@mail.com a valid email?: ",
  validateEmail("mango@mail.com")
);

console.log(
  "Is Mangozedog.com a valid email?: ",
  validateEmail("Mangozedog.com")
);

Выполнив в терминале npm start получим.

Is mango@mail.com a valid email?: true
Is Mangozedog.com a valid email?: false


 --- Удаление пакетов --- 
Предположим, что установленная в предыдущем примере версия validator вызывает проблемы с совместимостью. 
Мы можем удалить этот пакет и поставить более старую версию.

npm uninstall validator



 --- Установка определенной версии пакета --- 
Теперь установим нужную версию validator. В команде установки номер версии указывается после символа @.

npm install validator@1.0.0

ИНТЕРЕСНО
Установка пакетов определенный версии используется в коммерческих проектах для того, чтобы гарантировать работу кодовой базы 
и возможность долгосрочной поддержки. Вы можете устанавливать самые последние версии.



--- Типы зависимостей ---
Представьте торт, для его приготовления шефу нужны продукты, именно они войдут в состав торта. 
Но для приготовления понадобятся и инструменты вроде мисок, ложек, лопаток и т. п. А еще на кухне есть столы и печи, холодильники и т. д. 
- то, что используется для приготовления любого блюда, общие инструменты которые есть на кухне.

То же самое и с зависимостями проекта - некоторые будут использованы в результирующем продукте, другие необходимы только 
на стадии разработки, а есть такие, что необходимо использовать вне зависимости от проекта.

Именно для этого у команд npm install и npm uninstall есть три флага.

--save - указывает, что добавляется зависимость, которая войдет в финальный продукт. 
Пакет будет установлен локально, в папку node_modules и будет добавлена запись в поле dependencies в package.json.
--save-dev - указывает, что добавляется зависимость разработки. 
Пакет будет установлен локально, в папку node_modules и будет добавлена запись в поле devDependencies в package.json.
--global - указывает, что добавляется глобальная зависимость, то есть инструмент, который доступен для любого проекта. 
Пакет будет установлен глобально (в систему).

ИНТЕРЕСНО
Если не указывать флаг, по умолчанию будет использован --save.
При удалении пакета необходимо указывать правильный флаг, такой же как при установке.
Не устанавливайте пакеты глобально если вы работаете на проекте с другими разработчиками.


--- Управление версиями пакетов ---
Пакеты имеют связанный с ними номер версии. Номера версий соответствуют стандарту SemVer.

npm outdated - используется для поиска обновлений, обнаружит совместимые версии программно.
npm update - обновит все пакеты до максимально разрешенной версии.
npm update [имя-пакета] - обновит указанный пакет.

ИНТЕРЕСНО
Если вы не доверяете машинам или хотите какую-то определённую версию пакета, можно открыть package.json и вручную поменять версии пакетов, 
после чего выполнить npm install.

--- Управление кэшем ---
После установки пакета npm сохраняет его копию в кэше, поэтому при следующей его установке вам не нужно опять скачивать его из интернета. 
Кэш хранится в папке .npm вашего домашнего каталога.

Эта папка со временем засоряется старыми пакетами и иногда ее полезно очищать, не слишком часто (пару раз в год), 
кеширование полезно, так как сокращает время установки уже использованных пакетов.

npm cache clean
*/

/**
  |============================
  | Модульность кода
  |============================
*/
/* 
Концепция модулей как способа организации кода существовала давно. 
С ростом проекта и его кодовой базы ее пытаются разбить на файлы, в каждом из которых описывается отдельный функционал.

Модульный код помогает в организации, обслуживании, тестировании и, самое главное, управлении зависимостями. 
Наиболее важные преимущества модулей - это поддерживаемость, пространство имен и повторное использование.

Поддерживаемость - хорошо разработанный модуль призван максимально снизить зависимость от других частей кода. 
Это позволит расширять функционал приложения не опасаясь нарушить его работу в целом. 
Обновление одного модуля намного проще, если модуль самодостаточен.

Пространство имен - переменные, не входящие в область видимости функции, являются глобальными. 
Из-за этого обычно происходит загрязнение пространства имен, где полностью несвязанный код разделяет глобальные переменные. 
Модули позволяют избежать загрязнения пространства имен, создавая отдельную область видимости для переменных.

Повторное использование - все разработчики копировали готовый код в новые проекты, изменяя его под специфику проекта. 
Это, очевидно, огромная трата времени. Намного лучше когда есть модуль, который можно повторно использовать снова и снова 
без необходимости знать что-либо об окружении в котором он используется.

 --- Сборка модулей ---
Сборка модулей - это процесс конкатенации группы модулей и их зависимостей в один или группу файлов.

Обычно код делят на папки и файлы, к тому же необходимо подключить внешние библиотеки. 
В результате каждый из этих файлов должен быть включен в основной HTML-файл в теге <script>, который затем загружается браузером.

Наличие отдельных тегов <script> для каждого файла означает, что браузер будет загружать каждый файл по отдельности, 
что негативно сказывается на скорости загрузки страницы. Чтобы обойти эту проблему, файлы объединяются в один или пару файлов, 
чтобы уменьшить количество запросов. Но остается проблема управления зависимостями между модулями.

Если используются системы модулей, такие как CommonJS или ESM, необходимо использовать инструмент для их преобразования 
в правильно упорядоченный, доступный браузеру код. Именно здесь вступают в действие Webpack и другие бандлеры (от английского bundle).



--- ECMAScript Modules (ESM) ---
До недавнего времени в языке не было встроенной модульной системы. 
ESM имеют компактный декларативный синтаксис и возможность асинхронной загрузки. 

ES-модуль - это многократно используемый фрагмент JS-кода, который экспортирует определенные объекты, делая их доступными для других модулей.

greeter.js
const helloMessage = "hello!";
const goodbyeMessage = "goodbye!";

export const hello = () => helloMessage;
export const goodbye = () => goodbyeMessage;

index.js
import { hello, goodbye } from "./greeter";

console.log(hello()); // "hello!"
console.log(goodbye()); // "goodbye!"

Каждый JS-файл хранит код в уникальном контексте модуля и импортирует необходимые ему зависимости и экспортирует все, 
что должно быть импортировано другими модулями. 

Операции экспорта/импорта реализованы конструкциями import и export. 
Есть два очевидных преимущества этого подхода - предотвращение загрязнения глобального пространства имен и явное указание зависимостей.

Новая система модулей отличается от CommonJS и других, прежде всего тем, что это стандарт. 
А значит, со временем, будет полностью поддерживаться браузерами нативно, без дополнительных инструментов. 

Однако сейчас браузерная поддержка не полная, поэтому ESM используются в сочетании с инструментами сборки модулей, такими как 
Webpack, Parcel и другими.

ИНТЕРЕСНО
ESM разработаны с учетом статического анализа. Это значит, что при импорте модулей, импорт обрабатывается во время компиляции, 
то есть до запуска скрипта. Это позволяет удалять экспорт, который не используется другими модулями, прежде чем запускать скрипт, 
что может привести к значительной экономии веса JS-файла, уменьшив нагрузку на браузер. Это называется tree shaking и выполняется 
бандлерами автоматически при сборке JS кода.


--- Named export ---
Модуль может экспортировать несколько сущностей, которые отличаются своими именами и называются именованными экспортами. 
Чтобы импортировать их в другой модуль, необходимо знать имена экспортируемых сущностей, которые мы хотим импортировать.

Первый способ - это использовать ключевое слово export перед всеми сущностями, которые необходимо экспортировать. 
Они будут добавлены как свойства в экспортируемый объект. При импорте мы деструктуризируем свойства из импортируемого объекта.

my-module.js
const sqrt = Math.sqrt;
export const square = x => x * x;
export const diag = (x, y) => sqrt(square(x) + square(y));

main.js
import { square, diag } from "./path/to/my-module";

console.log(square(11)); // 121
console.log(diag(4, 3)); // 5

Второй способ - это явно указать объект со свойствами для экспорта.

my-module.js
const sqrt = Math.sqrt;
const square = x => x * x;
const diag = (x, y) => sqrt(square(x) + square(y));

export { square, diag };

main.js
import { square, diag } from "./path/to/myModule";

console.log(square(11)); // 121
console.log(diag(4, 3)); // 5


--- Следующий синтаксис импортирует все экспорты модуля как объект с указанным именем. Это называется namespace import. ---

main.js
import * as myModule from "./path/to/my-module";

console.log(myModule.square(11)); // 121
console.log(myModule.diag(4, 3)); // 5


--- Default export ---
Часто модуль экспортирует всего одну сущность, такой экспорт удобен для импорта. 
Экспорт по умолчанию - самое главное экспортируемое значение, которое может быть чем угодно: переменной, функцией, классом и т. д.

my-func.js
export default function myFunc() {
  // ...
}

my-class.js
export default class MyClass {
  // ...
}

main.js
import myFunc from "./path/to/my-func";
import MyClass from "./path/to/my-class";

myFunc();

const inst = new MyClass();

Используйте именованный экспорт, когда необходимо экспортировать несколько сущностей, а экспорт по умолчанию - при экспорте одной сущности. 
Хотя и можно использовать экспорт по умолчанию и именованный экспорт в одном файле, хорошей практикой будет выбрать только один стиль 
для каждого модуля.
*/

/**
  |============================
  | Знакомство с Webpack
  |============================
*/
/* 
Webpack - это сборщик JS-модулей, менеджер модульных зависимостей, который анализирует дерево зависимостей и создает один или несколько 
результирующих файлов, содержащих всю кодовую базу проекта. 
Выстраивает порядок подключения модулей, собирает, минифицирует, запаковывает и многое другое.

Webpack стал одним из самых важных инструментов веб-разработчика. 
В первую очередь - это менеджер модульных зависимостей приложения и сборщик JS-файлов, но он может трансформировать все ресурсы 
(HTML и CSS, SASS и т. п.), оптимизировать изображения, компилировать шаблоны, запускать локальный веб-сервер для разработки и многое другое.

Принцип работы
Предположим, у нас есть приложение, которое может выполнять две простые математические задачи: суммировать и умножать. 
Мы решили разделить эти функции на отдельные файлы (модули) для упрощения поддержки кодовой базы. 
Тогда в index.html скрипты будут подключены в такой последовательности.

index.html
<script src="sum.js"></script>
<script src="multiply.js"></script>
<script src="index.js"></script>

Допустим код из sum.js используется в multiply.js и index.js, а код из multiply.js используется только в index.js. 

Если ошибиться в последовательности подключения скриптов в index.html, то есть если index.js подлючен перед любой из других зависимостей 
или если sum.js добавлен после multiply.js - будут ошибки. Теперь представим, что мы масштабируем это до реального, 
полностью рабочего приложения - могут быть сотни зависимостей. Сохранение порядка подключения станет кошмаром.

Webpack преобразует зависимости в модули и сошьет в один или несколько файлов. 
Каждый модуль будет иметь закрытое пространство имен и подключаться в нужное время, в правильном порядке.

Gulp все еще занимает достойное место в инструментарии разработчика и для некоторых проектов, функционал Webpack не нужен, 
хотя он может отлично работать в связке с ним. Несмотря на то, что кривая обучения может быть выше при более сложных настройках, 
Webpack незаменим если вы используете современные библиотеки и фреймворки для разработки, такие как React, Vue, Angular и т. д.


Настройка
По ссылкам ниже вы найдете исчерпывающие руководства с пошаговыми объяснениями настройки Webpack.

https://www.taniarascia.com/how-to-use-webpack/ - How to set up webpack 5 from scratch 
https://webpack.js.org/concepts/ - Документация Webpack
*/

/**
  |============================
  | Формат JSON
  |============================
*/
/* 
JSON (JavaScript Object Notation) - сучасний текстовий формат зберігання і передачі структурованих даних у текстовій формі. 
Звичний об'єктоподібний синтаксис JSON - дуже зручний. Саме у цьому форматі дані будуть приходити і відправлятися на сервер, 
зберігатися в локальному сховищі тощо.

Але JSON - це не об'єкт, а його рядкове відображення. Нижче наведено приклад JSON файлу. Синтаксис схожий на об'єкт, за винятком того, 
що ключі - це завжди рядки у подвійних лапках. Рядкові значення також обов'язково повинні бути взяті у подвійні лапки. 
Значеннями властивостей можуть бути типи: string, number, object, array, boolean і null.

user.json
{
  "name": "Josh",
  "weight": 175,
  "age": 30,
  "eyecolor": "brown",
  "isHappy": true,
  "cars": ["Chevy", "Honda"],
  "favoriteBook": {
    "title": "The Last Kingdom",
    "author": "Bernard Cornwell",
    "rating": 8.38
  }
}

Javascript і JSON чудово працюють разом, завдяки методам вбудованого класу JSON, які перетворюють JavaScript об'єкт у JSON і навпаки. 
Незалежно від того, що у вас є, можна легко отримати зворотне.

Метод JSON.stringify()
Приймає значення і перетворює його у JSON. Значенням може бути число, буль, null, масив або об'єкт. 
Рядки - це вже валідний JSON, тому в їх перетворенні немає сенсу.

const dog = {
  name: "Mango",
  age: 3,
  isHappy: true,
};

const dogJSON = JSON.stringify(dog);
console.log(dogJSON); // "{"name":"Mango","age":3,"isHappy":true}"

Результат виклику JSON.stringify(dog) - це валідний JSON (рядок), який може бути збережений у файл або переданий мережею.

Не будь-який JavaScript об'єкт може бути перетворений один до одного у JSON. 
Наприклад, якщо в об'єкта є методи, то при перетворенні вони будуть проігноровані.

const dog = {
  name: "Mango",
  age: 3,
  isHappy: true,
  bark() {
    console.log("Woof!");
  },
};

const dogJSON = JSON.stringify(dog);
console.log(dogJSON); // "{"name":"Mango","age":3,"isHappy":true}"

Також, при спробі перетворити функцію в JSON, результатом буде undefined.

JSON.stringify(() => console.log("Well, this is awkward")); // undefined

Метод JSON.parse()
Щоб отримати з JSON валідне JavaScript значення, його необхідно розпарсити (parse). Це операція зворотна перетворенню в рядок (stringify). 
Тепер, коли dog - це валідний об'єкт, з ним можна працювати звичайним чином.

const json = '{"name":"Mango","age":3,"isHappy":true}';

const dog = JSON.parse(json);
console.log(dog); // {name: "Mango", age: 3, isHappy: true}
console.log(dog.name); // "Mango"



Обробка помилок
Якщо методам класу JSON передати невалідний JSON, то вони «викинуть» помилку і весь скрипт впаде. 
Для уникнення цього, використовується конструкція try...catch, яка дозволяє «ловити» і обробляти помилки виконання скрипта.

try {
  // Code that may throw a runtime error
} catch (error) {
  // Error handling
}

Спочатку виконується код всередині блоку try.
Якщо помилки відсутні, блок catch ігнорується і управління передається далі.
Якщо в блоці try сталася помилка, його виконання зупиняється та інтерпретатор переходить до блоку catch.
Змінна error - це об'єкт помилки з інформацією про те, що сталося. У цього об'єкта є кілька корисних властивостей:

name - тип помилки. Для помилки парса - це SyntaxError.
message - повідомлення про деталі помилки.
stack - стек викликів функцій на момент помилки. Використовується для налагодження.
Наприклад, парс рядка призведе до такого сценарію, тому що рядок з символами - це невалідний JSON, оскільки не може бути перетворений 
у валідне JavaScript значення.

// Script will crash during parse
const data = JSON.parse("Well, this is awkward");
console.log("❌ You won't see this log");

Використовуючи конструкцію try...catch, ми можемо обробити цей виняток таким чином, щоб скрипт продовжив працювати, навіть у разі помилки.

try {
  const data = JSON.parse("Well, this is awkward");
} catch (error) {
  console.log(error.name); // "SyntaxError"
  console.log(error.message); // Unexpected token W in JSON at position 0
}

console.log("✅ This is fine, we handled parse error in try...catch");

Те саме буде при спробі парса невалідного JSON, який, наприклад, може прийти з бекенду або бути прочитаний з файлу. 
У прикладі у властивості username бракує подвійних лапок.

try {
  const data = JSON.parse('{username: "Mango"}');
} catch (error) {
  console.log(error.name); // "SyntaxError"
  console.log(error.message); // "Unexpected token u in JSON at position 1"
}

console.log("✅ This is fine, we handled parse error in try...catch");




Фази виконання коду
В JavaScript код виконується не відразу, для початку рушію потрібно прочитати код і дізнатися, чи можливо його взагалі виконати.

Фаза інтерпретації або оцінки (compile time, evaluation time) - підготовка перед виконанням коду, рушій знаходить синтаксичні помилки, 
помилки типізації тощо. Тобто код ще не виконується, тільки оцінюється. Якщо ця фаза пройшла успішно, це як мінімум означає, 
що в коді відсутні синтаксичні помилки і його можна запустити для виконання.

Фаза виконання (runtime) - скрипт починає виконуватися, виконуються інструкції викликів функцій і оцінки виразів, відбувається пошук 
необхідних ідентифікаторів у відповідних областях видимості тощо.

Якщо ця фаза завершилася успішно, отже скрипт написаний без явних помилок і завершив свою роботу. 
На цій фазі можуть бути помилки, пов'язані з відсутніми властивостями і змінними, перетворенням типів тощо, тобто щось, що 
відбувається тільки під час виконання коду.

Спробуйте виконати наступний код. Оскільки ми зробили помилку і замість const намагаємося оголосити змінну value ключовим словом cos, 
на фазі компіляції буде виявлена синтаксична помилка і фаза виконання навіть не запуститься. 
В консолі ми відразу побачимо повідомлення про помилку.

console.log('This message will not appear in the console');

cos value = 5;

ЦІКАВО
try...catch ловить тільки помилки, які виникли під час виконання коду (runtime errors). 
Це означає, що код повинен бути синтаксично правильним, інакше фаза виконання просто не запуститься. 

Помилки, які виникають під час фази оцінки, називаються помилками парсингу.
*/

/**
  |============================
  | Веб-хранилище
  |============================
*/
/* 
Каждый раз когда вы изменяете цветовую тему между светлой и темной, просматриваете видео, добавляете товар в корзину, 
открываете или закрываете сайдбар, популярные веб-приложения запоминают состояние интерфейса и при следующем посещении его восстанавливают.

По умолчанию состояние интерфейса хранится в памяти вкладки браузера и теряется при закрытии веб-приложения. 
Чтобы избежать этого, необходимо где-то сохранить данные о состоянии интерфейса между посещениями страницы. 
На помощь приходит хранение информации о состоянии веб-приложения на компьютере пользователя.

Web Storage API
Веб-хранилище состоит из локального хранилища (localStorage) и хранилища сеансов (sessionStorage). 
Предоставляет способ хранения данных интуитивно понятным способом в виде пар ключ:значение. 

Технически в веб-хранилище можно записать только строки, но это не проблема если использовать методы класса JSON для преобразования 
сложных типов. В веб-хранилище не записывают методы объектов или функции, только данные.

Локальное хранилище (localStorage) уникально для каждого веб-приложения и будет одинаковым между несколькими вкладками 
в которых оно (веб-приложение) запущено. Данные в локальном хранилище не удаляются даже при закрытии браузера или выключении компьютера. 
Чтобы их удалить, необходимо использовать JavaScript.

Хранилище сеансов (sessionStorage) похоже на локальное, оно также уникально для кажого веб-приложения, но время жизни сохраненных 
данных огрничено сессией вкладки браузера. Как только пользователь закрывает вкладку или браузер, данные очищаются. 
На практике хранилище сеансов используется значительно реже.

ИНТЕРЕСНО
В веб-хранилище не хранят пароли, номера банковских карт и тому подбную конфиденциальную информацию. 
Если вредоносный скрипт получит доступ к веб-странице, то без проблем прочитает эти данные.

Локальное хранилище
Позволяет хранить данные без истечения срока действия в формате пар ключ:значение на компьютере пользователя и читать их при 
повторном посещении страницы. 

Локальное и хранилище сессии это часть браузера, поэтому они доступны как свойства объекта window, имеют одинаковый набор свойств 
и методов и различаются только поведением.

setItem(key, value) - делает новую, или обновляет уже существующую запись в хранилище.
getItem(key) - возвращает из хранилища значение с ключом key.
removeItem(key) - удаляет из хранилища запись с ключом key.
clear() - полностью очищает все записи в хранилище.
length - хранит количество записей в хранилище.

Сохранение
Используя метод setItem(key, value) можно добавить новую запись в виде пары ключ:значение.

localStorage.setItem("ui-theme", "light");
localStorage.setItem("sidebar", "expanded");
localStorage.setItem("notification-level", "mute");

Если необходимо сохранить что-то кроме строки, например массив или объект, необходимо преобразовать их в строку методом JSON.stringify().

const settings = {
  theme: "dark",
  isAuthenticated: true,
  options: [1, 2, 3],
};

localStorage.setItem("settings", JSON.stringify(settings));

Чтение
Метод getItem(key) позволяет прочитать из хранилища запись с ключом key. 
Если в хранилище нет записи с таким ключом, метод возвращает null. 
Когда значение это обычная строка - нет необходимости её парсить.

localStorage.setItem("ui-theme", "dark");

const theme = localStorage.getItem("ui-theme");
console.log(theme); // "dark"

В противном случае, необходимо распарсить значение методом JSON.parse(), чтобы получить валидные данные.

const settings = {
  theme: "dark",
  isAuthenticated: true,
  options: [1, 2, 3],
};

localStorage.setItem("settings", JSON.stringify(settings));

const savedSettings = localStorage.getItem("settings");
const parsedSettings = JSON.parse(savedSettings);
console.log(parsedSettings); // settings object

ИНТЕРЕСНО
Не забывайте использовать конструкцию try...catch с методом JSON.parse(), чтобы избежать «падения» скрипта если вдруг прочитали 
не валидный JSON.

Удаление
Метод removeItem(key) удаляет из хранилища уже существующую запись с ключом key.

localStorage.setItem("ui-theme", "dark");
console.log(localStorage.getItem("ui-theme")); // "dark"

localStorage.removeItem("ui-theme");
console.log(localStorage.getItem("ui-theme")); // null

Очистка хранилища
Операция полной очистки хранилища занятие опасное, так как может затронуть записи сделанные другими разработчиками проекта. 
Тем не менее, если вы хотите полностью очистить хранилище, вызовите метод clear().

localStorage.setItem("ui-theme", "light");
localStorage.setItem("sidebar", "expanded");
localStorage.setItem("notification-level", "mute");
console.log(localStorage.getItem("ui-theme")); // "light"
console.log(localStorage.getItem("sidebar")); // "expanded"
console.log(localStorage.getItem("notification-level")); // "mute"

localStorage.clear();
console.log(localStorage.getItem("ui-theme")); // null
console.log(localStorage.getItem("sidebar")); // null
console.log(localStorage.getItem("notification-level")); // null


Сохраняем сообщение
Создадим форму для ввода сообщения и будем сохранять его в localStorage при сабмите. 
Изменяйте значение текстового поля и нажимате кнопку «Save». Текст в поле вывода изменится на введенный. 
Перезагрузите страницу, и вы увидите все тот же текст, хотя ничего еще не вводили. 
При загрузке страницы мы берем из localStorage последнее сохраненное значение. 
Изначально такой записи в хранилище нет, поэтому будет выведена пустая строка.

const form = document.querySelector(".feedback-form");
const localStorageKey = "goit-example-message";

form.elements.message.value = localStorage.getItem(localStorageKey) ?? "";

form.addEventListener("input", (evt) => {
  localStorage.setItem(localStorageKey, evt.target.value);
});

form.addEventListener("submit", (evt) => {
  evt.preventDefault();
  localStorage.removeItem(localStorageKey);
  form.reset();
});


Посмотреть содержимое веб-хранилища можно в инструментах разработчика на вкладке Application. 
Там же можно вручную удалять и добавлять записи. На практике это используется во время разработки и отладки работы приложения.


Сервис для localStorage
Для того чтобы сократить количество повторяющегося кода при работе с веб-хранилищем, можно написать сервис с стандартными методами, 
например save и load. Они будут абстрагировать повторяющийся код проверки ошибок парса и тому подобную рутину.

storage.js
const save = (key, value) => {
  try {
    const serializedState = JSON.stringify(value);
    localStorage.setItem(key, serializedState);
  } catch (error) {
    console.error("Set state error: ", error.message);
  }
};

const load = key => {
  try {
    const serializedState = localStorage.getItem(key);
    return serializedState === null ? undefined : JSON.parse(serializedState);
  } catch (error) {
    console.error("Get state error: ", error.message);
  }
};

export default {
  save,
  load,
};

Теперь мы можем безопасно добавлять и читать записи из локального хранилища. 
Попробуйте самостоятельно дописать метод remove(key) для удаления записи, аналогично load(key) и save(key, value).
*/

/**
  |============================
  | Асинхронность
  |============================
*/
/* 
Весь код выполняется процессором вашего компьютера. Код который мы писали до сих пор был синхронным, то есть занимал процессор 
на все время своего выполнения. Например, скорость выполнения цикла для итерации по массиву зависит от скорости процессора.

Есть операции которые взаимодействуют с внешним миром. Например, обмен данными с сервером по сети, что намного медленнее, 
чем получение их из памяти. Если такие операции обрабатываются синхронно, то процессор простаивает пока идет сетевой запрос 
на сервер, вместо того чтобы выполнять другой код.

Синхронный код выполняется последовательно, каждая инструкция ожидает пока выполнится предыдущая. Когда вы вызываете функцию, 
которая выполняет длительное действие, это останавливает программу на всё время её выполнения. То есть в модели синхронного 
программирования все происходит по очереди.

ИНТЕРЕСНО
Представьте очередь покупки билетов на поезд. Вы не можете начать покупать билет до тех пор, пока не купит человек перед вами. 
Точно так же люди, стоящие за вами, не могут начать покупать билеты до тех пор, пока не купите вы.

В асинхронном коде одновременно могут выполняться несколько операций. В такой модели сетевой запрос на сервер не остановит 
программу, она продолжит выполнять другие операции. Когда запрос завершится, программа информируется об этом и получает доступ 
к результату (например, данным от сервера).

ИНТЕРЕСНО
Представьте обед в ресторане. Вы и другие посетители, заказываете еду. Вам не нужно ждать, пока им принесут еду, прежде чем заказывать. 
Точно так же другие посетители не должны ждать, пока вы получите свое блюдо и поедите, прежде чем они смогут заказать. 
Каждый получит свое блюдо, как только его закончат готовить.

Рассмотрим разницу на примере в котором программа выполняет два сетевых запроса на сервер, после чего обрабатывает их результат. 
Операции 1 и 2 это функции которые делают запросы на севрер, а 3, 4 и 5 любой другой привычный вам код.

https://textbook.edu.goit.global/javascript-yk5evp/v2/img/lesson-17/sync-vs-async.png

В синхронной модели все понятно и довольно печально - предыдущие операции блокируют выолнение последующих пока не закончатся. 
Если операции 3-5 это обработка кликов пользователя, то интерфейс просто зависнет пока не выполнятся и обработаются результаты запросов 1-2.

Например, пользователь отправил комментарий (сетевой запрос) и в тоже время захотел открыть сайдбар с последними новостями. 
После клика отправить комментрий, интерфейс зависнет и не будет реагировать на его действия пока от сервера не придет результат 
отправки комментария. Согласитесь, это не очень удобно.

В асинхронной модели старт сетевого запроса вызывает как бы разветвление, то есть запуск запроса и результат его обработки это 
различные действия. Пока выполяется запрос, программа продолжает работать и выполнять другой код. Как только сетевой запрос выполнен, 
программа может начать обрабатывать его результат как только будет свободна. Это значит, что пользователь отправил комментарий 
и сразу смог открыть сайдбар со свежими новостями, не дожидаясь пока придёт ответ от сервера.

То есть в единицу времени все также может выполняться только одна операция, потому что JavaScript однопоточный. 
Асинхронное программирование достигается путем отложенных вызовов функций, где инициализация асинхронной операции и обработка её результата 
это разные действия.



--- Асинхронный код ---

В синхронном коде следующая инструкция не может начать свое выполнение пока не выполнится предыдущая. То есть инструкции 
обрабатываются последовательно.

console.log("First log");
console.log("Second log");
console.log("Third log");

Следующий код - асинхронный. С функцией setTimeout() мы познакомимся дальше. Сейчас о ней нам нужно знать только то, что она 
принимает два параметра: callback-функцию, которая будет вызвана по истечении времени, которое мы передаем вторым аргументом.

// Will run first
console.log("First log");

setTimeout(() => {
  // Will run last, after 2000 milliseconds
  console.log("Second log");
}, 2000);

// Will run second
console.log("Third log");

Функция setTimeout() отрабатывает синхронно и регистрирует отложенный вызов переданной callback-функции, которая будет вызвана 
асинхронно, через указанный промежуток времени.



--- Многопоточность ---

Не путайте асинхронность и многопоточность (параллелизм) - это разные модели программирования. Приведем простую аналогию, 
которая все расставит по своим местам. Представьте, что вы шеф в ресторане и приходит заказ на кофе и тосты.

Синхронный однопоточный подход - вы сами сначала готовите кофе, затем тосты и подаёте их, после чего убираете на кухне.

Асинхронный однопоточный подход - вы начинаете готовить кофе и устанавливаете таймер, затем начинаете готовить тосты и так же 
устанавливаете таймер. Пока кофе и тосты готовятся, вы убираете на кухне. Когда таймеры срабатывают, вы снимаете с огня кофе, 
достаете тосты и подаёте их.

Многопоточный подход (параллелизм) - вы нанимаете двух помошников, одного для приготовления кофе, а другого для тостов. 
Теперь у вас есть проблема управления помошниками (потоками), чтобы они не конфликтовали друг с другом на кухне при 
совместном использовании ресурсов.

В асинхронных однопоточных процессах у вас есть график задач, где некоторые задачи зависят от результата работы других. 
По мере выполнения каждой задачи вызывается код для обработки её результата. Но вам нужен только один работник для выполнения 
всех задач, а не один работник на задачу.
*/

/**
  |============================
  | Таймеры
  |============================
*/
/* 
Внутренний таймер-планировщик браузера позволяет откладывать вызов функции на определенный период времени. Для этого есть тайм-ауты 
и интервалы, которые контролируют когда и как часто вызывается функция. Таймеры реализованы в браузере, а не встроенны в язык, 
и доступны на глобальном объекте window.

--- Таймаут ---
Метод setTimeout() позволяет запланировать запуск функции через определённое время.

const timerId = setTimeout(callback, delay, arg1, arg2, ...);

callback - функция, выполнение которое необходимо запланировать.
delay - время в миллисекундах, через которое callback-функция будет вызвана один раз.
Возвращает цифровой идентификатор созданного таймера, который используется для его удаления.

Дополнительные аргументы (arg1, arg2 и т. д.) будут переданы callback-функции во время вызова. 

const id = setTimeout((name, city) => {
  console.log(name);
  coonsole.log(city)
}, 1000, "Alice", "Lviv") //  Alice // Lviv

const button = document.querySelector("button");

const onClick = () => {
  const timerId = setTimeout(() => {
    console.log("I love async JS!");
  }, 2000);

  console.log(timerId);
};

button.addEventListener("click", onClick);

Если нам, по какой-то причине, нужно отменить вызов функции внутри таймаута, используется метод clearTimeout(id), 
которая принимает идентификатор таймера и очищает (удаляет) его.

const greet = () => {
  console.log("Hello!");
};

const timerId = setTimeout(greet, 3000);

clearTimeout(timerId);

Поскольку мы вызвали clearTimeout(), который исполнится раньше чем будет вызвана функция greet(), таймер с timerId 
будет удалён и регистрация отложенного вызова greet() отменится. Поэтому в консоль ничего не выведется.


--- Интервал ---
Метод setInterval() - это простой способ повторения кода снова и снова с установленным промежутком времени повторений. 
Синтаксис и параметры такие же как у setTimeout(). В отличие от setTimeout(), интервал запускает выполнение функции не один раз, 
а регулярно повторяет её через указанный промежуток времени. Остановить исполнение можно вызовом метода clearInterval(id).

const timerId = setInterval(callback, delay, arg1, arg2, ...);

При клике на кнопку «Start» запустим интервал и будем каждую секунду выводить в консоль строку. Используем Math.random() 
чтобы строки были разные. По клику на кнопку «Stop» вызовем clearInterval() и передадим идентификатор интервала который 
надо остановить.

const startBtn = document.querySelector(".js-start");
const stopBtn = document.querySelector(".js-stop");
let timerId = null;

startBtn.addEventListener("click", () => {
  timerId = setInterval(() => {
    console.log(`I love async JS!  ${Math.random()}`);
  }, 1000);
});


stopBtn.addEventListener("click", () => {
  clearInterval(timerId);
  console.log(`Interval with id ${timerId} has stopped!`);
});

--- Частота срабатывания счетчика ---
У браузерного таймера есть минимальная возможная задержка. В современных браузерах она колеблется примерно от 0 до 4 миллисекунд. 
В более старых браузерах задержка может быть больше и достигать 15 миллисекунд. По стандарту, минимальная задержка составляет 4 
миллисекунды, так что разницы между setTimeout(callback, 1) и setTimeout(callback, 4) нет.

Таймер может срабатывать реже чем указано в параметре delay, потому что при слишком большой загрузке процессора некоторые запуски 
функций-интервалов будут пропущены. Браузеры продолжают выполнять таймауты и интервалы даже если вкладка браузера неактивна, 
но при этом снижают частоту срабатывания таймеров.
*/

/**
  |============================
  | Дата и время
  |============================
*/
/* 
Класс Date абстрагирует большую часть работы с датами напрямую. Это позволяет нам представлять моменты во времени как объекты 
и манипулировать ими заранее определёнными методами. Используя возможности класса Date можно создавать часы, счетчики, календари 
и другие интерактивные элементы интефрейса.

--- Создание даты ---
Экземпляр объекта Date это объект представляющий определённый момент времени. Создание даты без аргументов, возвращает объект 
хранящий дату и время на момент его инициализации, то есть текущие. В строчном преобразовании объект возвращает результат 
вызова метода toString(), поэтому в первом логе мы получим строку, а не объект.

const date = new Date();

console.log(date);
// "Fri Jun 18 2021 15:01:35 GMT+0300 (Eastern European Summer Time)"

console.log(date.toString());
// "Fri Jun 18 2021 15:01:35 GMT+0300 (Eastern European Summer Time)"

--- Unix время ---
Внутренне даты представлены в миллисекундах прошедших с полночи 1 января 1970 года в часовом поясе UTC. Для компьютера это дата 
начала отсчета всего времени - Unix время. Поэтому при инициализации даты одним числом, оно представляет собой количество 
прошедших миллисекунд.

console.log(new Date(0));
// "Thu Jan 01 1970 03:00:00 GMT+0300 (Eastern European Standard Time)"

console.log(new Date(15000));
// "Thu Jan 01 1970 03:00:15 GMT+0300 (Eastern European Standard Time)"

--- Метод getTime() возвращает числовое представление даты (timestamp) - количество миллисекунд прошедших с полночи 1 января 1970 года.

const date = new Date();
console.log(date.getTime()); // 1624021654154

Удобство этого формата заключается в том, что можно представлять точные моменты времени в виде одного числа и не 
беспокоиться о датах, строках и часовых поясах, так как можно получить всю необходимую информацию когда необходимо.

Установка даты
При создании экземпляра класса Date, можно установить дату строкой или числами. Строка может описывать только дату или дату и время.

const teamMeetingDate = new Date("March 16, 2030");
console.log(teamMeetingDate);
// "Mon Mar 16 2030 00:00:00 GMT+0200 (Eastern European Standard Time)"

const preciseTeamMeetingDate = new Date("March 16, 2030 14:25:00");
console.log(preciseTeamMeetingDate);
// "Mon Mar 16 2030 14:25:00 GMT+0200 (Eastern European Standard Time)"

Установка времени в виде строк внутренне вызывает метод Date.parse(), который преобразует строку в число - количество миллисекунд. 
Именно поэтому формат передаваемой строки очень гибкий. Например, можно не указывать ноль для дней и месяца. 

Рассмотрим несколько примеров, которые приведут к одинаковому результату.

new Date("2030-03-16");
new Date("2030-03");
new Date("2030");
new Date("03/16/2030");
new Date("2030/03/16");
new Date("2030/3/16");
new Date("March 16, 2030");
new Date("March 16, 2030 14:25:00");
new Date("2030-03-16 14:25:00");
new Date("2030-03-16T14:25:00");
new Date("16 March 2030");

Другой способ создания новых объектов - это передать семь чисел, которые описывают год, месяц (начинается с 0), день, часы, 
минуты, секунды и миллисекунды. Обязательны только первые три.

const date = new Date(2030, 2, 16, 14, 25, 0, 0);
console.log(date);
// Sat Mar 16 2030 14:25:00 GMT+0200 (Eastern European Standard Time)

--- Методы ---
Экземпляр класса Date имеет множество методов для чтения и записи значений даты и времени. Методы возвращают или присваивают 
год, месяц, день месяца или недели, час, минуту, секунду и миллисекунду для каждого экземпляра. Эти данные могут быть 
представлены в виде строки с учетом местного календаря или языка.

--- Геттеры ---
Геттеры используются для чтения всей даты или отдельной составляющей. Возвращаемое значение зависит от текущего часового
пояса установленного на вашем компьютере.

const date = new Date();
console.log("Date: ", date);

// Возвращает день месяца от 1 до 31
console.log("getDate(): ", date.getDate());

// Возвращает день недели от 0 до 6
console.log("getDay(): ", date.getDay());

// Возвращает месяц от 0 до 11
console.log("getMonth(): ", date.getMonth());

// Возвращает год из 4 цифр
console.log("getFullYear(): ", date.getFullYear());

// Возвращает час
console.log("getHours(): ", date.getHours());

// Возвращает минуты
console.log("getMinutes(): ", date.getMinutes());

// Возвращает секунды
console.log("getSeconds(): ", date.getSeconds());

// Возвращает миллисекунды
console.log("getMilliseconds(): ", date.getMilliseconds());

Существуют эквивалентные версии этих методов, которые возвращают значения в формате UTC (Coordinated Universal Time), 
а не адаптированные к текущему часовому поясу пользователя.

const date = new Date();
console.log("Date: ", date);

// Возвращает день месяца от 1 до 31
console.log("getUTCDate(): ", date.getUTCDate());

// Возвращает день недели от 0 до 6
console.log("getUTCDay(): ", date.getUTCDay());

// Возвращает месяц от 0 до 11
console.log("getUTCMonth(): ", date.getUTCMonth());

// Возвращает год из 4 цифр
console.log("getUTCFullYear(): ", date.getUTCFullYear());

// Возвращает час
console.log("getUTCHours(): ", date.getUTCHours());

// Возвращает минуты
console.log("getUTCMinutes(): ", date.getUTCMinutes());

// Возвращает секунды
console.log("getUTCSeconds(): ", date.getUTCSeconds());

// Возвращает миллисекунды
console.log("getUTCMilliseconds(): ", date.getUTCMilliseconds());


--- Сеттеры ---
Все, что можно прочитать можно записать, методы для записи называются также как геттеры, но начинаются с приставки set. 
Также для всех методов есть их UTC эквивалент.

const date = new Date("March 16, 2030 14:25:00");

date.setMinutes(50);
// "Sat Mar 16 2030 14:50:00 GMT+0200"

date.setFullYear(2040, 4, 8);
// "Tue May 08 2040 14:50:00 GMT+0300"



--- Форматирование даты ---
Объект даты может быть представлен в разных строчных и числовых форматах. Для этого существует целый набор методов. 
Например, toString(), toDateString() и toTimeString() возвращают стандартное строчное представление, не заданное жёстко 
в стандарте, а зависящее от браузера. Единственное требование к нему - читаемость человеком. 

Метод toString() возвращает дату целиком, а toDateString() и toTimeString() - только дату и время соответственно.

const date = new Date("March 16, 2030 14:25:00");

date.toString();
// "Sat Mar 16 2030 14:25:00 GMT+0200 (Eastern European Standard Time)"

date.toTimeString();
// "14:25:00 GMT+0200 (Eastern European Standard Time)"

date.toLocaleTimeString("uk-Ua");
// "2:25:00 PM"

date.toUTCString();
// "Sat, 16 Mar 2030 12:25:00 GMT"

date.toDateString();
// "Sat Mar 16 2030"

date.toISOString();
// "2030-03-16T12:25:00.000Z"

date.toLocaleString();
// "3/16/2030, 2:25:00 PM"

date.getTime();
// 1899894300000
*/

/**
  |============================
  | Промисы
  |============================
*/
/* 
Поли обещает испечь торт на мой день рождения через две недели. Если все пойдет хорошо и она не заболеет, у меня будет торт. 
Если Поли будет плохо себя чувствовать, то не сможет испечь торт. В любом случае, мы все равно устроим вечеринку. 
Обещание - это не гарантия выполнения, мы не знаем, выполнят его или нет. 

В программировании также есть задачи результат которых мы узнаем только в будущем.

Promise (обещание, промис) - объект представляющий текущее состояние асинхронной операции. Это обёртка для значения, 
неизвестного на момент создания промиса. Позволяет обрабатывать результаты асинхронных операций так, как если бы они были синхронными: 
вместо конечного результата асинхронной операции возвращается своего рода обещание получить результат в будущем.

Промис может находиться в трёх состояниях:

Ожидание (pending) - начальное состояние при создании промиса.
Исполнено (fulfilled) - операция исполнена успешно, с каким-то результатом.
Отклонено (rejected) - операция отклонена с ошибкой.

При создании промис находится в ожидании (pending), после чего может завершиться успешно (fulfilled), вернув результат 
(значение), или с ошибкой (rejected), вернув причину. Когда промис переходит в состояние fulfilled или rejected - это навсегда.

ИНТЕРЕСНО
Когда промис исполнен или отклонен, то говорят что он завершён (settled). Это просто термин описывающий то, что промис 
находится в любом состоянии кроме ожидания.

Отличия промиса и callback-функции:

Коллбэки - это функции, обещания это объекты.
Коллбэки передаются в качестве аргументов из внешнего кода во внутренний, а обещания возвращаются из внутреннего кода во внешний.
Коллбэки обрабатывают успешное или неуспешное завершение операции, обещания ничего не обрабатывают.
Коллбэки могут обрабатывать несколько событий, обещания связаны только с одним событием.




--- Создание ---
Промис создается как экземпляр класса Promise, который принимает функцию (executor) в качестве аргумента и сразу вызывает её, 
ещё до создания и возврата промиса.

const promise = new Promise((resolve, reject) => {
  // Asynchronous operation
});

Функция executor оповещает экземпляр (промис), когда и как операция, с которой он связан, будет завершена. 
В ней можно выполнять любую асинхронную операцию, по завершении которой нужно вызвать resolve() при успешном выполнении 
(состояние fulfilled), или reject() при ошибке (состояние rejected). Значение возвращаемое этой функции игнорируется.

resolve(value) - функция для вызова при успешной операции. Переданный ей аргумент будет значением выполненного промиса.
reject(error) - функция для вызвова в случае ошибки. Переданный ей аргумент будет значением отклоненного промиса.



// Change value of isSuccess variable to call resolve or reject
const isSuccess = true;

const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    if (isSuccess) {
      resolve("Success! Value passed to resolve function");
    } else {
      reject("Error! Error passed to reject function");
    }
  }, 2000);
});

В переменную promise будет записан промис (объект) в состоянии pending, а через две секунды, после того как будет 
вызван resolve() или reject(), промис перейдет в состояние fulfilled или rejected и мы сможем его обработать.


--- Метод then() ---
Код, которому надо сделать что-то асинхронно, создаёт обещание и возвращает его. Внешний код, получив обещание, 
навешивает на него обработчики. По завершении процесса асинхронный код переводит обещание в состояние fulfilled 
или rejected и автоматически вызываются обработчики во внешнем коде.

После того как промис создан, его результат обрабатывается в callback-функциях. Код пишется так, как будто мы размышляем о том, 
что может произойти если промис выполнится или нет, не думая о временных рамках.

Метод then() принимает два аргумента - callback-функции которые будут вызваны когда промис изменит своё состояние. 
Результат промиса, значение или ошибку, они получат как аргументы.

promise.then(onResolve, onReject)

onResolve(value) - будет вызвана при успешном выполнении промиса и получит его результат как аргумент.
onReject(error) - будет вызвана при выполнении промиса с ошибкой и получит её как аргумент.


В примере, callback-функция onResolve будет вызвана через две секунды если обещание выполнится успешно, 
а onReject вызовется через две секунды в том случае, если обещание выполнится с ошибкой.

// Change value of isSuccess variable to call resolve or reject
const isSuccess = true;

const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    if (isSuccess) {
      resolve("Success! Value passed to resolve function");
    } else {
      reject("Error! Error passed to reject function");
    }
  }, 2000);
});

// Will run first
console.log("Before promise.then()");

// Registering promise callbacks
promise.then(
  // onResolve will run third or not at all
  value => {
    console.log("onResolve call inside promise.then()");
    console.log(value); // "Success! Value passed to resolve function"
  },
  // onReject will run third or not at all
  error => {
    console.log("onReject call inside promise.then()");
    console.log(error); // "Error! Error passed to reject function"
  }
);

// Will run second
console.log("After promise.then()");

ИНТЕРЕСНО
Если фукнции onResolve и onReject содержат сложную логику, их, для удобства, объявляют как внешние функции и передают 
в метод then() по имени.


--- Метод catch() ---
На практике в методе then() обрабатывают только успешное выполнение промиса, а ошибку его выполнения в специальном методе 
catch() для «отлова» ошибок.

promise.catch(error => {
  // Promise rejected
});

Коллбек-функция будет вызвана при выполнении промиса с ошибкой, и получит её как аргумент.

// Change value of isSuccess variable to call resolve or reject
const isSuccess = true;

const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    if (isSuccess) {
      resolve("Success! Value passed to resolve function");
    } else {
      reject("Error! Error passed to reject function");
    }
  }, 2000);
});

promise
  .then(value => {
    console.log(value);
  })
  .catch(error => {
    console.log(error);
  });
-


--- Метод finally() ---
Этот метод может быть полезен если необходимо выполнить код после того, как обещание будет разрешено (fulfilled или rejected), 
независимо от результата. Позволяет избежать дублирования кода в обработчиках then() и catch().

promise.finally(() => {
  // Promise fulfilled or rejected
});

Коллбэк-функция не получит никаких аргументов, поскольку нельзя определить выполнено ли обещание или отклонено. 
Тут будет выполняться код, который необходимо запустить в любом случае.

// Change value of isSuccess variable to call resolve or reject
const isSuccess = true;

const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    if (isSuccess) {
      resolve("Success! Value passed to resolve function");
    } else {
      reject("Error! Error passed to reject function");
    }
  }, 2000);
});

promise
  .then(value => console.log(value)) // "Success! Value passed to resolve function"
  .catch(error => console.log(error)) // "Error! Error passed to reject function"
  .finally(() => console.log("Promise settled")); // "Promise settled"
-


--- Цепочки промисов ---
Метод then() результатом своего выполнения возвращает еще один промис, значением которого будет то, что вернет 
его callback-функция onResolve. Это позволяет строить асинхронные цепочки из промисов.


Так как метод then() возвращает промис, до его выполнения может пройти некоторое время, поэтому оставшаяся часть цепочки будет ждать. При возникновении ошибки в любом месте цепочки, выполнение всех последующих then() отменяется, а управление передается методу catch(). Поэтому он находится в конце цепочки промисов.

const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(5);
  }, 2000);
});

promise
  .then(value => {
    console.log(value); // 5
    return value * 2;
  })
  .then(value => {
    console.log(value); // 10
    return value * 3;
  })
  .then(value => {
    console.log(value); // 30
  })
  .catch(error => {
    console.log(error);
  })
  .finally(() => {
    console.log("Final task");
  });
-



--- Промисификация функций ---
Представим что у нас есть асинхронная функция которая выполянет какую-то асинхронную операцию, например запрос на сервер. 
Для того чтобы обработать результат, её придётся спроектировать так, что она будет ожидать два коллбэка - для успешного 
запроса и для ошибки.

const fetchUserFromServer = (username, onSuccess, onError) => {
  console.log(`Fetching data for ${username}`);

  setTimeout(() => {
    // Change value of isSuccess variable to simulate request status
    const isSuccess = true;

    if (isSuccess) {
      onSuccess("success value");
    } else {
      onError("error");
    }
  }, 2000);
};

const onFetchSuccess = user => {
  console.log(user);
};

const onFetchError = error => {
  console.error(error);
};

fetchUserFromServer("Mango", onFetchSuccess, onFetchError);

Сейчас функция fetchUserFromServer() знает слишком много о том коде, который будет использовать результат её работы. 
Она ожидает коллбэки и отвечает за их вызов при определённых условиях. То есть, мы передаём что-то внутрь функции (коллбэки) 
и надеемся что оно отработает правильно - это не хорошо.

Лучше если функция не заботится о том коде, который будет использовать её результат. Она просто выполняет какую-то операцию 
и возвращает результат своей работы во внешний код. Для того чтобы вернуть результат асинхронной операции, из функции 
необходимо вернуть промис. Промисификация - это преобразование функции с колбеками так, чтобы она не принимала 
коллбэки, а возвращала промис.

const fetchUserFromServer = username => {
  return new Promise((resolve, reject) => {
    console.log(`Fetching data for ${username}`);

    setTimeout(() => {
      // Change value of isSuccess variable to simulate request status
      const isSuccess = true;

      if (isSuccess) {
        resolve("success value");
      } else {
        reject("error");
      }
    }, 2000);
  });
};

fetchUserFromServer("Mango")
  .then(user => console.log(user))
  .catch(error => console.error(error));

ИНТЕРЕСНО
Большинство современных библиотек основаны на промисах. При вызове метода для асинхронной операции его результат доступен 
как промис к которому можно прицепить обработчики в методах then() и catch().

*/

/**
  |============================
  | Методы класса Promise
  |============================
*/
/* 
Есть задачи, в которых необходимо работать с целым набором промисов. В одном случае необходимо дождаться выполнения всех сразу, 
и только потом обрабатывать их результат, а в другом достаточно дождаться выполнения любого, проигнорировав остальные и т. п. 
Именно для этих случаев у класса Promise есть статические методы для работы с одним или группой промисов.

--- Promise.all() ---
Принимает массив промисов, ждет их исполнения и возвращает промис. Если все промисы выполнятся успешно, возвращаемый промис 
перейдет в состояние fulfilled, а его значением будет массив результатов исполнения каждого промиса. В случае когда хотя бы 
один из промисов будет отклонён, то возвращаемый промис перейдет в состояние rejected, а его значением будет ошибка.

Promise.all([promise1, promise2, promise3, ...])

Напишем функцию которая принимает текст для resolve() и задержку в миллисекундах, а результатом своего выполнения возвращает промис. 
Затем создадим два промиса с разным временем задержки.

const makePromise = (text, delay) => {
  return new Promise(resolve => {
    setTimeout(() => resolve(text), delay);
  });
};

const promiseA = makePromise("promiseA value", 1000);
const promiseB = makePromise("promiseB value", 3000);

Promise.all([promiseA, promiseB])
  .then(value => console.log(value)) //["promiseA value", "promiseB value"]
  .catch(error => console.log(error));

Коллбэк метода then() будет вызван спустя три секунды, то есть когда выполнится промис promiseB. Промис promiseA выполнится через 
одну секунду и просто будет ожидать. Если какой либо из промисов будет отклонён, то будет вызван коллбэк метода catch().



--- Promise.race() ---
Возвращает выполненный или отклонённый промис, в зависимости от того, с каким результатом завершится самый «быстрый» из 
переданных промисов, со значением или причиной его отклонения.

Promise.race([promise1, promise2, promise3, ...])

Когда хотя бы один промис из массива исполнится или будет отклонён, то возвращаемый промис перейдёт в состояние resolved 
или rejected, а все остальные будут отброшены.

const makePromise = (text, delay) => {
  return new Promise(resolve => {
    setTimeout(() => resolve(text), delay);
  });
};

const promiseA = makePromise("promiseA value", 1000);
const promiseB = makePromise("promiseB value", 3000);

Promise.race([promiseA, promiseB])
  .then(value => console.log(value)) // "promiseA value"
  .catch(error => console.log(error));

Коллбэк метода then() или catch() будет вызван спустя одну секунду, когда выполнится promiseA. Второй промис promiseB 
будет проигнорирован.




--- Promise.resolve() и Promise.reject() ---
Статические методы для создания мгновенно выполняющихся успешно или отклонённых промисов. 
Работают аналогично new Promise() за исключением возможности указать задержку, но имеют более краткий синтаксис.

// Fulfilled promise
new Promise(resolve => resolve("success value")).then(value =>
  console.log(value)
);

Promise.resolve("success value").then(value => console.log(value));

// Rejected promise
new Promise((resolve, reject) => reject("error")).catch(error =>
  console.error(error)
);

Promise.reject("error").catch(error => console.error(error));

Эти методы используются при промисификации функций, когда необходимо построить цепочку промисов и начальное значение 
уже есть. Выполним рефакторинг следующего кода.

const makeGreeting = guestName => {
  if (guestName === "" || guestName === undefined) {
    return {
      success: false,
      message: "Guest name must not be empty",
    };
  }

  return {
    success: true,
    message: `Welcome ${guestName}`,
  };
};

const result = makeGreeting("Mango");

if (result.success) {
  console.log(result.message);
} else {
  console.error(result.message);
}

При использовании колбеков отпадает необходимость возвращать сложные объекты со статусом операции и проверять его во внешнем коде.

const makeGreeting = (guestName, onSuccess, onError) => {
  if (guestName === "" || guestName === undefined) {
    return onError("Guest name must not be empty");
  }
  onSuccess(`Welcome ${guestName}`);
};

makeGreeting(
  "Mango",
  greeting => console.log(greeting),
  error => console.error(error)
);

Последним шагом будет промисификация функции makeGreeting(), для того чтобы полностью убрать её зависимость от внешнего кода.

const makeGreeting = guestName => {
  if (guestName === "" || guestName === undefined) {
    return Promise.reject("Guest name must not be empty");
  }

  return Promise.resolve(`Welcome ${guestName}`);
};

makeGreeting("Mango")
  .then(greeting => console.log(greeting))
  .catch(error => console.error(error));
*/

/**
  |============================
  | Цикл событий
  |============================
*/
/* 
Цикл событий (event loop) — ключ к асинхронному программированию на JavaScript. Сам по себе язык однопоточный, 
но использование этого механизма позволяет создать дополнительные потоки, чтобы код работал быстрее.

С помощью механизма Event Loop (Цикл событий) становится возможным выполнять асинхронный код в JavaScript.

Event Loop - это специальный механизм на уровне движка js, который координирует работу трёх сущностей: 
- Call Stack (стэк вызовов), 
- Web API (API, предоставляемый браузером), 
- Callback Queue (очередь колбэков).

Работают они следующим образом: движок js анализирует код. Когда он встречает вызов какой-то функции, он перемещает эту функцию в Call Stack. 
Если эта функция синхронная (например, console.log()), то она сразу же исполняется, покидает стэк и на её место приходит следующая функция. 
Если же эта функция асинхронная, например, setTimeout(), обработчик событий, сетевой запрос и т.д., то на помощь приходит браузер со своим 
Web API (мы же помним, что JavaScript - это однопоточный язык, и сам работать в многопоточном режиме он не может). 

Event Loop перемещает колбэк асинхронной функции в Web API, а сама асинхронная функция уходит из стэка вызовов. 
То есть, пока колбэк асинхронной функции находится под управлением Web API, движок js продолжает выполнять другие операции!

Что же происходит с колбэком? В случае, например, setTimeout(), Web API ожидает истечения указанного времени, затем Event Loop 
перемещает этот колбэк в Callback Queue (очередь колбэков). Когда стэк вызовов освобождается, Event Loop перемещает в него 
наш колбэк из очереди колбэков, после чего колбэк наконец исполняется и покидает стэк вызовов.

Этот процесс повторяется до тех пор, пока весь js код не будет выполнен.
*/

/**
  |============================
  | Протокол HTTP
  |============================
*/
/* 
Перед тем как пользователь увидит содержимое сайта на экране, браузер делает запрос на сервер, чтобы получить это самое содержимое. 
HTML-файл, изображения, стили и скрипты приходят с сервера по HTTP протоколу - набору правил и соглашений, используемых 
при передаче данных в сети.

HyperText Transfer Protocol (протокол передачи гипертекста) - широко распространённый протокол для передачи веб-ресурсов различных типов:
 html, css, javascript, изображений, аудио и видео и т. д.

HTTP основан на структуре клиент-сервер и модели запрос-ответ, в которой клиентское приложение инициирует соединение, формирует запрос 
и отправляет его на сервер, после чего сервер обрабатывает этот запрос, формирует ответ и передаёт его обратно клиенту. 
Связь между ними осуществляется посредством череды перемежающихся HTTP-запросов и HTTP-ответов.

Запрос происходит в несколько этапов:

DNS-запрос - поиск ближайшего DNS-сервера, чтобы преобразовать адрес (например google.com ) в его числовое представление, 
IP-адрес (74.125.87.99).
Соединение - установка соединения с сервером по полученному IP-адресу.
Отправка данных - пересылка пакетов с клиента на сервер.
Ожидание ответа - ожидание пока пакеты данных дойдут до сервера, он их обработает и ответ вернется назад.
Получение данных - пакеты пришли, можно получать из них данные.



----- Протокол HTTPS -----
HyperText Transfer Protocol Secure - это надстройка над протоколом HTTP, в которой все сообщения между клиентом и сервером 
шифруются в целях повышения безопасности. Обеспечивает защиту от атак, основанных на прослушивании соединения. Данные 
передаются поверх криптографических протоколов SSL или TLS.

При общении через обычное HTTP-соединение все данные передаются в виде текста и могут быть прочитаны всеми, кто получил 
доступ к соединению между клиентом и сервером. Если пользователи делают покупки онлайн и заполняют форму заказа, содержащую 
информацию о кредитной карте, их финансовые данные гораздо легче украсть, если они передаются в виде текста. 
С HTTPS данные будут зашифрованы и хакер не сможет их расшифровать, потому что для расшифровки необходим доступ к 
закрытому ключу, который хранится на сервере.

ИНТЕРЕСНО
Протокол HTTPS гарантирует, что информация о клиенте, например номера кредитных карт, зашифрована и не может быть перехвачена 
в расшифрованном виде. Посетители могут подтвердить, что сайт безопасен, посмотрев на иконку слева от адресной строки, 
защищенные соединения помечаются иконкой замка.
*/

/**
  |============================
  | REST API
  |============================
*/
/* 
Сервер это компьютер со специальным программным обеспечением. Бекенд это программа, расположенная на сервере, способная 
обработать входящие HTTP-запросы и имеющая набор готовых действий на определенные запросы.

API (интерфейс прикладного программирования) - набор четко определенных правил связи между различными программными компонентами. 
Интерфейс описывает, что можно попросить программу сделать и что получится в результате.

REST (representational state transfer) - стиль бекенд-архитектуры, основанный на наборе принципов, которые описывают как 
сетевые ресурсы определяются и адресуются.

REST API - бекенд построенный по принципу REST. Служит прослойкой между веб-приложением и базой данных. Имеет стандартный 
интерфейс для обращения к ресурсам. Работает как веб-сайт, мы посылаем HTTP-запрос с клиента на сервер, а в ответ, 
вместо HTML-страницы, получаем данные в JSON-формате.




----- Формат запроса -----

REST-сервис требует, чтобы клиент делал запрос на добавление, извлечение или изменение данных. Запрос может состоять 
из следующих частей.

Entry	          Description
-----           -----
HTTP-метод	    Определяет какую операцию выполнять.
HTTP-заголовки	Позволяет клиенту передавать служебную информацию о запросе.
Путь	          Путь к ресурсу. Доступные пути описываются в документации бэкенда.
Тело	          Блок запроса содержащий данные.


----- HTTP-методы -----
Выделяют несколько основных HTTP-методов для работы с REST-сервисом.

Method        	Description
-----           -----
POST	          Создать новый ресурс
GET	            Получить набор ресурсов или один ресурс
PUT	            Обновить существующий или создать новый ресурс
PATCH	          Обновить существующий ресурс
DELETE	        Удалить ресурс


----- HTTP-заголовки -----
Заголовки содержат служебную информацию относящуюся к контенту запроса. Например, тип контента, который клиент 
может обработать в ответе от сервера (заголовок Accept) или который описывает тип ресурса, который клиент отправляет 
серверу или сервер отправляет клиенту (заголовок Content-Type).

Accept: text/html
Content-Type: application/json

MIME-типы - варианты типов контента. Используются для указания содержимого запроса и ответа, состоят из типа и подтипа, 
которые разделены косой чертой /. 
- Например, текстовый файл, содержащий HTML, будет описан типом text/html. 
- Если файл содержит CSS, он будет описан как text/css. 
- Данные в формате JSON будут описаны как application/json. 
Если клиент ожидает text/css, а получает application/json, он не сможет распознать и обработать контент овтета.



----- Пути -----
Запросы должны содержать путь к ресурсу, над которым выполняется операция. 
Доступные пути (эндпоинты, ресурсы) описываются в документации бэкенда.

GET https://bookstore.com/api/orders
Accept: application/json

Такой путь явно указывает ресурс, даже если вы его никогда раньше не видели, потому что он является иерархическим и описательным. 
Мы выполняем запрос для получения коллекции заказов.

Для того чтобы получить один элемент коллекции, его идентификатор добавляется к ресурсу. 
Рассмотрим запрос на чтение одного заказа с идентификатором 289.

GET https://bookstore.com/api/orders/289
Accept: application/json

Последняя часть пути называется динамический параметр и в документации описывается как /ресурс/:параметр. 
Ресурс неизменен, это путь к целой коллекции, а значение параметра меняется для каждого её элемента.




----- Коды ответов -----
На запрос клиента сервер отправляет ответ, который содержит код состояния, чтобы информировать клиента о результате операции. 
Коды делятся на группы.

Group	        Description
-----         -----
1XX	          Несут информационное назначение
2XX	          Коды успешного проведения операции
3XX	          Описывают все, что связано с перенаправлением (redirect)
4XX	          Указывают на ошибки клиента
5XX	          Указывают на ошибки со стороны сервера

ИНТЕРЕСНО
Нет необходимости помнить все коды из каждой группы, достаточно знать наиболее распространенные. 
Остальные всегда можно посмотреть в справочнике HTTP-кодов.
https://www.webfx.com/web-development/glossary/http-status-codes/

Code	                      Description
-----                       -----
200 (OK)	                  Стандартный ответ для успешных HTTP-запросов.
201 (Created)	              Стандартный ответ для HTTP-запроса, который привел к успешному созданию ресурса.
400 (Bad Request)	          Запрос не может быть обработан из-за неверного синтаксиса запроса или другой ошибки клиента.
401 (Unauthorized)	        Для доступа к ресурсу требуется авторизация.
403 (Forbidden)	            У клиента нет разрешения на доступ к этому ресурсу.
404 (Not Found)	            В настоящее время ресурс не найден. Возможно, он был удален или еще не существует.
500 (Internal Server Error)	Общий ответ на непредвиденный сбой сервера, если нет более конкретной информации.


----- Запрос-Ответ -----
Предположим у нас есть приложение которое позволяет просматривать, создавать, редактировать и удалять клиентов и 
заказы небольшого книжного магазина, бекенд которого размещен на bookstore.com/api. 
Используя полученные знания опишем псевдокодом процесс запрос-ответ к бекенду.

Если мы хотим получить данные о всех клиентах, GET запрос будет выглядеть так.

GET bookstore.com/api/customers
Accept: application/json

На что сервер отправит нам такой ответ.

Status: 200 OK
Content-Type: application/json
Body: JSON-данные о всех клиентах

Для получения данных одного клиента мы указываем его идентификатор, уточняя GET запрос.

GET bookstore.com/api/customers/289
Accept: application/json

На что сервер отправит нам такой ответ.

Status: 200 OK
Content-Type: application/json
Body: JSON-данные о клиенте

Для того чтобы добавить нового клиента выполняем POST запрос.

POST bookstore.com/api/customers
Content-Type: application/json
Body: { "username": "Mango", "email": "mango@gmail.com" }

Сервер добавляет уникальный идентификатор и возвращает объект целиком как результат.

Status: 201 Created
Content-type: application/json
Body: { "id": 18674, "username": "Mango", "email": "mango@gmail.com" }
*/

/**
  |============================
  | AJAX
  |============================
*/
/* 
AJAX (Asynchronous JavaScript and XML) - метод получения или отправки данных с последующим обновлением интерфейса по этим данным, 
без необходимости перезагрузки страницы. За счет этого уменьшается время отклика и веб-страница становится более интерактивной. 
Этот процесс можно разобрать на примере подгрузки данных.

На веб-странице происходит событие (страница загружается, нажимается кнопка «Показать больше», отправляется форма и т. п.).
На клиенте, с помощью JavaScript, реакцией на это событие выполнятся функция для работы с сервером, где создается и отправляется 
HTTP-запрос.
Сервер получает и обрабатывает HTTP-запрос, отправляя обратно в ответе данные в формате JSON.
На клиенте, с помощью JavaScript, ответ от сервера обрабатывается, считываются данные и обновляется интерфейс.
ИНТЕРЕСНО
Несмотря на то, что в названии технологии присутствует XML, в современном вебе его заменил JSON, а название оставили 
как дань памяти. Под AJAX подразумевают любое общение с сервером без перезагрузки страницы.



----- Fetch API -----
Встроенный в браузер интерфейс доступный на объекте window, который содержит набор свойств и методов для отправки, 
получения и обработки ресурсов от сервера. 

Метод fetch() предоставляет современный интерфейс для составления запросов к серверу и построен на промисах.

fetch(url, options)

url - путь к данным на бэкенде которые необходимо получить, создать или изменить. Обязательный аргумент.
options - объект настроек запроса: метод (по умолчанию GET), заголовки, тело и т. д. Необязательный аргумент.
Будем делать запросы к JSONPlaceholder API - публичному REST API для быстрого прототипирования, который 
предоставляет коллекцию не настоящих пользователей в ресурсе /users.

fetch("https://jsonplaceholder.typicode.com/users")
  .then(response => {
    // Response handling
  })
  .then(data => {
    // Data handling
  })
  .catch(error => {
    // Error handling
  });




----- Проверка ответа -----
Значение промиса, который возвращает метод fetch(), это объект со служебной информацией о состоянии ответа сервера. 
Экземпляр класса Response, снабжен различными методами и свойствами. В зависимости от типа получаемого контента, 
используется различный метод для преобразования тела ответа в данные.

json() - парсит данные в JSON-формате.
text() - парсит данные в простом текстовом формате, например .csv (табличные данные).
blob() - парсит данные описывающие файл, например изображение, аудио или видео.

В певом методе then() выполняется проверка статуса ответа и преобразование данных в правильный формат, или явное создание 
ошибки чтобы обработать неудачный HTTP-запрос в блоке catch().

fetch("https://jsonplaceholder.typicode.com/users")
  .then(response => {
    if (!response.ok) {
      throw new Error(response.status);
    }
    return response.json();
  })
  .then(data => {
    // Data handling
  })
  .catch(error => {
    // Error handling
  });

ИНТЕРЕСНО
Это необходимо для того, чтобы fetch() правильно среагировал на статус код 404, который технически не является ошибкой, 
но для клиента это не успешный результат.




Вкладка Network
В инструментах разработчика на вкладке Network отображаются все выполняющиеся на странице HTTP-запросы.
Выбрав фильтр XHR, останутся только запросы к бэкенду. После нажатия кнопки в примере, через некоторое время, 
запрос отобразится в списке. Выбрав его можно посмотреть служебную информацию и тело ответа на подвкладках 
Headers, Preview и Response.



----- Работа с публичным REST API -----
Каждый бэкенд уникален, их тысячи. С другой стороны REST API построены по стандартной архитектуре. Это значит, что можно 
понять принцип их работы, после чего, все что нужно сделать - это ознакомиться с документацией того бэкенда, 
который необходимо использовать.

Продолжим работать с JSONPlaceholder API. Из документации берем URL ресурса для запроса информации о коллекции не 
настоящих пользователей.

https://jsonplaceholder.typicode.com/users

Этот путь состоит из следующих частей:

https://jsonplaceholder.typicode.com - это эндпоинт, базовый URL, точка входа в API.
/users - ресурс, к которому мы обращаемся.
По клику на кнопку «Fetch users» сделаем GET-запрос и отрисуем список пользователей по полученным данным.

const fetchUsersBtn = document.querySelector(".btn");
const userList = document.querySelector(".user-list");

fetchUsersBtn.addEventListener("click", () => {
  fetchUsers()
    .then((users) => renderUsers(users))
    .catch((error) => console.log(error));
});

function fetchUsers() {
  return fetch("https://jsonplaceholder.typicode.com/users").then(
    (response) => {
      if (!response.ok) {
        throw new Error(response.status);
      }
      return response.json();
    }
  );
}

function renderUsers(users) {
  const markup = users
    .map((user) => {
      return `<li>
          <p><b>Name</b>: ${user.name}</p>
          <p><b>Email</b>: ${user.email}</p>
          <p><b>Company</b>: ${user.company.name}</p>
        </li>`;
    })
    .join("");
  userList.insertAdjacentHTML("beforeend", markup);
}

Обратите внимание на то, что функция fetchUsers() возвращает промис, поэтому на результат её вызова мы добавляем 
цепочку методов then() и catch().




Ошибка новичка
Разберем распространенную ошибку при работе с асинхронным кодом - попытку использовать данные HTTP-запроса вне 
коллбэка метода then(). Новичок пытается записать «результат fetch» во внешнюю пременную и использовать её ниже по коду
 сразу за вызовом метода fetch().

let globalVariable; // undefined

// Initializing data fetching
fetch("https://jsonplaceholder.typicode.com/users")
  .then(response => response.json())
  .then(users => {
    console.log("users inside then callback: ", users);

    // Writing the result to a global variable
    globalVariable = users;

    // Everything is ok here, the data is in the variable
    console.log("globalVariable inside fetch callback: ", globalVariable);
  });

// No async data here
console.log("globalVariable outside fetch: ", globalVariable); // undefined

Вне коллбэка метода then() данных нет, так как последний console.log() выполнится раньше чем придет ответ от сервера. 
В это время переменная globalVariable еще содержит undefined. 
!!!!! Значение выполнившегося промиса fetch() доступно только в коллбэке метода then(). !!!!!



----- Параметры строки запроса -----
Параметры запроса позволяют указать бекенду дополнительные критерии. Например, сколько элементов коллекции мы хотим получить 
в запросе, возможно необходимо добавить сортировку по какому-то свойству объекта, ограничить выборку и т. п. 
Список параметров запроса, их названия и возможные значения зависят от бэкенда и описаны в документации.

Символ ? указывает на старт параметров запроса. Каждый параметр это пара имя=значение. 
Символ & используется для указания смыслового «И», разделяя параметры в строке запроса.

const url = "https://jsonplaceholder.typicode.com/users?_limit=7&_sort=name";

Такой GET-запрос вернет массив из семи пользователей (всего их 10) отсортированных по имени (поле name) в алфавитном порядке. 
Подчеркивания в именах параметров специфичны для этого бэкенда, это не какой-то стандарт.



const fetchUsersBtn = document.querySelector(".btn");
const userList = document.querySelector(".user-list");

fetchUsersBtn.addEventListener("click", () => {
  fetchUsers()
    .then((users) => renderUsers(users))
    .catch((error) => console.log(error));
});

function fetchUsers() {
  return fetch(
    "https://jsonplaceholder.typicode.com/users?_limit=7&_sort=name"
  ).then((response) => {
    if (!response.ok) {
      throw new Error(response.status);
    }
    return response.json();
  });
}

function renderUsers(users) {
  const markup = users
    .map((user) => {
      return `
          <li>
            <p><b>Name</b>: ${user.name}</p>
            <p><b>Email</b>: ${user.email}</p>
            <p><b>Company</b>: ${user.company.name}</p>
          </li>
      `;
    })
    .join("");
  userList.insertAdjacentHTML("beforeend", markup);
}



Класс URLSearchParams
Параметров может быть много, и составлять из них одну длинную строку не удобно, как для читабельности, так и для её последующего редактирования. 
При составлении строки параметров создаётся экземпляр класса URLSearchParams и инициализируется объектом. 
Результатом будет специальный объект (итератор) с методами, который в строчном преобразовании возвращает результат вызова метода toString() - 
своё строчное представление.

const searchParams = new URLSearchParams({
  _limit: 5,
  _sort: "name",
});

console.log(searchParams.toString()); // "_limit=5&_sort=name"

const url = `https://jsonplaceholder.typicode.com/users?${searchParams}`;
console.log(url); // "https://jsonplaceholder.typicode.com/users?_limit=5&_sort=name"

В строчном виде свойства объекта станут параметрами и их значениями. Параметры будут разделены символом &. При интерполяции значения в шаблонных 
строках происходит его неявное преобразование к строке, поэтому не нужно вызывать метод toString() при составлении URL. 
Не забывайте указывать начало строки запроса символом ?.




----- HTTP-заголовки -----
Класс Headers позволяет выполнять различные действия в заголовках HTTP-запроса и ответа. Эти действия включают в себя извлечение, настройку, 
добавление и удаление заголовков.

const headers = new Headers({
  "Content-Type": "application/json",
  "X-Custom-Header": "custom value",
});

headers.append("Content-Type", "text/bash");
headers.append("X-Custom-Header", "custom value");
headers.has("Content-Type"); // true
headers.get("Content-Type"); // "text/bash"
headers.set("Content-Type", "application/json");
headers.delete("X-Custom-Header");

На практике для составления заголовков запроса обычно использут просто литерал объекта со свойствами. 
В таком случае методов не будет, что зачастую и не требуется.

const headers = {
  "Content-Type": "application/json",
  "X-Custom-Header": "custom value",
};

Запрос с использованием заголовков будет выглядеть так.

fetch("https://jsonplaceholder.typicode.com/users", {
  headers: {
    Accept: "application/json",
  },
}).then(response => {
  // ...
});

ИНТЕРЕСНО
Современные браузеры добавляют много заголовков по умолчанию, в зависимости от операции и тела запроса, поэтому нет необходимости явно указывать 
стандартные заголовки.
*/

/**
  |============================
  | Кросс-доменные запросы
  |============================
*/
/* 
По умолчанию HTTP-запрос можно делать только в рамках текущего сайта. При попытке запроса на другой домен, порт или протокол, 
то есть выполнить кросс-доменный запрос - браузер выдаёт ошибку. Это сделано из соображений безопасности и права доступа настраиваются на бэкенде. 
Если бэкенд не поддерживает кросс-доменные запросы, то фронтенд-разработчик ничего не сможет с этим сделать в своем коде.

ИНТЕРЕСНО
Эта политика браузеров называется CORS и расшифровывается как Cross-Origin Resource Sharing, где Origin это и есть домен, порт или протокол. 
Дословный перевод звучит как «совместное использование ресурсов между разными источниками».

При каждом запросе браузер сам добавляет HTTP-заголовок Origin, где указывает адрес веб-страницы которая хочет сделать HTTP-запрос. 
Например, если мы делаем fetch-запрос с веб-страницы https://my-site.com/about на https://my-api.com/users, то заголовки будут следующими.

GET /users
Host: my-api.com
Origin: https://my-site.com

Сервер проверяет заголовок Origin и, если он поддерживает кросс-доменные запросы, добавляет в ответ специальный HTTP-заголовок Access-Control-Allow-Origin.

# Private API
Access-Control-Allow-Origin: https://my-site.com

# Public API
Access-Control-Allow-Origin: *

Значением этого заголовка будет разрешенный источник (Origin). В нашем случае это должен быть один сайт https://my-site.com, если бэкенд приватный, 
или спецсимвол *, если бэкенд публичный - разрешает делать запросы кому угодно.


То есть браузер это некий посредник между JavaScript-кодом и бэкендом. Он добавляет каждому запросу заголовок Origin с правильным значением и 
проверяет наличие заголовка Access-Control-Allow-Origin в ответе. Если заголовок есть и его значение подходит, выполнится оригинальный запрос 
и JavaScript-код получит его результат, в противном случае будет ошибка CORS.
*/

/**
  |============================
  | Пагинация
  |============================
*/
/* 
База данных может хранить коллекции состоящие из сотен миллионов записей. Поэтому возвращать всю коллекцию на каждый GET-запрос слишком ресурсозатратно. 
Размер тела ответа будет слишком большой, и время запроса затянется на десятки секунд, а то и минуты - чем больше в ответе от бэкенда данных, тем дольше 
он идет по сети.

Кроме этого, необходимо думать о пользователях - врядле им нужны все миллионы записей сразу. Обработка такого большого количества данных в ответе и 
отрисовка интерфейса потребует огромных ресурсов устройства на котором просматривается веб-страница. По статистике пользователи находят интересующую 
их информацию на нескольких первых экранах.

Допустим наш бекенд my-api.com хранит очень большую коллекцию постов в ресурсе /posts, которую представим двенадцатью элементами на иллюстрации.
https://textbook.edu.goit.global/javascript-yk5evp/v2/img/lesson-20/no-pagination.png

На каждый GET-запрос бэкенду придется вернуть всю коллекцию и мы столкнемся с проблемами описанными ранее. Для их решения и существует пагинация
- приём, при котором на первый и каждый последующий GET-запрос возвращается не вся коллекция, а определённая её часть. 
Пагинация реализуется на бэкенде и используется на фронтенде при помощи специальных параметров запроса.



----- Количество элементов ответа -----
Первый параметр определяет количество элементов в ответе от бэкенда. Пусть, в нашем случае, он называется per_page. Стандарта именования 
параметров пагинации нет, поэтому их имена зависят от бэкенд разработчика.
https://textbook.edu.goit.global/javascript-yk5evp/v2/img/lesson-20/per-page-param.png



В таком GET-запросе бэкенд вернет не всю коллекцию из двенадцати элементов, а только первые четыре. 
Если передать отрицательное значение или значение большее чем количество элементов в коллекции, то бэкенд может ответить по разному - 
проигнорировать их или вернуть ошибку 400 (BAD REQUEST), зависит от его реализации.

Публичный JSONPlaceholder API так же поддерживает пагинацию - количество элементов в ответе контролируерт параметр _limit. 
Всего в коллекции /posts есть сто элементов. Изменяйте значение параметра _limit в примере и исследуйте ответ бэкенда в интерфейсе и на вкладке Network.

const fetchPostsBtn = document.querySelector(".btn");
const postList = document.querySelector(".posts");

fetchPostsBtn.addEventListener("click", () => {
  fetchPosts()
    .then((posts) => renderPosts(posts))
    .catch((error) => console.log(error));
});

function fetchPosts() {
  // Change the number of items in the group here
  return fetch("https://jsonplaceholder.typicode.com/posts?_limit=5").then(
    (response) => {
      if (!response.ok) {
        throw new Error(response.status);
      }
      return response.json();
    }
  );
}

function renderPosts(posts) {
  const markup = posts
    .map(({ id, title, body, userId }) => {
      return `<li>
          <h2 class="post-title">${title.slice(0, 30)}</h2>
          <p><b>Post id</b>: ${id}</p>
          <p><b>Author id</b>: ${userId}</p>
          <p>${body}</p>
        </li>`;
    })
    .join("");
  postList.innerHTML = markup;
}



----- Номер группы элементов -----
Указав желаемое количество элементов в ответе мы всегда получим одинаковый результат - первые per_page элементов коллекции, так называемую первую 
группу или «страницу». Второй параметр пагинации контролирует смещение внутри коллекции - номер группы элементов которую мы хотим получить. 
Если бэкенд реализует пагинацию, то значение этого параметра по умолчанию единица - первая группа или «страница» элементов. 
Пусть в нашем случае он называется page.
https://textbook.edu.goit.global/javascript-yk5evp/v2/img/lesson-20/page-param.png



Изменяя значение параметра page мы уточняем бэкенду какую следующую группу элементов хотим получить, и так пока в коллекции не закончатся элементы.
Если задать отрицательное значение или больше чем групп в коллекции - ответ бекенда будет зависеть от его реализации.

В JSONPlaceholder API параметр контролирующий группу элементов называется _page. Изменяйте его значение в примере и исследуйте ответ бэкенда 
в интерфейсе и на вкладке Network.


const fetchPostsBtn = document.querySelector(".btn");
const postList = document.querySelector(".posts");

fetchPostsBtn.addEventListener("click", () => {
  fetchPosts()
    .then((posts) => renderPosts(posts))
    .catch((error) => console.log(error));
});

function fetchPosts() {
  const params = new URLSearchParams({
    _limit: 5,
    // Change the group number here
    _page: 3
  });

  return fetch(`https://jsonplaceholder.typicode.com/posts?${params}`).then(
    (response) => {
      if (!response.ok) {
        throw new Error(response.status);
      }
      return response.json();
    }
  );
}

function renderPosts(posts) {
  const markup = posts
    .map(({ id, title, body, userId }) => {
      return `<li>
          <h2 class="post-title">${title.slice(0, 30)}</h2>
          <p><b>Post id</b>: ${id}</p>
          <p><b>Author id</b>: ${userId}</p>
          <p class="post-body">${body}</p>
        </li>`;
    })
    .join("");
  post.innerHTML = markup;
}


ИНТЕРЕСНО
Для того чтобы знать когда закончатся элементы в коллекции и вывести об этом сообщение пользователю, бэкенд в каждом ответе возвращает 
не только массив элементов, но и метаданные про доступное количество групп («страниц»), зависящее от значения параметра per_page, или 
просто общее количество элементов в коллекции, тогда вычисление количества групп ложится на плечи фронтенд разработчика. К сожалению 
JSONPlaceholder API не реализует этот функционал.



----- Приём «Загрузить ещё» -----
Для того чтобы динамически изменять номер группы на каждый последующий запрос, достаточно объявить еще одну глобальную переменную, назвем её page 
и установим начальное значение 1 - первая группа элементов. После каждого успешного запроса, в коллбэке метода then() будем увеличивать значение 
page на единицу. При составлении параметров запроса используем её значение.


const fetchPostsBtn = document.querySelector(".btn");
const postList = document.querySelector(".posts");

// Controls the group number
let page = 1;
// Controls the number of items in the group
let perPage = 10;

fetchPostsBtn.addEventListener("click", () => {
  fetchPosts()
    .then((posts) => {
      renderPosts(posts);
      // Increase the group number
      page += 1;

      // Replace button text after first request
      if (page > 1) {
        fetchPostsBtn.textContent = "Fetch more posts";
      }
    })
    .catch((error) => console.log(error));
});

function fetchPosts() {
  const params = new URLSearchParams({
    _limit: perPage,
    _page: page
  });

  return fetch(`https://jsonplaceholder.typicode.com/posts?${params}`).then(
    (response) => {
      if (!response.ok) {
        throw new Error(response.status);
      }
      return response.json();
    }
  );
}

function renderPosts(posts) {
  const markup = posts
    .map(({ id, title, body, userId }) => {
      return `<li>
          <h2 class="post-title">${title.slice(0, 30)}</h2>
          <p><b>Post id</b>: ${id}</p>
          <p><b>Author id</b>: ${userId}</p>
          <p class="post-body">${body}</p>
        </li>`;
    })
    .join("");
  postList.insertAdjacentHTML("beforeend", markup);
}

После загрузки первой группы элементов, текст на кнопке измениться, а сама кнопка опустится под список постов. Когда пользователь прокрутит страницу 
и опять кликнет по ней - выполнится запрос за второй группой элементов, которая добавиться к уже существующей разметке списка постов. 
Если при клике на кнопку «Fetch posts» постов для загрузки больше нет - показываем оповещение.

Мы добавили проверку конца коллекции на фронтенде, потому что JSONPlaceholder API не реализует этот функционал на бэкенде. 
В нашем случае достаточно разделить общее количество элементов в коллекции на количество элементов в одной группе. 
Это похоже на случай, когда бэкенд возвращает не количество доступных страниц, а общее количество элементов в коллекции.
*/

/**
  |============================
  | CRUD
  |============================
*/
/* 
Для взаимодействия с ресурсами бэкенда используется четыре операции: создание (create), чтение (read), обновление (update) 
и удаление (delete). Для каждой из них определен стандартный HTTP-метод.

Method	      Description
-----         -----
POST	        Операция create - создать новый ресурс.
GET	          Операция read - получить набор ресурсов или один ресурс по идентификатору.
PUT и PATCH	  Операция update - обновить ресурс по идентификатору.
DELETE	      Операция delete - удалить ресурс по идентификатору

Будем делать запросы к JSONPlaceholder API, который предоставляет коллекцию не настоящих постов в ресурсе /posts, 
представленных объектами со свойствами id, author и body.



----- Чтение -----
HTTP-метод GET используется для получения существующих данных.
Метод fetch() должен отправить на сервер GET-запрос без тела. 
Бэкенд, по получению запроса, обработает его и в ответе вернет необходимые ресурсы.

Получим массив всех постов. Для этого обращаемся к ресурсу /posts описанному в документации бэкенда. 
Метод fetch() по умолчанию делает GET-запрос, поэтому переопределять опции запроса не обязательно.

fetch("https://jsonplaceholder.typicode.com/posts")
  .then(response => response.json())
  .then(posts => console.log(posts))
  .catch(error => console.log(error));

Получим один пост по идентификатору (свойство id) добавив его к ресурсу /posts/:postId. 
Последняя часть этого пути называется динамический параметр и в документации описывается как /ресурс/:параметр. 
Ресурс неизменен, это путь к целой коллекции, а значение параметра меняется для каждого её элемента.

// Change this number to fetch different post
const postId = 1;

fetch(`https://jsonplaceholder.typicode.com/posts/${postId}`)
  .then(response => response.json())
  .then(post => console.log(post))
  .catch(error => console.log(error));




----- Создание -----
Метод POST используется для добавления нового ресурса. 
Метод fetch() должен отправить на сервер POST-запрос, в теле которого будет объект с полями author и body, 
идентификатор будет автоматически создан базой данных. Результатом такого запроса будет объект добавленный в базу данных.

const postToAdd = {
  author: "Mango",
  body: "CRUD is awesome",
};

const options = {
  method: "POST",
  body: JSON.stringify(postToAdd),
  headers: {
    "Content-Type": "application/json; charset=UTF-8",
  },
};

fetch("https://jsonplaceholder.typicode.com/posts", options)
  .then(response => response.json())
  .then(post => console.log(post))
  .catch(error => console.log(error));

Делаем запрос на создание поста обращаясь к ресурсу /posts, но в настройках метода fetch() изменяем HTTP-метод на POST. 
Так бэкенд знает, что нужно не прочитать уже существующее, а создать новый ресурс в этой коллекции.

Тело запроса должно быть строкой, потому что протокол HTTP передает все как текст. 
При передаче сложных типов данных, их обязательно необходимо привести к строке методом JSON.stringify(). 
Не забываем указать заголовок Content-Type, который уточняет для бэкенда тип передаваемых данных.

В ответ, если все хорошо, получим JSON с добавленным id. Идентификатор будет уникальным для каждого объекта.

{
  "id": 1,
  "author": "Mango",
  "content": "CRUD is awesome"
}




----- Обновление -----
Методы PUT и PATCH используются для обновления существующих данных. Какой метод использовать будет написано в документации бэкенда. 
Метод fetch() должен отправить на сервер запрос, в теле которого необходимо указать объект с полями для изменения. 
Путь указывает в какой коллекции и какой элемент мы хотим обновить. Бекенд, по получению запроса, обработает его и в ответе 
вернет обновленный ресурс.

// Change value of id property to update different post
const postToUpdate = {
  id: 1,
  body: "CRUD is really awesome",
};

const options = {
  method: "PATCH",
  body: JSON.stringify(postToUpdate),
  headers: {
    "Content-Type": "application/json; charset=UTF-8",
  },
};

fetch(`https://jsonplaceholder.typicode.com/posts/${postToUpdate.id}`, options)
  .then(response => response.json())
  .then(post => console.log(post))
  .catch(error => console.log("ERROR" + error));

В ответ, если все хорошо, получим обновленный объект.

{
  id: 1,
  author: 'Mango',
  content: 'CRUD is really awesome',
}

ИНТЕРЕСНО
Метод PATCH заменяет в существующем ресурсе значения переданные в теле запроса свойств. Метод PUT полностью заменяет ресурс.




----- Удаление -----
Метод DELETE используется для удаления существующих данных.
Метод fetch() должен отправить на сервер DELETE-запрос без тела. Путь указывает в какой коллекции и какой элемент мы хотим удалить. 
Бекенд, по получению запроса, обработает его, удалит ресурс из коллекции и в ответе вернет статус результата.

const postIdToDelete = 1;

fetch(`https://jsonplaceholder.typicode.com/posts/${postIdToDelete}`, {
  method: "DELETE",
})
  .then(() => console.log("Post deleted"))
  .catch(error => console.log("Error:", error));
*/

/**
  |============================
  | Асинхронные функции
  |============================
*/
/* 
Работа с бэкендом может быть запутанной, после одной асинхронной операции необходимо сделать еще один запрос на сервер 
по полученным данным, и так несколько раз. Например, на странице профиля пользователь хочет посмотреть список друзей. 

Первое, что необходимо сделать, это подтвердить его права доступа к этой странице у бэкенда. Для этого нужно сделать 
запрос к my-api.com/me. Если бэкенд разрешит доступ, в ответе мы получим уникальный токен доступа к защищенным ресурсам.

const fetchFriends = () => {
  return fetch("my-api.com/me").then(token => {
    console.log(token);
  });
};

Далее необходимо запросить профиль пользователя от my-api.com/profile, но профиль не полный, он содержит только критически 
важную информацию - идентификатор пользователя, без списка друзей.

const fetchFriends = () => {
  return fetch("my-api.com/me")
    .then(token => {
      return fetch(`my-api.com/profile?token=${token}`);
    })
    .then(user => {
      console.log(user.id);
    });
};

И только после этого можно запросить список друзей от my-api.com/users/:userId/friends.

const fetchFriends = () => {
  return fetch("my-api.com/me")
    .then(token => {
      return fetch(`my-api.com/profile?token=${token}`);
    })
    .then(user => {
      return fetch(`my-api.com/users/${user.id}/friends`);
    });
};

fetchFriends()
  .then(friends => console.log(friends))
  .catch(error => console.error(error));

Согласитесь, не самый легкочитаемый код, хотя операции относительно простые. 
Из-за того, что мы передаем функции-обработчики методу then(), получаются ёлки вложенности.

Асинхронные функции помогают избавиться от коллбэков и вложенных конструкций. 
При этом они отлично работают в связке с методами then() и catch(), потому что гарантированно возвращают промис.

const fetchFriends = async () => {
  const token = await fetch("my-api.com/me");
  const user = await fetch(`my-api.com/profile?token=${token}`);
  const friends = await fetch(`my-api.com/users/${user.id}/friends`);
  return friends;
};

fetchFriends()
  .then(friends => console.log(friends))
  .catch(error => console.error(error));





-----  Синтаксис async/await  -----
Асинхронные функции (async/await) - удобный способ написания асинхронного кода, который внешне становится похож на синхронный. 
В основе синтаксиса async/await лежат промисы, поэтому он не блокирует главный поток выполнения программы.

Для объявления асинхронной стрелочной функции, перед списком параметров добавляем ключевое слово async. 
Внутри неё можно использовать оператор await и справа от него поставить что-то, что вернёт промис. 
Метод response.json() также возвращает промис, поэтому ставим await.

const fetchUsers = async () => {
  const response = await fetch("https://jsonplaceholder.typicode.com/users");
  const users = await response.json();
  return users;
};

fetchUsers().then(users => console.log(users));

Когда интерпретатор встречает await, он приостановливает выполнение этой функции (не всего скрипта) и ждет, пока не выполнится 
промис справа от await. Как только промис выполнился - исполнение функции возобновляется и на строке ниже нам доступен 
результат асинхронной операции.

Оператор await можно использовать только в теле асинхронной (async) функции.
Оператор await приостанавливает функцию пока промис не выполнится (fulfilled или rejected).
Если промис выполнился успешно (fulfilled), оператор await вернет его значение.
Если промис был отклонен с ошибкой (rejected), оператор await выбросит ошибку.
Асинхронная функция всегда возвращает промис, поэтому любое возвращаемое значение будет его значением.
Если не указать возвращаемое значение, вернется промис со значением undefined.
Любая функция может быть асинхронной, будь-то метод обьекта, класса, коллбэк, объявление или инлайн функция. 
Все они смогут использовать оператор await и обязательно вернут промис, потому что будут асинхронными функциями.

// Function declaration
async function foo() {
  // ...
}

// Functional expression
const foo = async function () {
  // ...
};

// Arrow function
const foo = async () => {
  // ...
};

// Object method
const user = {
  async foo() {
    // ...
  },
};

// Class method
class User {
  async foo() {
    // ...
  }
}




----- Обработка ошибок -----
Если результат асинхронной функции (промис) не используется во внешнем коде, ошибки обрабатываются в теле функции 
конструкцией try...catch. Значение параметра error в блоке catch это ошибка которую сгенерирует await если промис будет отклонен.

const fetchUsers = async () => {
  try {
    const response = await fetch("https://jsonplaceholder.typicode.com/users");
    const users = await response.json();
    console.log(users);
  } catch (error) {
    console.log(error.message);
  }
};

fetchUsers();

Если результат асинхронной функции (промис) используется во внешнем (глобальном) коде, то есть вне других асинхронных функций, 
ошибки обрабатываются коллбэком методом catch(). 
Значение параметра error в методе catch() это ошибка которую сгенерирует await если промис будет отклонен.

const fetchUsers = async () => {
  const response = await fetch("https://jsonplaceholder.typicode.com/users");
  const users = await response.json();
  return users;
};

fetchUsers()
  .then(users => console.log(users))
  .catch(error => console.log(error));

Так работать не будет - await можно использовать только в теле асинхронной функции.

const fetchUsers = async () => {
  const response = await fetch("https://jsonplaceholder.typicode.com/users");
  const users = await response.json();
  return users;
};

// ❌ SyntaxError: await is only valid in async function
const users = await fetchUsers();

Если результат асинхронной функции используется в другой асинхронной функции, ошибки обрабатываются конструкцией try...catch. 
Значение параметра error в блоке catch это ошибка которую сгенерирует await если промис будет отклонен.

const fetchUsers = async () => {
  const response = await fetch("https://jsonplaceholder.typicode.com/users");
  const users = await response.json();
  return users;
};

const doStuff = async () => {
  try {
    const users = await fetchUsers();
    console.log(users);
  } catch (error) {
    console.log(error.message);
  }
};

doStuff();




----- Параллельные запросы -----
Если одновременно необходимо сделать несколько запросов, использовать синтаксис async/await нужно очень аккуратно. 
В следующем примере будут выполнены три последовательных запроса, потому что выполнение асинхронной функции приостанавливается 
когда интерпретатор встречает await. Кроме того, парс результатов запросов также будет последовательный, что займет больше времени.

const fetchUsers = async () => {
  const baseUrl = "https://jsonplaceholder.typicode.com";
  const firstResponse = await fetch(`${baseUrl}/users/1`);
  const secondResponse = await fetch(`${baseUrl}/users/2`);
  const thirdResponse = await fetch(`${baseUrl}/users/3`);

  const firstUser = await firstResponse.json();
  const secondUser = await secondResponse.json();
  const thirdUser = await thirdResponse.json();

  console.log(firstUser, secondUser, thirdUser);
};

fetchUsers();

На вкладке Network хорошо видно, что запуск каждого последующего запроса ожидает пока завершится предыдущий. 
То есть выолняются они последовательно, что занимает больше времени, которое равно сумме длительностей всех запросов. 
Это нормально, если запросы зависят друг от друга, то есть следующий использует результат предыдущего.

В нашем случае они полностью независимы, поэтому нужно запустить их параллельно. Для этого создаётся массив промисов, 
после чего используется метод Promise.all(), для ожидания их выполнения. 
Массив промисов создается методами map(), filter() и так далее, зависит от задачи.

const fetchUsers = async () => {
  const baseUrl = "https://jsonplaceholder.typicode.com";
  const userIds = [1, 2, 3];

  // 1. Создаём массив промисов
  const arrayOfPromises = userIds.map(async userId => {
    const response = await fetch(`${baseUrl}/users/${userId}`);
    return response.json();
  });

  // 2. Запускаем все промисы параллельно и ждем их завершения
  const users = await Promise.all(arrayOfPromises);
  console.log(users);
};

fetchUsers();

При таком подходе запросы запускаются параллельно, что экономит время ожидания их выполнения, которое равно длительности 
самого «медленного» из них. Такой приём подходит только если запросы не зависят друг от друга.




Убедитесь в этом, открыв инструменты разработчика в живом примере. Также мы добавили кнопку при клике на которую выполняется запрос, 
и обработали возможную ошибку конструкцией try...catch. Это стандартный AJAX-код с использованием асинхронных функций.

const fetchUsersBtn = document.querySelector(".btn");
const userList = document.querySelector(".user-list");

fetchUsersBtn.addEventListener("click", async () => {
  try {
    const users = await fetchUsers();
    renderUserListItems(users);
  } catch (error) {
    console.log(error.message);
  }
});

async function fetchUsers() {
  const baseUrl = "https://jsonplaceholder.typicode.com";
  const userIds = [1, 2, 3, 4, 5];

  const arrayOfPromises = userIds.map(async (userId) => {
    const response = await fetch(`${baseUrl}/users/${userId}`);
    return response.json();
  });

  const users = await Promise.all(arrayOfPromises);
  return users;
}

function renderUserListItems(users) {
  const markup = users
    .map(
      (user) => `<li class="item">
        <p><b>Name</b>: ${user.name}</p>
        <p><b>Email</b>: ${user.email}</p>
        <p><b>Company</b>: ${user.company.name}</p>
      </li>`
    )
    .join("");
  userList.innerHTML = markup;
}
*/
