/**
  |============================
  | Подключение скрипта
  |============================
*/
/* Чтобы подключить JavaScript из внешнего файла:

Создайте файл с расширением .js и поместите его в подпапку js.
Затем укажите путь к файлу скрипта в атрибуте src тега script.
Cкрипт подключают перед закрывающим тегом <body> после всего содержимого

<script src="js/script.js"></script> 

Если скрипт подключен в <head>, отрисовка страницы останавливается до тех пор, пока скрипт не загрузится и выполнится полностью.
*/ /**
  |============================
  | Синтаксис
  |============================
*/
/* 
Инструкция (statement) - это связанный набор слов и символов из синтаксиса языка, которые объединяются чтобы выразить одну идею, 
одну инструкцию для машины.
a = b * 2;
    a и b - переменные (как в алгебраическом уравнении), это хранилища данных, которые использует программа. Переменная состоит 
            из идентификатора (имени) и связанного с ним значения.
    2 - просто число. Это называется значением литерала (literal value), так как не хранится в переменной.
    = и * - операторы, производят действия над значениями и переменными.

Инструкции состоят из частей, как в любом языке предложения состоят из фраз, и эти фразы называются выражениями.
Выражение (expression) - ссылка на переменную или значение, или на набор переменных и значений в сочетании с операторами.

Интерфейс - это набор свойств и методов сущности, доступных для использования в исходном коде.

Свойство
У нас с вами есть свойства: рост, вес, цвет глаз, то есть какие-то описательные характеристики. Так же и у данных есть свойства, 
например у строки есть свойство ее длины. Синтаксис обращения к свойству очень простой - через точку.
сущность.имя_свойства
Для наглядности обратимся к свойству строки length, которое содержит кол-во символов строки.
"JavaScript is awesome".length;

Метод
Это вызов действия, например присесть или плавать, то есть какая-то активная операция. Так же и у данных есть свои заранее 
определённые методы, например можно добавить или удалить элементы из коллекции, перевести строку в разный регистр и т. д. 
Синтаксис вызова метода очень похож на обращение к свойству, но в конце добавляется пара круглых скобок.
сущность.имя_метода()
Для примера обратимся к методу строки toUpperCase(), который сделает все буквы заглавными.
"JavaScript is awesome".toUpperCase();

Строгий режим
Новая возможность в спецификации ECMAScript 5, которая позволяет переводить скрипт в режим полного соответствия современному стандарту. 
Это предотвращает определенные ошибки, такие как использование небезопасных и устаревших конструкций.
Для того, чтобы перевести скрипт в строгий режим, достаточно указать директиву в начале js-файла. 
Всегда пишите код в строгом режиме.

script.js
"use strict";
// Это комментарий. Дальше идет весь код JS-файла
*/
/**
  |============================
  | Переменные и типы
  |============================
*/
/* 
Переменные используются для хранения данных и состоят из идентификатора (имени) и области в памяти, где хранится их значение.

Идентификатор - это имя переменной, функции или класса. Состоит из одного или нескольких символов в следующем формате.

Первым символом должна быть буква a-z или A-Z, символ подчеркивания _ или знак доллара $.
Другие символы могут быть буквами a-z, A-Z, цифрами 0-9, подчеркиваниями _ и знаками доллара $.
Идентификаторы чувствительны к регистру. Это значит, что переменные user, usEr и User различны.

Использование camelCase-нотации для идентификаторов это стандарт. Первое слово пишется строчными буквами, а каждое последующее 
начинается с заглавной. Например, user, greetUser, getUserData.

Как называть переменные:
https://bookflow.ru/kak-nazyvat-peremennye/

Есть список зарезервированных ключевых слов, которые имеют специальное значение и используются для определенных конструкций. 
Нельзя использовать ключевые слова как идентификаторы.
abstract	arguments	await	boolean
break	byte	case	catch
char	class	const	continue
debugger	default	delete	do
double	else	enum	eval
export	extends	false	final
finally	float	for	function
goto	if	implements	import
in	instanceof	int	interface
let	long	native	new
null	package	private	protected
public	return	short	static
super	switch	synchronized	this
throw	throws	transient	true
try	typeof	var	void
volatile	while	with	yield

Объявление переменной начинается с ключевого слова const. Такая переменная должна быть сразу инициализирована значением, после 
чего его нельзя переопределить.
Переменные, объявленные как const, обязательно должны быть инициализированы значением во время объявления, иначе будет ошибка.

const yearOfBirth = 2006;

Для того, чтобы объявить переменную, которой в будущем можно будет присвоить новое значение, используется ключевое слово let.
Переменным, объявленным через let, не обязательно сразу присваивать значение.

let age;

Если переменной, объявленной как let, изначально не присвоено значение, она инициализируется специальным значением undefined (не определено).

константы и КОНСТАНТЫ
Имена КОНСТАНТ - переменных, значение которых не изменяется никогда на протяжении работы всего скрипта, обычно записываются 
в формате UPPER_SNAKE_CASE.
Абсолютное большинство переменных – константы в другом смысле, они просто не изменяют значение после присвоения. 
Но при разных запусках скрипта, это значение может быть разным. Имена таких переменных записывают используя формат camelCase.

неопределенные и необъявленные переменные
Неопределенная (undefined) - это переменная, которая была объявлена ключевым слово let, но не инициализирована значением. 
По умолчанию ей присваивается начальное значение undefined.
Необъявленная (undeclared или not defined) - это переменная, которая не была объявлена в доступной области видимости. Попытка обратиться 
к пременной до её объявления вызовет ошибку. Например, чтобы прочитать или изменить её значение.

Примитивные типы
- Number - целые числа и числа с плавающей запятой (точкой).
const age = 20;
- String - строки, последовательность из нуля или более символов. Строка начинается и заканчивается одиночной ', или двойными кавычками ".
const username = "Mango";
- Boolean - логический тип данных, флаги состояния. Всего два значения: true и false. 
const isLoggedIn = true;
- null - особое значение, которое по сути значит ничто. Используется в тех ситуациях, когда необходимо явно указать пустоту. 
К примеру если пользователь ещё ничего не выбрал, то можно сказать что значение null.
let selectedProduct = null;
- undefined - ещё одно специальное значение. По умолчанию, когда переменная объявляется, но не инициализируется, ее значение 
не определено, ей присваивается undefined.
let username;
console.log(username); // undefined

Оператор typeof
Используется для получения типа значения переменной. Возвращает на место своего вызова тип значения переменной указанного после 
него - строку в которой указан тип.
let username;
console.log(typeof username); // "undefined"
let inputValue = null;
console.log(typeof inputValue); // "object"
*/
/**
  |============================
  | Взаимодействие с пользователем
  |============================
*/
/* 
Вывод данных
Для вывода данных есть два метода: console.log() и alert(). 
В круглых скобках указываем имя переменной, значение которой необходимо вывести.
Можно сначала указать какую-то описательную строку, после чего поставить запятую и указать имя переменной.

const username = "Mango";
console.log("Username is ", username);

Метод alert() выводит модальное окно, текст которого соответствует значению переменной (или литерала) которую передадим в скобках.
const message = "JavaScript is awesome!";
alert(message);

Получение данных
Для получения данных от пользователя есть prompt() и confirm(). Это тоже методы из интерфейса window. 
Результатом своего выполнения они возвращают то, что было введено пользователем, поэтому результат их работы можно записать 
в переменную для дальнейшего использования.

confirm() - выводит модальное окно с сообщением, и две кнопки, Ok и Cancel. 
При нажатии на Ok, результатом будет true, при нажатии на Cancel - возвращается false.
const isComing = confirm("Please confirm hotel reservation");
console.log(isComing);

prompt() - выводит модальное окно с полем ввода и кнопками Ok и Cancel. При нажатии Ok, результатом будет то, что ввел пользователь, 
при Cancel - возвращается null.
const hotelName = prompt("Please enter desired hotel name");
console.log(hotelName);
Важная особенность prompt в том, что не зависимо что ввел пользователь, всегда вернется строка. То есть, если пользователь ввел 5, 
то вернется не число 5, а строка "5".
*/
/**
  |============================
  | Основные операторы
  |============================
*/
/* 
Математические операторы
Назначение, функционал и приоритет (порядок) операций ничем не отличаются от школьного курса алгебры. 
Операторы возвращают значение как результат выражения.
Важно запомнить термины составляющих выражения. + - * / % называются операторы, а то, на чем они применяются - операнды.
const x = 10;
const y = 5;
// Сложение
console.log(x + y); // 15
// Вычитание
console.log(x - y); // 5
// Умножение
console.log(x * y); // 50
// Деление
console.log(x / y); // 2
// Остаток от деления
console.log(x % y); // 0
// Сложение с заменой (также есть для всех других операторов)
let value = 5;
// Аналогично записи value = value + 10;
value += 10;
console.log(value); // 15

Операторы сравнения
Используются для сравнения двух значений. Результатом своего выполнения возвращают буль - true или false, то есть «да» или «нет».

a > b и a < b - больше/меньше
a >= b и a <= b - больше/меньше или равно
a == b - равенство
a != b - неравенство
a === b - строгое равенство
a !== b - строгое неравенство

const x = 5;
const y = 10;
const z = 5;

console.log("x > y:", x > y); // false
console.log("x < y:", x < y); // true
console.log("x < z:", x < z); // false
console.log("x <= z:", x <= z); // true
console.log("x === y:", x === y); // false
console.log("x === z:", x === z); // true
console.log("x !== y:", x !== y); // true
console.log("x !== z:", x !== z); // false

«Нестрогие» операторы равенства == и != выполняют преобразование типов сравниваемых значений к числу, что может привести к ошибкам, 
особенно у начинающих.
console.log(5 == "5"); // true
console.log(5 != "5"); // false
На следующей иллюстрации показана таблица сравнения значений используя операторы нестрогого равенства.
https://textbook.edu.goit.global/javascript-yk5evp/v2/img/lesson-01/not-strict-equality.png

Поэтому для проверки равенства или неравенства двух значений используются только операторы === (строгое равенство) и 
!== (строгое неравенство), которые не выполняют приведение типов операндов.
console.log(5 === "5"); // false
console.log(5 === 5); // true
console.log(5 !== "5"); // true
В таком случае, все равно только себе. Перед оценкой ничего не преобразуется.
https://textbook.edu.goit.global/javascript-yk5evp/v2/img/lesson-01/strict-equality.png
*/
/**
  |============================
  | Числа
  |============================
*/
/* 
Все числа в JavaScript, как целые так и дробные, имеют тип Number и записывать их можно не только в десятичной системе счисления.

Приведение к числу
Большинство арифметических операций и математических функций преобразуют значение в число автоматически. 
Для того чтобы сделать это явно, используйте функцию Number(val), передавая ей в val то, что надо привести к числу.
Если значение не возможно привести к числу, результатом будет специальное числовое значение NaN (Not a Number). Аналогичным образом 
происходит преобразование и в других математических операторах и функциях.

const valueA = "5";
console.log(Number(valueA)); // 5
console.log(typeof Number(valueA)); // "number"

const valueB = "random string";
console.log(Number(valueB)); // NaN
console.log(typeof Number(valueB)); // "number"


Методы Number.parseInt() и Number.parseFloat()
Преобразуют строку символ за символом, пока это возможно. При возникновении ошибки возвращается число, которое получилось.

Метод Number.parseInt() парсит из строки целое число.
console.log(Number.parseInt("5px")); // 5
console.log(Number.parseInt("12qwe74")); // 12
console.log(Number.parseInt("12.46qwe79")); // 12
console.log(Number.parseInt("qweqwe")); // NaN

Метод Number.parseFloat() парсит из строки дробное число.
console.log(Number.parseFloat("5px")); // 5
console.log(Number.parseFloat("12qwe74")); // 12
console.log(Number.parseFloat("12.46qwe79")); // 12.46
console.log(Number.parseFloat("qweqwe")); // NaN

Функция Number - преобразует переданное значение в число. 
В случае строки пробельные символы по краям обрезаются, затем, если строку возможно преобразовать в число - то возвращается это число, 
а если нет - возвращается NaN. 
Значение true преобразуется к числу 1, значение false - к числу 0. 
Объекты при численных преобразованиях превращаются в NaN.
 
Преобразуем булевое значение true в число:
Number(true);
Результат выполнения кода:
1
 
А теперь давайте преобразуем булевое значение false:
Number(false);
Результат выполнения кода:
0
 
Давайте в параметр функции введем строку, содержащую число:
Number('53');
В результате преобразования мы получим число:
53
 
А теперь добавим к числу пробелы в начале и в конце строки:
Number(' 5 ');
После выполнения кода лишние пробелы удаляются и в итоге мы получаем число:
5
 
Давайте преобразуем пустую строку:
Number('');
Результат выполнения кода:
0
 
Теперь преобразуем строку, содержащую букву и цифру:
Number('a5');
После выполнения кода получаем значение NaN, показывающее недопустимую математическую операцию:
NaN
 
Давайте поменяем местами в строке букву и цифру:
Number('5a');
Результат выполнения кода останется прежним:
NaN
 
Теперь преобразуем строку, в которой числа разделены пробелом:
Number('5 5');
В результате выполнения кода мы опять увидим, что данная математическая операция недопустима:
NaN
 
Давайте преобразуем булевое значение true, заключенное в строку:
Number('true');
После выполнения кода снова получим NaN:
NaN
 
Теперь преобразуем пустой объект:
Number({});
Результат выполнения кода:
NaN
 
Давайте зададим в параметре функции пустой массив:
Number([]);
В результате мы получим число 0:
0
 
Теперь добавим в массив цифру:
Number([1]);
Массив преобразуется в число:
1
 
Давайте преобразуем массив, включающий две цифры:
Number([1, 2]);
В результате нам снова сообщат, что данная математическая операция недопустима:
NaN



Проверка на число
Для проверки на число можно использовать метод Number.isNaN(val). Он проверяет, является ли указанное значение NaN или нет. 
Метод отвечает на вопрос "Это Not A Number?" и возвращает:
true - если значение val это NaN
false - если значение val это не NaN
Этот метод не производит попытку преобразовать val к числу, а просто выполняет проверку на NaN.

const validNumber = Number("51"); // 51
console.log(Number.isNaN(validNumber)); // false

const invalidNumber = Number("qweqwe"); // NaN
console.log(Number.isNaN(invalidNumber)); // true



Сложение чисел с плавающей точкой

При сложении не целых чисел в JavaScript и других языках программирования, есть особенность. Если кратко, то 0.1 + 0.2 не равно 0.3, 
результат сложения больше чем 0.3. Все от того что машина считает в двоичной системе.
Число 0.1 в двоичной системе счисления - это бесконечная дробь, так как единица на десять в двоичной системе не делится. 
Двоичное значение бесконечных дробей хранится только до определенного знака, поэтому возникает неточность. При сложении 0.1 и 0.2, 
две неточности складываются, получается незначительная, но всё же ошибка в вычислениях.
console.log(0.1 + 0.2 === 0.3); // false
console.log(0.1 + 0.2); // 0.30000000000000004

Конечно, это не означает, что точные вычисления для таких чисел невозможны. Есть несколько методов решения этой проблемы.
Можно сделать их целыми, умножив на N, сложить, а потом результат разделить также на N.
console.log(0.17 + 0.24); // 0.41000000000000003
console.log((0.17 * 100 + 0.24 * 100) / 100); // 0.41
Еще один способ - сложить, а результат отсечь до определённого знака после запятой при помощи метода toFixed().
console.log(0.17 + 0.24); // 0.41000000000000003
console.log((0.17 + 0.24).toFixed(2)); // 0.41




Класс Math
Один из встроенных классов, который предоставляет набор методов для работы с числами.
// Math.floor(num) - возвращает наибольшее целое число, меньшее, либо равное указанному
console.log(Math.floor(1.7)); // 1

// Math.ceil(num) - возвращает наименьшее целое число, большее, либо равное указанному числу.
console.log(Math.ceil(1.2)); // 2

// Math.round(num) - возвращает значение числа, округлённое до ближайшего целого
console.log(Math.round(1.2)); // 1
console.log(Math.round(1.5)); // 2

// Math.max(num1, num2, ...) - возвращает наибольшее число из набора
console.log(Math.max(20, 10, 50, 40)); // 50

// Math.min(num1, num2, ...) - возвращает наименьшее число из набора
console.log(Math.min(20, 10, 50, 40)); // 10

// Math.pow(base, exponent) - возведение в степень 
console.log(Math.pow(2, 4)); // 16

// Math.random() - возвращает псевдослучайное число в диапазоне [0, 1)
console.log(Math.random()); // случайное число между 0 и 1
console.log(Math.random() * (10 - 1) + 1); // псевдослучайное число от 1 до 10

*/

/**
  |============================
  | Строки
  |============================
*/
/* 
Строка - это индексированный набор из нуля или более символов, заключенных в одинарные либо двойные кавычки.
const username = "Mango";
Важно помнить, что индексация элементов строки начинается с нуля. К примеру в строке "JavaScript" буква "J" стоит на позиции с индексом 0.
Содержимое строки нельзя изменить, только прочитать. То есть нельзя взять какой-то символ и заменить его, 
как только строка создана - она такая навсегда. Можно лишь создать целиком новую строку и присвоить в переменную вместо старой.

Конкатенация строк
Если применить оператор + к строке и любому другому типу данных, результатом операции «сложения» будет строка. 
Эта операция называется конкатенация, или сложение строк.
Во время конкатенации, любой тип данных приводится к строке и сшивается со строкой, но есть особенность - последовательность 
записи операндов.
Последовательность операций имеет значение, преобразование типов происходит только в момент операции сложения со строкой, 
до этого момента действуют привычные правила математики.

const message = "Mango " + "is" + " happy";
console.log(message); // Mango is happy
console.log(1 + "2"); // "12"
console.log(1 + "2" + 4); // "124"
console.log(1 + 2 + "4"); // "34"
В последнем примере произошла математическая операция сложения для первых двух чисел 1 и 2, после чего число 3 было преобразовано 
в строку "3" и сшито со строкой "4".



Шаблонные строки
Шаблонные строки это альтернатива конкатенации с более удобным синтаксисом. Шаблонная строка заключена в обратные (косые) 
кавычки вместо двойных или одинарных и может содержать местозаполнители, которые обозначаются знаком доллара и фигурными скобками 
- ${выражение}.

// Используя переменные необходимо составить строку с подставленными значениями
const guestName = "Манго";
const roomNumber = 207;
const greeting =  "Welcome " + guestName + ", your room number is " + roomNumber + "!";
console.log(greeting); // "Welcome Mango, your room number is 207!"

Составлять строки с подставляемыми значениями используя конкатенацию очень неудобно. 
На помощь приходят шаблонные строки и интерполяция.
const guestName = "Манго";
const roomNumber = 207;
const greeting = `Welcome ${guestName}, your room number is ${roomNumber}!`;
console.log(greeting); // "Welcome Mango, your room number is 207!"



Свойство length
Для того чтобы узнать длину строки, то есть количество её символов, у всех строк есть встроенное свойство length, 
значение которого можно получить обратившись к нему через точку после имени переменной или строкового литерала.

const message = "Welcome to Bahamas!";
console.log(message.length); // 19
console.log("There is nothing impossible to him who will try".length); // 47



Методы toLowerCase() и toUpperCase()
Возвращают новую строку в соответствующем регистре, не изменяя оригинальную строку.

const message = "Welcome to Bahamas!";
console.log(message.toLowerCase()); // "welcome to bahamas!"
console.log(message.toUpperCase()); // "WELCOME TO BAHAMAS!"
console.log(message); // "Welcome to Bahamas!"

Чтобы не требовать абсолютно точный ввод можно сделать «нормализацию» введённой пользователем строки, то есть преобразовать 
все её символы в верхний или нижний регистр. Методы строки toLowerCase() и toUpperCase() вернут новую строку в соответствующем 
регистре, не изменяя оригинальную.

const BRAND_NAME = "SAMSUNG";
const userInput = "saMsUng";
const normalizedToUpperCaseInput = userInput.toUpperCase();

console.log(userInput); // 'saMsUng'
console.log(userInput === BRAND_NAME); // false
console.log(normalizedToUpperCaseInput); // 'SAMSUNG'
console.log(normalizedToUpperCaseInput === BRAND_NAME); // true



Метод indexOf()
Возвращает позицию (индекс) на которой находится первое совпадение подстроки или -1, если ничего не найдено.
const message = "Welcome to Bahamas!";
console.log(message.indexOf("to")); // 8
console.log(message.indexOf("hello")); // -1



Метод includes()
Проверяет входит ли подстрока в строку, возвращает буль - true если входит и false в противном случае. 
Регистр символов в строке и подстроке имеет значение, так как например буква "a" не равна букве "А".

const productName = "Ремонтный дроид";
console.log(productName.includes("н")); // true
console.log(productName.includes("Н")); // false
console.log(productName.includes("дроид")); // true
console.log(productName.includes("Дроид")); // false
console.log(productName.includes("Ремонтный")); // true
console.log(productName.includes("ремонтный")); // false



Метод endsWith()
Позволяет определить, заканчивается ли строка символами (подстрокой) указанными в скобках, возвращая true или false.
const jsFileName = "script.js";
console.log(jsFileName.endsWith(".js")); // true
const cssFileName = "styles.css";
console.log(cssFileName.endsWith(".js")); // false



Методы replace() и replaceAll()
Возвращают новую строку, в которой первое (replace) или все совпадения (replaceAll) подстроки заменены на указанное значение.

const jsFileName = "script.js";
const minifiedJsFileName = jsFileName.replace(".js", ".min.js");
console.log(minifiedJsFileName); // "script.min.js"

const cssFileNames = "styles.css, about.css, portfolio.css";
const minifiedCssFileNames = cssFileNames.replaceAll(".css", ".min.css");
console.log(minifiedCssFileNames); // "styles.min.css, about.min.css, portfolio.min.css"



Метод slice()
Метод строк slice(startIndex, endIndex) используется для создания копии части или всей строки. 
Он делает копию элементов строки от startIndex и до, но не включая endIndex и возвращает новую строку, не изменяя оригинал.

const productName = "Repair droid";
console.log(productName.slice(0, 4)); // "Repa"
console.log(productName.slice(3, 9)); // "air dr"
console.log(productName.slice(0, productName.length)); // "Repair droid"
console.log(productName.slice(7, productName.length)); // "droid"
*/

/**
  |============================
  | Логические операторы
  |============================
*/
/* 
Логические операторы используются для проверки условий с множественными выражениями, например в операциях сравнения.

Приведение типов
В логических операциях осуществляется приведение типов операндов к true или false. 
Приведение происходит если в коде обнаружен логический оператор.
Truthy и Falsy - термины, которые используются для тех значений, которые, в логической операции, приводятся к true или false, 
хотя изначально не были булями.



Логическое «И»
Оператор && приводит все операнды к булю и возвращает значение одного из них. 
Левый операнд если его можно привести к false, и правый в остальных случаях.

выражение && выражение

В следующем примере оба условия вернут true, поэтому результатом всего выражения будет true - вернётся значение правого операнда.
const age = 20;
console.log(age > 10 && age < 30); // true && true -> true
Если хотябы один из операндов будет приведён к false, результатом выражения будет его значение.

const age = 50;
console.log(age > 10 && age < 30); // true && false -> false
console.log(age > 80 && age < 120); // false && true -> false
То есть логическое «И» запинается на лжи и возвращает то на чём запнулось или последний операнд.

console.log(1 && 5); // true && true -> 5
console.log(5 && 1); // true && true -> 1
console.log(0 && 2); // false && true -> 0
console.log(2 && 0); // true && false -> 0
console.log("" && "Mango"); // false && true -> ""
console.log("Mango" && ""); // true && false -> ""
console.log("Mango" && "Poly"); // true && true -> "Poly"
console.log("Poly" && "Mango"); // true && true -> "Mango"



Логическое «ИЛИ»
Оператор || приводит все операнды к булю и возвращает значение одного из них. 
Левый операнд если его можно привести к true, и правый в остальных случаях.

выражение || выражение

В следующем примере условие слева вернёт true, поэтому результатом всего выражения будет true - вернётся значение первого операнда 
которое было приведено к true.
const age = 5;
console.log(age < 10 || age > 30); // true || false -> true

Тут результатом тоже будет true, так как хотябы один из операндов, в этом случае правый, был приведён к true.
const age = 40;
console.log(age < 10 || age > 30); // false || true -> true

А здесь ни одно из условий не выполняется, поэтому получаем false - значение последнего операнда.
const age = 20;
console.log(age < 10 || age > 30); // false || false -> false

То есть логическое «ИЛИ» запинается на правде и возвращает то на чём запнулось или последний операнд.

console.log(true || false); // true
console.log(false || true); // true
console.log(true || true); // true

console.log(3 || false); // 3
console.log(false || 3); // 3
console.log(3 || true); // 3
console.log(true || 3); // true



Оператор нулевого слияния ??

Аналогичен оператору "ИЛИ" ||, но в качестве false воспринимает только null и undefined
То есть это логический оператор, возвращающий значение правого операнда, если значение левого операнда содержит null или undefined, 
в противном случае возвращается значение левого операнда.



Логическое «НЕ»
Все операторы которые мы рассматривали до этого были бинарными - содержащими два операнда, левый и правый. 
Логическое «НЕ» это унарный оператор - выполняющий операцию над одним операндом справа.

!выражение

Оператор ! приводит операнд к булю, если необходимо, а затем делает инверсию - заменяет его на противоположный 
true -> false или false -> true.

console.log(!true); // false
console.log(!false); // true
console.log(!3); // !3 -> !true -> false
console.log(!"Mango"); // !"Mango" -> !true -> false
console.log(!0); // !0 -> !false -> true
console.log(!""); // !"" -> !false -> true

const isOnline = true;
const isNotOnline = !isOnline; // !isOnline -> !true -> false
*/
/**
  |============================
  | Ветвления
  |============================
*/
/* 
Ветвления используются для выполнения различного кода в зависимсти от условия. Принцип работы простой - результат условия 
приводится к булю true или false, после чего поток программы направляется в ту или иную ветку.



Инструкция if
Входные данные, которые приводятся к булю называются условием. Условие помещают за оператором if в круглых скобках. 
Если условие приводится к true, то выполняется код в фигурных скобках тела if.
Если условие приводится к false, код в фигурных скобках будет пропущен.

let cost = 0;
const subscription = "pro";
if (subscription === "pro") {
  cost = 100;
}
console.log(cost); // 100

let cost = 0;
const subscription = "free";
if (subscription === "pro") {
  cost = 100;
}
console.log(cost); // 0



Инструкция if...else
Расширяет синтаксис if тем, что в случае если условие приводится к false, выполнится код в фигурных скобках после оператора else.
Если условие приводится к true, тело блока else игнорируется.

let cost;
const subscription = "free";
if (subscription === "pro") {
  cost = 100;
} else {
  cost = 0;
}
console.log(cost); // 0

let cost;
const subscription = "pro";
if (subscription === "pro") {
  cost = 100;
} else {
  cost = 0;
}
console.log(cost); // 100



Инструкция else...if
Конструкция if...else может проверить и среагировать на выполнение или невыполнение только одного условия.
Блок else...if позволяет добавить после else еще один оператор if с условием. В конце цепочки может быть классический блок else, 
который выполнится только в случае, когда ни одно из условий не приведётся к true.
При первом же true проверки прекратятся и выполнится только один сценарий, соответствующий этому true. 
Поэтому подобную запись следует читать как: ищу первое совпадение условия, игнорирую все остальное.

let cost;
const subscription = "premium";

if (subscription === "free") {
  cost = 0;
} else if (subscription === "pro") {
  cost = 100;
} else if (subscription === "premium") {
  cost = 500;
} else {
  console.log("Invalid subscription type");
}

console.log(cost); // 500
*/

/**
  |============================
  | Тернарный оператор
  |============================
*/
/* 
Тернарный оператор используется как более синтаксически краткая замена инструкции if...else, когда одной и той же переменной 
необходимо присвоить разные значения по условию.

<условие> ? <выражение_если_условие_истинно> : <выражение_если_условие_ложно>

Работает по такой схеме:
Вычисляется условие.
Если условие истинно, то есть приводится к true, вычисляется выражение после ?.
Если условие ложно, то есть приводится к false, вычисляется выражение после :.
Значение вычисленного выражения возвращается как результат работы тернарного оператора.

Тернарный оператор должен использоваться в простых операциях присваивания или возврата. 
го использование для описания сложных ветвлений - плохая практика (антипаттерн).

let type;
const age = 20;
if (age >= 18) {
  type = "adult";
} else {
  type = "child";
}
console.log(type); // "adult"

Выполним рефакторинг заменив if...else тернарным оператором.

const age = 20;
const type = age >= 18 ? "adult" : "child";
console.log(type); // "adult"

Запишем операцию поиска большего числа.

const num1 = 5;
const num2 = 10;
let biggerNumber;
if (num1 > num2) {
  biggerNumber = num1;
} else {
  biggerNumber = num2;
}
console.log(biggerNumber); // 10

Код работает верно, получаем большее число из двух, но это решение кажется слишком громоздким, учитывая, насколько проста проблема. 
Используем тернарный оператор.

const num1 = 5;
const num2 = 10;
const biggerNumber = num1 > num2 ? num1 : num2;

console.log(biggerNumber); // 10
*/

/**
  |============================
  | Инструкция switch
  |============================
*/
/* 
В некоторых случаях неудобство чтения сложных ветвлений if...else можно избежать используя более «плоский» синтаксис инструкции 
ветвления switch.
Область применения switch ограничена задачами с одним общим вопросом (что сравнивать) и множеством вариантов ответов (с чем сравнивать).
Его синтаксис состоит из блока switch(значение) - что нужно сравнить и множества отдельных случаев case значение - с чем нужно сравнить. 
Для сравнения используется оператор строгого равенства ===. То есть нельзя сравнить на больше или меньше, только на равенство.

switch (значение) {
  case значение:
    инструкции;
    break;
  case значение:
    инструкции;
    break;
  default:
    инструкции;
}

Значение в блоке switch(значение) - строка или число, которое сравнивается на строгое равенство со всеми значениями в блоках case 
значение по порядку, сверху вниз.
Оператор break в завершении каждого блока case необходим чтобы прервать дальнейшие проверки и сразу перейти к коду за switch 
в том случае, когда проверка на равенство вернула true.
Если оператор break будет отсутствовать, то после того как выполнится какое-то условие case, все последующие за ним блоки кода будут 
ыполняться один за другим, что может привести к нежелательным последствиям при неверном применении.
Если ни одного совпадения значений не произошло, необходимо выполнить код по умолчанию, как в блоке else для инструкции if...else. 
Для этого после всех блоков case добавляется блок default. Оператор break после блока default не нужен, так как это и так последнее 
что будет выполнено в switch и управление будет передано коду за ним.

let cost;
const subscription = "premium";

switch (subscription) {
  case "free":
    cost = 0;
    break;

  case "pro":
    cost = 100;
    break;

  case "premium":
    cost = 500;
    break;

  default:
    console.log("Invalid subscription type");
}

console.log(cost); // 500
*/

/**
  |============================
  | Паттерн switch(true)
  |============================
*/
/* 
let value = 10;
switch(true) {
  case value > 5:
    // always do this
    break;
  case value > 15:
    // unreachable
  default:
    // unreachable
}
*/

/**
  |============================
  | Область видимости
  |============================
*/
/* 
------ Глобпльная и локальная (блочная) области видимости -----
Область видимости (scope) - механизм который определяет доступность переменных в исполняемом коде.

Область видимости переменных (variable scope) - доступность переменных в определённом месте кода.

Цепочка областей видимости (scope chain) - области видимости образуют иерархию, так что дочерние области имеют доступ к переменным из родительских областей, 
но не наоборот.

Глобальная область видимости используется по умолчанию. Все и вся имеют доступ к переменным объявленным в ней.
Переменные, объявленные на самом верхнем уровне, то есть вне любых конструкций вроде if, while, for и функций, находятся в глобальной области видимости 
и доступны везде после их объявления.
Например, переменная value объявлена в глобальной области видимости, то есть вне какого-то блока, и доступна в любом месте 
после объявления.

const value = 5;
if (true) {
  console.log("Block scope: ", value); // 5
}

console.log("Global scope: ", value); // 5

Переменные, объявленные внутри инструкций if, for, функций и других блоков кода обрамлённых фигурными скобками {}, находятся в 
блочной области видимости и доступны только внутри этого блока кода или вложенных в него.
Любая конструкция использующая фигурные скобки {} (условия, циклы, функции и т. п.) создает новую локальную область видимости, 
и переменные, объявленные в этой области видимости, используя let или const, не доступны вне этого блока.

if (true) {
  const value = 5;
  console.log("Block scope: ", value); // 5
}

console.log("Global scope: ", value); // ReferenceError: value is not defined

Глубина вложенности областей видимости не ограничена, и все они будут работать по одному принципу - область видимости имеет доступ 
ко всем переменным объявленным выше по иерархии вложенности, но не может получить доступ к переменным объявленным во вложенных 
областях видимости.




----- Поиск по цепочке областей видимости -----
Интерпретатор пытается сначала найти переменную в той области видимости, в которой к ней обратились. Если такой переменной в локальной области видимости нет, 
то он выходит наружу, на один уровень за попытку, пока не найдёт значение или не дойдет до самой верхней области видимости (глобальной) и поймет, 
что переменную с таким идентификатором невозможно найти, так как ее просто нет, тогда будет ошибка о том, что переменная не объявлена.




------ Глобальная и функциональная области видимости -----
var не имеет блочной области видимости
Как мы видели в предыдущих примерах, блок кода создает область видимости для переменных, объявленных с помощью ключевых слов const и let. 
Однако это не работает для переменных, объявленных с помощью ключевого слова var.

Рассмотрим пример:
if (true) {
    // область видимости блока if
    var count = 0
    console.log(count) // 0
}
console.log(count) // 0

Переменная count, как и ожидалось, доступна внутри блока if. Однако, она доступна и за пределами данного блока!
Дело в том, что блок кода не создает области видимости для переменных, объявленных с помощью ключевого слова var. Но это делает функция.

Область видимости функции
Функции в JavaScript создают область видимости для всех переменных, независимо от того, с помощью какого ключевого слова они объявлены (var, const или let).

Например:

function run() {
    // область видимости функции run()
    var message = 'Беги, Форрест, беги!'
    console.log(message)
}
run() // 'Беги, Форрест, беги!'
console.log(message) // ReferenceError

Функция run() создает область видимости. Переменная message доступна внутри функции, но недоступна снаружи.



----- Инициализация в разных областях видимости -----
Попытка присвоеить значение переменной до ее инициализации выдаст ошибку.

let a;
if (true) {
  a = 10;
  let a; // ReferenceError: Cannot access "a" before initialization
} 

В данном примере инициализируется глобальная переменная а. Затем внутри блока if  инициализируется локальная переменная a, но перед этим производится попытка
присвоить ей значение а = 10, что выдаст ошибку.






*/

/**
  |============================
  | Циклы
  |============================
*/
/* 
Цикл - управляющая конструкция в высокоуровневых языках программирования, предназначенная для организации многократного 
исполнения набора инструкций.
Тело цикла - последовательность инструкций, предназначенная для многократного исполнения.
Итерация - единичное выполнение тела цикла.
Условие выхода - выражение, определяющее будет в очередной раз выполняться итерация, или цикл завершится.
Счётчик - переменная, хранящая текущий номер итерации. Цикл не обязательно содержит счётчик, и он не обязан быть один, 
условие выхода из цикла может зависеть от нескольких изменяемых в цикле переменных.




Цикл while
Цикл с предусловием — цикл, который выполняется пока истинно некоторое условие, указанное перед его началом. 
Это условие проверяется до выполнения тела цикла, поэтому тело может быть не выполнено ни разу, если условие с самого начала ложно.

while (condition) {
  // код, тело цикла (statement)
}

Конструкция while создает цикл, который выполняет блок кода, пока условие проверки оценивается как true.
condition, то есть условие, вычисляется перед каждой итерацией цикла.
Если condition оценивается как true, оператор while выполняет statement.
Если condition оценивается как false, выполнение цикла прерывается и скрипт продолжает выполнять инструкции после цикла while.

Сделаем счетчик.

let counter = 0;
while (counter < 10) {
  console.log("counter: ", counter);
  counter += 1;
}

Будем заполнять места в отеле до тех пор пока текущее количество клиентов не будет равно максимально допустимому.

let clientCounter = 18;
const maxClients = 25;
while (clientCounter < maxClients) {
  console.log(clientCounter);
  clientCounter += 1;
}




Цикл do...while
Цикл с постусловием - цикл, в котором условие проверяется после выполнения тела цикла. Отсюда следует, что тело всегда выполняется 
хотя бы один раз.

do {
  // statement
} while (condition);

Конструкция do...while создает цикл, который выполняет блок кода до тех пор, пока condition не вернёт false.
В отличие от цикла while, цикл do...while всегда выполняет statement как минимум один раз, прежде чем он оценит condition.
Внутри цикла нужно внести изменения в некоторую переменную, чтобы убедиться, что выражение равно false после итераций. 
В противном случае будет бесконечный цикл.

let password = "";
do {
  password = prompt("Введите пароль длиннее 4-х символов", "");
} while (password.length < 5);

console.log("Ввели пароль: ", password);




Цикл for
Цикл со счётчиком - цикл, в котором некоторая переменная изменяет своё значение от заданного начального до конечного значения 
с некоторым шагом и для каждого значения этой переменной тело цикла выполняется один раз.

В большинстве процедурных языков программирования реализуется конструкцией for, в которой указывается счётчик, требуемое 
количество итераций и шаг, с которым изменяется счётчик.

for (initialization; condition; post-expression) {
  // statements
}

Алгоритм исполнения цикла for:

Инициализация (initialization) - выполняется один раз перед началом цикла. Используется для создания переменной-счётчика и указания 
её начального значения.
Условие (condition) - выражение, оцениваемое перед каждой итерацией (повторением) цикла. Тело цикла выполняется только тогда, 
когда выражение приводится к true. Цикл завершается, если значение будет false.
Тело (statements) - набор инструкций для выполнения на каждом повторении. Выполняется если выражение условия приводится к true.
Пост-выражение (post-expression) - выполняется в конце каждого повторения цикла, перед проверкой условия. Используется для 
обновления переменной-счётчика.
Переменные-счетчики, по традиции, называются буквами i, j и k.

for (let i = 0; i <= 20; i += 5) {
  console.log(i);
}

В примере объявляется перемнная-счетчик i, инициализируется значением 0 и цикл выполняется до тех пор, пока i <= 20, то есть 
условие приводится к true. После каждой итерации счётчик увеличивается на 5.

Посчитаем сумму чисел до определенного значения.

const target = 3;
let sum = 0;

for (let i = 0; i <= target; i += 1) {
  sum += i;
}

console.log(sum);

Вспомним про операцию a % b и выведем остаток от деления используя цикл.

const max = 10;
for (let i = 0; i < max; i += 1) {
  console.log(`${max} % ${i} = `, max % i);
}




Оператор break
Прервать выполнение цикла можно в любой момент. Для этого сущестует оператор break, который полностью прекращает выполнение цикла 
и передаёт управление на строку за его телом.

Найдём число 3. Как только выполнится условие if, цикл прекратит своё выполнение (будет прерван).

for (let i = 0; i <= 5; i += 1) {
  console.log(i);

  if (i === 3) {
    console.log("Нашли число 3, прерываем выполнение цикла");
    break;
  }
}

console.log("Лог после цикла");





Оператор continue
Прерывает не весь цикл, а только выполнение текущей итерации. Его используют, если понятно, что на текущей итерации цикла делать 
больше нечего или вообще ничего делать не нужно и пора переходить на следующую итерацию.

Используем цикл для вывода только нечетных чисел. Для чётных i срабатывает continue, выполнение тела прекращается и управление 
передаётся на следующую итерацию.

const number = 10;

for (let i = 0; i < number; i += 1) {
  if (i % 2 === 0) {
    continue;
  }

  console.log("Нечетное i: ", i); // 1, 3, 5, 7, 9
}
*/

/**
  |============================
  | Массивы
  |============================
*/
/* 
Массив - структура данных для хранения и манипулирования коллекцией индексированных значений.

Создание
Массив объявляется открывающей и закрывающей квадратной скобками [] - литералом массива. 
Внутри скобок каждый элемент массива разделяется запятой.

const clients = ["Mango", "Poly", "Ajax"];

Доступ к элементам
Для доступа к значению элемента массива используется синтаксис квадратных скобок массив[индекс]. 
Между именем переменной хранящей массив и квадратными скобками не должно быть пробела.
Индексация элементов массива начинается с нуля.

const clients = ["Mango", "Poly", "Ajax"];

// Указывая в скобках индекс элемента мы получаем его значение
console.log(clients[0]); // Mango
console.log(clients[1]); // Poly
console.log(clients[2]); // Ajax



Переопределение
В отличии от строк, элементы массива можно изменять обратившись к ним по индексу и присвоив другое значение.

const clients = ["Mango", "Poly", "Ajax"];
clients[0] = "Kiwi";
clients[1] = "Pango";




Длина массива
Длина массива, то есть число его элементов, хранится в свойстве length. 
Это динамическая величина, которая изменяется автоматически при добавлении или удалении элементов.

const clients = ["Mango", "Poly", "Ajax"];
console.log(clients.length); // 3




Индекс последнего элемента
Чаще всего мы заранее в коде не знаем какая будет длина массива. 
Для того чтобы получить значение последнего элемента применяется следующий подход - длина массива всегда на единицу больше 
чем индекс последнего элемента. Используя формулу длина_массива - 1 можно получить значение последнего элемента массива 
произвольной длины.

const clients = ["Mango", "Poly", "Ajax"];
const lastElementIndex = clients.length - 1;
console.log(lastElementIndex); // 2
console.log(clients[lastElementIndex]); // "Ajax"

*/

/**
  |============================
  | Проверка массива
  |============================
*/
/* 
console.log(typeof arrayName); // object
console.log(Array.isArray(arrayName)); // true
*/

/**
  |============================
  | Итерация по массиву
  |============================
*/
/* 
Цикл for можно использовать для итерации по массиву, то есть «перебрать» его поэлементно.

const clients = ["Mango", "Ajax", "Poly"];

for (let i = 0; i < clients.length; i += 1) {
  console.log(clients[i]);
}
*/

/**
  |============================
  | Цикл for...of
  |============================
*/
/* 
Конструкция for...of объявляет цикл, перебирающий итерируемые объекты, такие как массивы и строки. 
Тело цикла будет выполняться для значения каждого элемента. Это хорошая замена циклу for если не нужен доступ к счётчику итерации.

for (const variable of iterable) {
  // тело цикла
}

variable — переменная которая будет хранить значение элемента на каждой итерации.
iterable — коллекция, которая имеет перечислимые элементы, например массив.

const clients = ["Mango", "Ajax", "Poly"];

for (const client of clients) {
  console.log(client);
}

const string = "javascript";

for (const character of string) {
  console.log(character);
}
*/

/**
  |============================
  | Операторы break и continue
  |============================
*/
/* 
Будем искать имя клиента в массиве имен, если нашли - прервем цикл, так как нет смысла искать дальше, имена у нас уникальные.

const clients = ["Mango", "Poly", "Ajax"];
const clientNameToFind = "Poly";
let message;

for (const client of clients) {
  // На каждой итерации будем проверять совпадает ли элемент массива с
  // именем клиента. Если совпадает то мы записываем в message сообщение
  // об успехе и делаем break чтобы не искать дальше
  if (client === clientNameToFind) {
    message = "Клиент с таким именем есть в базе данных!";
    break;
  }

  // Если они не совпадают то запишем в message сообщение об отсутствии имени
  message = "Клиента с таким именем нету в базе данных!";
}

console.log(message); // "Клиент с таким именем есть в базе данных!"

Можно изначально задать message значение неудачи поиска, а в цикле перезаписать его на успех, если нашли имя. 
Но break все равно пригодится, так как если у нас массив из 10000 клиентов, а нужный нам стоит на позиции 2, то нет абсолютно 
никакого смысла перебирать оставшиеся 9998 элементов.

const clients = ["Mango", "Poly", "Ajax"];
const clientNameToFind = "Poly";
let message = "Клиента с таким именем нету в базе данных!";

for (const client of clients) {
  if (client === clientNameToFind) {
    message = "Клиент с таким именем есть в базе данных!";
    break;
  }
  // Если не совпадает, то на этой итерации ничего не делаем
}

console.log(message); // Клиент с таким именем есть в базе данных!

Используем цикл для вывода только чисел больше определенного значения.

const numbers = [1, 3, 14, 18, 4, 7, 29, 6, 34];
const threshold = 15;

// Для чисел меньше чем порог срабатывает continue, выполнение тела прекращается
// и управление передаётся на следующую итерацию.
for (let i = 0; i < numbers.length; i += 1) {
  if (numbers[i] < threshold) {
    continue;
  }

  console.log(`Число больше чем ${threshold}: ${numbers[i]}`); // 18, 29, 34
}
*/

/**
  |============================
  | Присвоение по ссылке и по значению
  |============================
*/
/* 
Фундаментальным отличием сложных типов от примитивов, является то, как они хранятся и копируются. 
Примитивы: строки, числа, були,null и undefined, при присваивании копируются целиком, по значению (by value).
Все примитивные типы присваиваются по значению, то есть создается копия.
let a = 5;
let b = a;
a = 10;
console.log(a); // 10
console.log(b); // 5

Со сложными типами всё не так. В переменной, которой присвоен массив или объект, хранится не само значение, а адрес его места в памяти, иными словами - ссылка 
(указатель) на него и передаются они по ссылке (by reference).
Сложные типы - объекты, массивы, функции присваиваются по ссылке, то есть переменная просто получает ссылку на уже существующий объект.
const a = ["Mango"];
const b = a;
a.push("Poly");
console.log(a); // ["Mango", "Poly"]
console.log(b); // ["Mango", "Poly"]
*/

/**
  |============================
  | Методы массива
  |============================
*/
/* 
split(delimiter) превращает строку в массив, «разбив» её по разделителю delimiter. Если разделитель это пустая строка, то получится массив отдельных символов. Разделителем может быть один или несколько символов.

const name = "Mango";
console.log(name.split("")); // ["M", "a", "n", "g", "o"]
const message = "JavaScript это интересно";
console.log(message.split(" ")); // ["JavaScript", "это", "интересно"]





join(delimiter) соединяет элементы массива в строку. В строке элементы будут разделены символом или группой символов указанных в delimiter. 
То есть это операция обратная методу строк split(delimiter).

const words = ["JavaScript", "это", "интересно"];
console.log(words.join("")); // "JavaScriptэтоинтересно"
console.log(words.join(" ")); // "JavaScript это интересно"
console.log(words.join("-")); // "JavaScript-это-интересно"





indexOf(value) возвращает первый индекс, в котором элемент со значением value был найден в массиве, или число -1, если такого элемента нет. 
Используйте indexOf тогда, когда необходимо получить непосредственно индекс элемента.

const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.indexOf("Poly")); // 2
console.log(clients.indexOf("Monkong")); // -1





includes(value) проверяет есть ли в массиве элемент со значением value и возвращает true или false соответственно. 
Область применения этого метода сводится к ситуациям когда необходимо проверить есть ли элемент в массиве и не важна его позиция (индекс).

const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.includes("Poly")); // true
console.log(clients.includes("Monkong")); // false





Проверка множественных условий с includes()
const fruit = "apple";
if (
  fruit === "apple" ||
  fruit === "strawberry" ||
  fruit === "cherry" ||
  fruit === "cranberries"
) {
  console.log("It is a red fruit!");
}

Можем переписать условие используя метод includes(), это очень просто и масштабируемо.

const redFruits = ["apple", "strawberry", "cherry", "cranberries"];
const fruit = "cherry";

const hasFruit = redFruits.includes(fruit);
if (hasFruit) {
  console.log(`${fruit} is a red fruit!`);
}





Методы push() и pop()
Добавляют или удаляют крайние элементы массива. Работают с крайним левым и крайним правым элементом и не могут поставить или удалить элемент с произвольной позиции.

Метод push() добавляет один или несколько элементов в конец массива, без необходимости указывать индексы добавляемых элементов. 
Возвращает длину массива после добавления элементов.

const numbers = [];
numbers.push(1);
console.log(numbers); // [1]
numbers.push(2);
console.log(numbers); // [1, 2]
numbers.push(3);
console.log(numbers); // [1, 2, 3]

Метод pop() удаляет последний элемент из конца массива и возвращает удаленный элемент. Если массив пустой, метод возвращает undefined.

const numbers = [1, 2, 3, 4, 5];

console.log(numbers.pop()); //  5
console.log(numbers); // [1, 2, 3, 4]
console.log(numbers.pop()); //  4
console.log(numbers); // [1, 2, 3]
console.log(numbers.pop()); //  3
console.log(numbers); // [1, 2]




Методы shift, unshift

Метод unshift() добавляет один или более элементов в начало массива и возвращает новую длину массива.
Синтаксис
arr.unshift(element1[, ...[, elementN]])
Параметры
element1, ..., elementN - Элементы, добавляемые в начало массива.
Возвращаемое значение - Новое свойство length объекта, над которым был вызван метод unshift.

Метод shift() удаляет первый элемент из массива и возвращает его значение. Этот метод изменяет длину массива.
Синтаксис
arr.shift()
Описание
Метод shift удаляет элемент по нулевому индексу, сдвигает значения по последовательным индексам вниз, а затем возвращает удалённое значение. 
Если свойство length массива равно 0, вернётся значение undefined.
Метод shift не является привязанным к типу; этот метод может быть вызван или применён к объектам, напоминающим массив. Объекты, не содержащие свойство length, 
отражающее последний элемент в серии последовательных числовых, начинающихся с нуля, свойств, могут повести себя неправильным образом.





Метод slice()
slice(begin, end) возвращает новый массив, содержащий копию части исходного массива, не изменяя его. 
Этод метод не мутирует оригинальный массив, то есть не является мутабельным методом.
Копия делается от begin и до, но не включая, end - индексы элементов исходного массива.

const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.slice(1, 3)); // ["Ajax", "Poly"]

Если begin и end не указаны, будет создана полная копия исходного массива.

Если не указан end, копирование будет от start и до конца исходного массива.
const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.slice(1)); // ["Ajax", "Poly", "Kiwi"]

Если значение start отрицательное, а end не указан, то будут скопированы последние start элементов
const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.slice(-2)); // ["Poly", "Kiwi"]





Метод splice()
Швейцарский нож для работы с массивами, если исходный массив нужно изменить. Удаляет, добавляет и заменяет элементы в произвольном месте массива.
Этод метод изменяет оригинальный массив, то есть является мутабельным методом массива.


Удаление
Чтобы удалить элементы в массиве, передаются два аргумента.

splice(position, num)

position - указывает позицию (индекс) первого элемента для удаления
num - определяет количество удаляемых элементов

! Метод splice изменяет исходный массив и возвращает массив, содержащий удаленные элементы. !
Например, у нас есть массив оценок, который содержит пять чисел от 1 до 5.

const scores = [1, 2, 3, 4, 5];

// Удаляем три элемента массива, начиная с первого элемента (индекс 0)
const deletedScores = scores.splice(0, 3);

// Теперь массив scores содержит два элемента
console.log(scores); // [4, 5]

// А массив deletedScores содержит три удаленных элемента
console.log(deletedScores); // [1, 2, 3]


Добавление
Для того чтобы добавить один или несколько элементов в массив, необходимо передать три или более аргумента, при этом второй аргумент должен быть равен нулю.

splice(position, 0, new_element_1, new_element_2, ...)

Аргумент position указывает начальную позицию в массиве, куда будут вставлены новые элементы.
Второй аргумент это ноль, он говорит методу не удалять элементы в месте добавления новых.
Третий, четвертый и все последующие аргументы - это новые элементы, которые добавляются в массив.
Например, у нас есть массив с названиями цветов в виде строк. Добавим новый цвет перед элементом с индексом 2.

const colors = ["red", "green", "blue"];

colors.splice(2, 0, "purple");
console.log(colors); // ["red", "green", "purple", "blue"]

На рисунке показан вызов метода colors.splice(2, 0, 'purple') из примера.


Замена
Замена это операция добавления в которой удаляются элементы в месте добавления новых. Для этого необходимо передать минимум три аргумента. 
Количество удаляемых и добавляемых элементов может не совпадать.

splice(position, num, new_element_1, new_element_2, ...)

position - указывает позицию (индекс) первого элемента для удаления
num - определяет количество удаляемых элементов
Третий, четвертый и все последующие аргументы - это новые элементы, которые добавляются в массив.
например, у нас есть массив языков программирования из четырех элементов.

const languages = ["C", "C++", "Java", "JavaScript"];

// Заменяем элемент с индексом 1 на новый
languages.splice(1, 1, "Python");
console.log(languages); // ["C", "Python", "Java", "JavaScript"]

// Заменяем один элемент (с индексом 2) на несколько
languages.splice(2, 1, "C#", "Swift", "Go");
console.log(languages); // ["C", "Python", "C#", "Swift", "Go", "JavaScript"]





Метод concat()
Объединяет два или более массива в один. Он не изменяет массив на котором вызывается, а возвращает новый. 
Порядок аргументов метода влияет на порядок элементов нового массива.

const oldClients = ["Mango", "Ajax", "Poly", "Kiwi"];
const newClients = ["Monkong", "Singu"];

const allClientsWithOldFirst = oldClients.concat(newClients);
console.log(allClientsWithOldFirst); // ["Mango", "Ajax", "Poly", "Kiwi", "Monkong", "Singu"]

const allClientsWithNewFirst = newClients.concat(oldClients);
console.log(allClientsWithNewFirst); // ["Monkong", "Singu", "Mango", "Ajax", "Poly", "Kiwi"]

console.log(oldClients); // ["Mango", "Ajax", "Poly", "Kiwi"]
console.log(newClients); // ["Monkong", "Singu"]
*/

/**
  |============================
  | Функции
  |============================
*/
/* 
Функция - это подпрограмма, независимая часть кода, предназначенная для многократного выполнения конкретной задачи с разными начальными значениями. 
Функции позволяют структурировать большие программы, уменьшают повторение и изолируют код.
Функцию можно представить как чёрный ящик, она получает что-то на входе (данные), и возвращает что-то на выходе (результат выполнения кода внутри неё).

Объявление функции (function declaration) начинается с ключевого слова function, за которым идёт её имя - глагол отвечающий на вопрос «Что сделать?» 
и пара круглых скобок.
Тело функции заключено в фигурные скобки {} и содержит инструкции которые необходимо выполнить при её вызове. 
Затем, когда необходимо, функция вызывается с помощью имени и пары круглых скобок.

// 1. Объявление функции multiply
function multiply() {
  // Тело функции
  console.log("Это лог при вызове функции multiply");
}
// 2. Вызовы функции multiply
multiply(); // 'Это лог при вызове функции multiply'



Параметры и аргументы
В круглых скобках после имени функции идут параметры - перечисление данных которые функция ожидает при вызове.

// Объявление параметров x, y, z
function multiply(x, y, z) {
  console.log(`Результат умножения равен ${x * y * z}`);
}

Параметры это локальные переменные доступные только в теле функции. Они разделяются запятыми. Параметров может быть несколько, или вообще не быть, 
тогда записываются просто пустые круглые скобки.
Параметры будут создаваться заново каждый раз при вызове функции, и их отдельные инкарнации никак друг с другом не связаны.

При вызове функции, в круглых скобках можно передать аргументы - значения для объявленных параметров функции.

!!! Если аргументов будет меньше чем параметров, то параметрам без значений будет присвоено undefined !!!

!!! Параметры и их аргументы создают локальные переменные в теле функии !!! :

let someValue = 2;                     // глобальная переменная someValue = 2
function checkScope(someValue) {       // параметр someValue будет создавать в теле функии локальную переменную someValue и принимать ее знаение из аргумента
 someValue = 45;                       // локальной переменной someValue присваевается значение 45
 return someValue;                     // функция возвращает в место своего вызова 45
}
checkScope(someValue);                 // вызов функии
console.log(someValue);                // 2

// 1. Объявление параметров x, y, z
function multiply(x, y, z) {
  console.log(`Результат умножения равен ${x * y * z}`);
}
// 2. Передача аргументов
multiply(2, 3, 5); // Результат умножения равен 30
multiply(4, 8, 12); // Результат умножения равен 384
multiply(17, 6, 25); // Результат умножения равен 2550

Порядок передачи аргументов должен соответствует порядку объявленых параметров: значение первого аргумента будет присвоено первому параметру, 
второго аргумента второму параметру и т. д. 

!!! Если аргументов будет меньше чем параметров, то параметрам без значений будет присвоено undefined !!!

function fn(valA, valB) {
     return valA + valB;
}

fn(4, 5); //   9
fn(4);    //   NaN



Оператор return используется для передачи значения из тела функции во внешний код. 
Когда интерпретатор встречает return, он сразу же выходит из функции (прекращает её выполнение), и возвращает указанное значение в то место кода, 
где функция была вызвана.

function multiply(x, y, z) {
  console.log("Код до return выполняется как обычно");
  // Возвращаем результат выражения умножения
  return x * y * z;
  console.log("Этот лог никогда не выполнится, он стоит после return");
}
// Результат работы функции можно сохранить в переменную
let result = multiply(2, 3, 5);
console.log(result); // 30

Оператор return без явно указанного значения возвращает специальное значение undefined.
При отсутствии return в теле функции, она все равно вернёт undefined.



Порядок выполнения кода
Когда интерпретатор встречает вызов функции (или метода), он приостанавливает выполнение текущего кода и начинает выполнять код из тела функции. 
После того как весь код функции будет выполнен, интерпретатор выходит из тела функции, возвращаясь в то место, откуда пришел и продолжает выполнять код, 
следующий после вызова функции.

function multiply(x, y, z) {
  console.log(`Результат умножения равен ${x * y * z}`);
}
console.log("Лог до вызова функции multiply");
multiply(2, 3, 5); // Результат умножения равен 30
console.log("Лог после вызова функции multiply");

// Последовательность логов в консоли
// "Лог до вызова функции multiply"
// "Результат умножения равен 30"
// "Лог после вызова функции multiply"



Параметры по умолчанию
Иногда необходимо объявить функцию, у параметров которой будут значения отличные от undefined, даже если для них не передали аргументы. 
Это делается очень простым и очевидным образом, достаточно указать значение по умолчанию прямо при объявлении параметров в подписи функции. 
При такой записи, если для параметра не передано значение аргумента, используется значение по умолчанию.

function count(countFrom = 0, countTo = 10, step = 1) {
  console.log(`countFrom = ${countFrom}, countTo = ${countTo}, step = ${step}`);
  for (let i = countFrom; i <= countTo; i += step) {
    console.log(i);
  }
}

count(1, 5); // countFrom = 1, countTo = 5, step = 1
count(2); // countFrom = 2, countTo = 10, step = 1
count(); // countFrom = 0, countTo = 10, step = 1




Псевдомассив arguments
Доступ к списку всех аргументов можно получить при помощи специальной переменной arguments, которая доступна только внутри функции и хранит все аргументы 
как псевдомассив.
Псевдомассив - коллекция, со свойством length и возможностью обратиться к элементу по индексу, но отсутствием большинства методов для работы с массивом.
Рассмотрим пример использования arguments в функции, которая умножает любое количество аргументов:

function multiply() {
  let total = 1;

  for (const argument of arguments) {
    total *= argument;
  }

  return total;
}

console.log(multiply(1, 2, 3)); //  6
console.log(multiply(1, 2, 3, 4)); //  24
console.log(multiply(1, 2, 3, 4, 5)); //  120





Преобразование псевдомассива
Обычно псевдомассив необходимо преобразовать в полноценный массив, так как у псевдомассива нет методов массива, например slice() или includes(). 
На практике применяют несколько основных способов.

1) Используя метод Array.from(), который создаст массив из псевдомассива.

function fn() {
  // В переменной args будет полноценный массив
  const args = Array.from(arguments);
}

2) Используя операцию ... (rest) - она позволяет собрать произвольное количество элементов, в нашем случае аргументов, в массив и сохранить его в переменную. 
Собираем все аргументы используя операцию rest прямо в подписи функции.

function fn(...args) {
  // В переменной args будет полноценный массив
}

или

3) Используя операцию ... (spread) - она позволяет распылить произвольное количество элементов, в нашем случае аргументов, в массив

function add() {
  const arr = [...arguments]    // В переменной arr будет полноценный массив
}
Операция rest более детально рассматривается дальше в курсе, здесь показано одно из ее возможных применений.





Паттерн «Ранний возврат»
Оператор if...else - это основной способ создания ветвлений. Тем не менее, сложные вложенные ветвления делают код запутанным для понимания.

Создадим функцию, которая обрабатывает снятие денег с личного счета в банке. Она получает сумму для снятия и текущий баланс счета, после чего, 
в зависимости от условия, выполняет тот или иной блок кода.

function withdraw(amount, balance) {
  if (amount === 0) {
    console.log("Для проведения операции введите сумму больше нуля");
  } else if (amount > balance) {
    console.log("Недостаточно средств на счету");
  } else {
    console.log("Операция снятия средств проведена успешно");
  }
}

withdraw(0, 300); // "Для проведения операции введите сумму больше нуля"
withdraw(500, 300); // "Недостаточно средств на счету"
withdraw(100, 300); // "Операция снятия средств проведена успешно"

Даже в таком простом примере есть группа вложенных условных операторов, среди которых не сразу можно выделить понять логику выполнения кода.

В функции может быть больше одного оператора return. Главное помнить, что выполнение функции прерывается когда интерпретатор встречает возврат, 
и весь код после него будет проигнорирован в текущем вызове функции.

Паттерн «Ранний возврат» - это способ использовать возможность досрочного возврата из функции с помощью оператора return. 
Используя этот приём мы получаем более чистый, плоский и понятный код, который легче рефакторить.

Выделим все проверки условий в отдельные операторы if, после чего добавим код, идущий в теле else. В идеальном случае, должен получиться плоский 
список условных операторов, идущих один за другим, а в конце блок, который выполнится только в том случае, если не выполнится ни один if.

function withdraw(amount, balance) {
  // Если  условие выполняется, вызывается console.log и выход из функции. Код идущий после тела if не выполнится.
  if (amount === 0) {
    console.log("Для проведения операции введите сумму больше нуля");
    return;
  }
  // Если условие первого if не выполнилось, его тело пропускается и интерпретатор доходит до второго if.
  // Если условие выполняется, вызывается console.log и выход из функции. Код идущий после тела if  не выполнится.
  if (amount > balance) {
    console.log("Недостаточно средств на счету");
    return;
  }
  // Если ни один из предыдущих if не выполнился, интерпретатор доходит до этого кода и выполняет его.
  console.log("Операция снятия средств проведена");
}

withdraw(0, 300); // "Для проведения операции введите сумму больше нуля"
withdraw(500, 300); // "Недостаточно средств на счету"
withdraw(100, 300); // "Операция снятия средств проведена"





Функциональное выражение
Функциональное выражение (function expression) - обычное объявление переменной, значение которой будет функция. Альтернативный способ объявления функции.

// Объявление функции (function declaration)
function multiply(x, y, z) {
  console.log(`Результат умножения равен ${x * y * z}`);
}

// Функциональное выражение (function expression)
const multiply = function (x, y, z) {
  console.log(`Результат умножения равен ${x * y * z}`);
};

Различие в том, что функциональное выражение нельзя вызвать до места его создания, только после, потому что это буквально объявление const переменной.

// ❌ Ошибка! Не работает вызов до объявления
multiply(1, 2, 3);

const multiply = function (x, y, z) {
  console.log(`Результат умножения равен ${x * y * z}`);
};

// ✅ Работает вызов после объявления
multiply(4, 5, 6);

A объявление функции можно вызвать до места её создания в коде.

// ✅ Работает вызов до объявления
multiply(1, 2, 3);

function multiply(x, y, z) {
  console.log(`Результат умножения равен ${x * y * z}`);
}

// ✅ Работает вызов после объявления
multiply(4, 5, 6);

ИНТЕРЕСНО
Не важно какой синтаксис использовать, главное чтобы код в проекте был однородным. То есть необходимо стараться не мешать объявления функции 
с функциональными выражениями.
*/

/**
  |============================
  | Стек вызовов
  |============================
*/
/* 
При вызове функции, внутри её тела могут вызываться другие функции, а в них другие и т. д. 
JavaScript однопоточный язык, то есть в одну единицу времени может выполняться только одна инструкция. 
Это значит, что уже вызванные функции, которые не закончили свое выполнение, должны ждать выполнения функций вызванных внутри себя, для того, 
чтобы продолжить свою работу.

function fnA() {
  console.log("Лог внуртри функции fnA до вызова fnB");
  fnB();
  console.log("Лог внуртри функции fnA после вызова fnB");
}

function fnB() {
  console.log("Лог внутри функции fnB");
}

console.log("Лог перед вызовом fnA");
fnA();
console.log("Лог после вызова fnA");

// "Лог перед вызовом fnA"
// "Лог внуртри функции fnA до вызова fnB"
// "Лог внутри функции fnB"
// "Лог внуртри функции fnA после вызова fnB"
// "Лог после вызова fnA"

Необходим механизм хранения списка функций, которые были вызваны, но еще не закончили свое выполнение и механизм управления порядком выполнения этих функций - 
и именно за это отвечает стек вызовов (call stack).

Стек
Стек - структура данных, которая работает по принципу LIFO (Last-In-First-Out), то есть последним пришёл - первым вышел. Последнее, что добавляется на стек, 
будет удалено из него первым, значит можно добавить или удалить элементы только из верхушки стека.

Представьте стек как массив у которого есть только методы pop и push, то есть можно добавить или удалить только элемент в конце коллекции.




Стек вызовов (call stack) - это механизм для отслеживания текущего местонахождения интерпретатора в коде, который вызывает несколько функций. 
Какая из функций выполняется на данный момент, какие функции вызываются изнутри выполняемой функции, какая будет вызвана следующей и т. д.

Когда скрипт вызывает функцию, интерпретатор добавляет её в стек вызовов и начинает выполнение.
Любые функции, вызванные выполняемой функцией, добавляются в стек вызовов и выполняются, как только происходит их вызов.
Когда выполнение функции завершено, интерпретатор снимает её со стека вызовов и возобновляет выполнение кода с той точки, где остановился до этого. 
То есть начинает выполняться функция, запись которой лежит следующей на стеке.

Stack frame (кадр стека, запись стека) - структура которая добавляется на стек при вызове функции. Хранит служебную информацию, например имя функции 
и номер строки, в которой произошел вызов.

function bar() {
  console.log("bar");
}

function baz() {
  console.log("baz");
}

function foo() {
  console.log("foo");
  bar();
  baz();
}

foo();

При выполнении этого кода сначала вызывается foo(), затем внутри foo() вызывается bar(), а затем baz(). Вызовы console.log() так же учитываются, ведь это функция. 




Переполнение стека вызовов
Стек вызовов не безграничный, ему отводится конечный объем памяти. Иногда в консоли можно увидеть ошибку "Uncaught RangeError: Maximum call stack size exceeded" - 
переполнение стека (stack overflow).

Это может произойти при неправильном использовании рекурсии или зацикливании вызовов функций, то есть, если идут бесконечные вызовы функций и результат 
не возвращается, то стек увеличивается. По достижению предела количества записей стека и возникнет такая ошибка и скрипт «падает».
*/

/**
  |============================
  | Объекты
  |============================
*/
/* 
Объекты позволяют описать и сгруппировать характеристики некоторой сущности - пользователя, книги, продукта в магазине, чего угодно. 
Объекты ещё называют словарями, то есть они содержат термины (свойства) и их определения (значения).

Создание объекта
Для объявления используются фигурные скобки {} - литерал объекта.

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  isPublic: true,
  rating: 8.38,
};

При создании объекту можно добавить свойства, каждое из которых описывается парами ключ:значение. Ключ ещё называют именем свойства и это всегда строка. 
Значением свойства могут быть любые типы: примитивы, массивы, объекты, були, функции и т. п. Свойства разделяются запятой.

Правила именования ключей просты:

Если ключ заключен в кавычки, то это может быть произвольная строка.
Если кавычек нет, то вступают ограничения - имя без пробелов, начинается на букву или символы _ и $.



Вложенные свойства
Значением свойства может быть другой объект, для того чтобы хранить вложенные и группированные данные. Например, статистика пользователя социальной сети 
состоит из количества последователей, просмотров и лайков, и хранить эти данные удобнее всего в виде объекта. Тоже самое с местоположением, отдельно страна и город.

const user = {
  name: "Jacques Gluke",
  tag: "jgluke",
  location: {
    country: "Jamaica",
    city: "Ocho Rios",
  },
  stats: {
    followers: 5603,
    views: 4827,
    likes: 1308,
  },
};

В будущем это можно будет использовать для поиска пользователей по стране, городу, минимальному или максимальному количеству последователей и т. д.



Обращение к свойствам через точку
Первый способ получить доступ к свойству объекта это синтаксис обьект.имя_свойства. 
Синтаксис «через точку» используется в большинстве случаев и подходит тогда, когда мы заранее знаем имя (ключ) свойства к которому хотим получить доступ.

На место обращения будет возвращено значение свойства с таким именем.
Если в объекте нет свойства с таким именем, на место обращения вернётся undefined.
const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  isPublic: true,
  rating: 8.38,
};

const bookTitle = book.title;
console.log(bookTitle); // 'The Last Kingdom'

const bookGenres = book.genres;
console.log(bookGenres); // ['historical prose', 'adventurs']

const bookPrice = book.price;
console.log(bookPrice); // undefined




Обращение к вложенным свойствам
Для доступа к вложенным свойствам используется цепочка обращейний «через точку». 
Например, если необходимо получить значение страны пользователя, записываем user.location.country, где user.location это обращение (путь) к объекту 
в свойстве location, а user.locaton.country обращение к свойству country в этом объекте. То есть «точка» указывает следующую вложенность.

const user = {
  name: "Jacques Gluke",
  tag: "jgluke",
  location: {
    country: "Jamaica",
    city: "Ocho Rios",
  },
  hobbies: ["swiming", "music", "sci-fi"],
};

const location = user.location;
console.log(location); // Объект location

const country = user.location.country;
console.log(country); // 'Jamaica'

Если значение свойства это массив, то в нашем примере user.hobbies обращение к этому массиву. 
Далее можно получить доступ к его элементам через квадратные скобки и индекс или использовать свойства и методы.

const hobbies = user.hobbies;
console.log(hobbies); // ['swiming', 'music', 'sci-fi']

const firstHobby = user.hobbies[0];
console.log(firstHobby); // 'swiming'

const numberOfHobbies = user.hobbies.length;
console.log(numberOfHobbies); // 3





Обращение к свойствам через квадратные скобки
Второй способ получить доступ к свойству объекта это синтаксис обьект["имя свойства"]. Похоже на обращение к элементу массива с отличием в том, 
что в скобках указывается не индекс элемента, а имя свойства как строка.

Синтаксис «квадратных скобок» используется значительно реже, в случае когда имя свойства заранее неизвестно или хранится в переменной, например 
как значение параметра функции.

На место обращения будет возвращено значение свойства с таким именем.
Если в объекте нет свойства с таким именем, на место обращения вернётся undefined.
const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  isPublic: true,
  rating: 8.38,
};

const bookTitle = book["title"];
console.log(bookTitle); // 'The Last Kingdom'

const bookGenres = book["genres"];
console.log(bookGenres); // ['historical prose', 'adventurs']

const propKey = "author";
const bookAuthor = book[propKey];
console.log(bookAuthor); // 'Bernard Cornwell'




Изменение значения свойства
После того как объект создан, значение его свойств можно изменить. Для этого необходимо обратиться к ним по имени, например «через точку», и присвоить новое значение.

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  isPublic: true,
  rating: 8.38,
};

book.rating = 9;
book.isPublic = false;
book.genres.push("драма");

console.log(book.rating); // 9
console.log(book.isPublic); // false
console.log(book.genres); // ['historical prose', 'adventures', 'драма']




Добавление свойств
Операция добавления нового свойства после создания объекта ничем не отличается от изменения значения уже существующего свойства. 
Если при записи значения по имени, такого свойства в объекте нет, оно будет создано.

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  isPublic: true,
  rating: 8.38,
};

book.pageCount = 836;
book.originalLanguage = "en";
book.translations = ["ua", "ru"];

console.log(book.pageCount); // 836
console.log(book.originalLanguage); // 'en'
console.log(book.translations); // ['ua', 'ru']





Короткие свойства
Иногда при создании объекта значение свойства необходимо взять из переменной или параметра функции с таким же именем как и само свойство.

Синтксис в следующем примере слишком громоздкий, потому что приходится дублировать имя свойства и имя переменной в которой хранится необходимое значение.

const name = "Генри Сибола";
const age = 25;

const user = {
  name: name,
  age: age,
};

console.log(user.name); // "Генри Сибола"
console.log(user.age); // 25

Синтаксис коротких свойств (shorthand properties) решает эту проблему, позволяя использовать имя переменной как имя свойства, а её значение как значение свойства.

const name = "Генри Сибола";
const age = 25;

const user = {
  name,
  age,
};

console.log(user.name); // "Генри Сибола"
console.log(user.age); // 25

То есть при объявлении объекта достаточно указать только имя свойства, а значение будет взято из переменной с аналогичным именем.





Вычисляемые свойства
Бывают ситуации когда при объявлении обьекта необходимо добавить свойство с именем которое мы заранее не знаем, потому что оно хранится как значение 
переменной или как результат выполнения функции.

Раньше для этого необходимо было сначала создать объект, а потом добавлять свойства через квадратные скобки, что не совсем удобно.

const propName = "name";
const user = {
  age: 25,
};

user[propName] = "Генри Сибола";
console.log(user.name); // 'Генри Сибола'

Синтаксис вычисляемых свойств (computed properties) помогает избежать лишнего кода и в некоторых случаях упростить его. 
Значением вычисляемого свойства может быть любое валидное выражение.

const propName = "name";
const user = {
  age: 25,
  // Имя этого свойства будет взято из значения переменной propName
  [propName]: "Генри Сибола",
};

console.log(user.name); // 'Генри Сибола'




Методы объекта
До сих пор мы рассматривали объекты только как хранилища взаимосвязанных данных, например информация о книге и т. п. 
Объекты-хранилища обычно находятся в массиве таких же объектов, который представляет коллекцию однотипных элементов.

Объекты могут хранить не только данные, но и функции для работы с этими данными - методы. 
Если значение свойства это функция, такое свойство называется методом объекта.

// ✅ Логически и синтаксически сгруппированные сущности
const bookShelf = {
  books: ["The Last Kingdom", "Dream Guardian"],
  // Это метод объекта
  getBooks() {
    console.log("Этот метод будет возвращать все книги - свойство books");
  },
  // Это метод объекта
  addBook(bookName) {
    console.log("Этот метод будет добавлять новую книгу в свойство books");
  },
};

// Вызовы методов
bookShelf.getBooks();
bookShelf.addBook("Новая книга");

Такие объекты можно назвать «моделями». Они связывают данные и методы для работы с этими данными. 
Например, можно было объявить переменную books и две функции getBooks() и addBook(bookName), но тогда это были бы три независимые сущности 
без явной синтаксической, и со слабой логической связью.

// ❌ Слабосвязанные, независмые сущности
const books = [];
function getBooks() {}
function addBook() {}




Доступ к свойствам объекта в методах
Методы используются для работы со свойствами объекта, их изменения. 
Для доступа к объекту в методе используется не имя переменной, например bookShelf, а ключевое слово this - контекст. Значением this будет объект перед «точкой», то есть объект который вызвал этот метод, в нашем случае это ссылка на объект bookShelf.

const bookShelf = {
  books: ["The Last Kingdom"],
  getBooks() {
    console.log(this);
  },
};

// Перед точкой стоит объект bookShelf,
// поэтому при вызове метода, this будет хранить ссылку на него.
bookShelf.getBooks(); // {books: ['The Last Kingdom'], getBooks: f}

Для того чтобы получить доступ к свойствам объекта в методах, мы обращаемся к нему через this и дальше как обычно - «через точку» к свойствам.

const bookShelf = {
  books: ["The Last Kingdom"],
  getBooks() {
    return this.books;
  },
  addBook(bookName) {
    this.books.push(bookName);
  },
  removeBook(bookName) {
    const bookIndex = this.books.indexOf(bookName);
    this.books.splice(bookIndex, 1);
  },
};

console.log(bookShelf.getBooks()); // ["The Last Kingdom"]
bookShelf.addBook("The Mist");
bookShelf.addBook("Dream Guardian");
console.log(bookShelf.getBooks()); // ['The Last Kingdom', 'The Mist', 'Dream Guardian']
bookShelf.removeBook("The Mist");
console.log(bookShelf.getBooks()); // ['The Last Kingdom', 'Dream Guardian']

Будет логично задуматься - почему бы не использовать при обращении к свойствам имя объекта, ведь мы явно не собираемся его менять. 
Дело в том, что имя объекта штука ненадежная, методы одного объекта можно копировать в другой (с другим именем), а в будущем узнаем что часто 
при создании объекта мы заранее вовсе не знаем имени. Использование this гарантирует, что метод работает именно с тем объектом, который его вызвал.

*/
/**
  |============================
  | Ccылки на методы с this
  |============================
*/
/*
Если свойством объекта является метод, использующий this, на него можно делать ссылку в других объектах. При этом конструкция метода this будет использовать 
уже новый объект в качестве истоника.
*/

/**
  |============================
  | Удаление свойств объекта - delete obj.valueKey;
  |============================
*/
/* 
delete obj.firstValueKey;
delete obj.secondValueKey;
*/

/**
  |============================
  | Перебор объекта
  |============================
*/
/* 
В отличии от массива или строки, объект это не итерируемая сущность, то есть его нельзя перебрать циклами for или for...of.




Цикл for...in
Для перебора объектов используется специальный цикл for...in, который перебирает ключи объекта object.

for (key in object) {
  // инструкции
}

Переменная key доступная только в теле цикла. На каждой итерации в неё будет записано значение ключа (имя) свойства. 
Для того чтобы получить значение свойства с таким ключом (именем), используется синтаксис квадратных скобок.

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  rating: 8.38,
};

for (const key in book) {
  // Ключ
  console.log(key);
  // Значение свойства с таким ключом
  console.log(book[key]);
}



Метод hasOwnProperty()
Разберём концепцию собственных и несобственных свойств объекта и научимся правильно использовать цикл for...in.

const animal = {
  legs: 4,
};
const dog = Object.create(animal);
dog.name = "Манго";

console.log(dog); // {name: 'Манго'}
console.log(dog.name); // 'Манго'
console.log(dog.legs); // 4

Метод Object.create(animal) создаёт и возвращает новый объект, связывая его с объектом animal. 
Поэтому можно получить значение свойства legs обратившись к нему как dog.legs, хотя его нет в объекте dog - это несобственное свойство из объекта animal.

Оператор in, который используется в цикле for...in, не делает различия между собственными и несобственными свойствами объекта. 
Эта особенность мешает, так как мы всегда хотим перебрать только собственные свойства. Для того чтобы узнать есть в объекте собственное свойство или нет, 
используется метод hasOwnProperty(key), который возвращает true или false.

// ❌ Возвращает true для всех свойств
console.log("name" in dog); // true
console.log("legs" in dog); // true

// ✅ Возвращает true только для собственных свойств
console.log(dog.hasOwnProperty("name")); // true
console.log(dog.hasOwnProperty("legs")); // false

Поэтому при переборе циклом for...in необходимо на каждой итерации добавить проверку на собственное свойство. 
Даже если сейчас мы уверены в том что у объекта нет несобственных свойств, это оградит от возможных ошибок в будущем.

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  rating: 8.38,
};

for (const key in book) {
  // Если это собственное свойство - выполняем тело if
  if (book.hasOwnProperty(key)) {
    console.log(key);
    console.log(book[key]);
  }

  // Если это не собственное свойство - ничего не делаем
}




Метод Object.keys()
У встроенного класса Object есть несколько полезных методов для работы с объектами. 
Первый из них это Object.keys(obj), который принимает объект и возвращает массив ключей его собственных свойств. 
Если в объекте нет свойств, метод вернёт пустой массив.

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  rating: 8.38,
};
const keys = Object.keys(book);
console.log(keys); // ['title', 'author', 'genres', 'rating']

Скомбинировав результат Object.keys() и цикл for...of можно удобно перебрать собственные свойства объекта, не прибегая к использованию архаического цикла for...in 
с проверками принадлежности свойств.

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  rating: 8.38,
};
const keys = Object.keys(book);

for (const key of keys) {
  // Ключ
  console.log(key);
  // Значение свойства
  console.log(book[key]);
}

Мы перебираем массив ключей объекта и на каждой итерации получаем значение свойства с таким ключом.





Метод Object.values()
Если метод Object.keys(obj) возвращает массив ключей собственных свойств обьекта, то метод Object.values(obj) возвращает массив значений его собственных свойств. 
Если в объекте нет свойств, метод Object.values(obj) вернёт пустой массив.

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  rating: 8.38,
};
const keys = Object.keys(book);
console.log(keys); // ['title', 'author', 'rating']

const values = Object.values(book);
console.log(values); // ['The Last Kingdom', 'Bernard Cornwell', 8.38]

Массив значений свойств также можно перебрать циклом for...of, например для получения общей суммы числовых значений.

Допустим перед нами стоит задача посчитать общее количество продуктов в объекте формата имя-продукта: количество. Тогда подойдет метод Object.values() для того, 
чтобы получить массив всех значений и потом удобно их сложить.

const goods = {
  apples: 6,
  grapes: 3,
  bread: 4,
  cheese: 7,
};

const values = Object.values(goods); // [6, 3, 4, 7]

let total = 0;

for (const value of values) {
  total += value;
}

console.log(total); // 20




Метод Object.entries()
Метод Object.entries(obj) возвращает массив записей, каждым элементом которого будет еще один массив из 2-х элементов: имени свойства и значения этого свойства 
из объекта obj.

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  rating: 8.38,
};
const keys = Object.keys(book);
console.log(keys); // ['title', 'author', 'rating']

const values = Object.values(book);
console.log(values); // ['The Last Kingdom', 'Bernard Cornwell', 8.38]

const entries = Object.entries(book);
console.log(entries);
// [["title", "The Last Kingdom"], ["author", "Bernard Cornwell"], ["rating", 8.38]]

ИНТЕРЕСНО
На практике метод Object.entries(obj) используется редко, только для каких-то очень специфичных задач. 
В 99% случаев будет использован метод Object.keys() или Object.values().
*/

/**
  |============================
  | Массив обьектов
  |============================
*/
/* 
В стандартный набор повседневных задач разработчика входит манипуляция массивом однотипных объектов. 
Это значит что все объекты в массиве гарантированно будут иметь одинаковый набор свойств, но с разными значениями.

const books = [
  {
    title: "The Last Kingdom",
    author: "Bernard Cornwell",
    rating: 8.38,
  },
  {
    title: "На берегу спокойных вод",
    author: "Роберт Шекли",
    rating: 8.51,
  },
  {
    title: "Сон смешного человека",
    author: "Федор Достоевский",
    rating: 7.75,
  },
];

Для перебора такого массива используется стандартный цикл for...of. 
Значения свойств каждого объекта можно получить используя синтаксис «через точку», так как в каждом объекте набор свойств и их имена будут одинаковые, 
отличаются только значения.

for (const book of books) {
  // Объект книги
  console.log(book);
  // Название
  console.log(book.title);
  // Автор
  console.log(book.author);
  // Рейтинг
  console.log(book.rating);
}

Например, получим список названий всех книг в коллекции books.

const bookNames = [];

for (const book of books) {
  bookNames.push(book.title);
}

console.log(bookNames); // ["The Last Kingdom", "На берегу спокойных вод", "Сон смешного человека"]

Узнаем средний рейтинг всей нашей коллекции. Для этого сложим все рейтинги, после чего разделим это значение на количество книг в коллекции.

let totalRating = 0;

for (const book of books) {
  totalRating += book.rating;
}

const averageRating = (totalRating / books.length).toFixed(1);
console.log(averageRating); // 8.2
*/

/**
  |============================
  | Синтаксис spread и rest
  |============================
*/
/* 
В современном стандарте появился новый синтаксис для работы с итерируемыми сущностями, такими как строка, массив или объект. 
Его функционал и название зависит от места применения.



spread: передача аргументов
Операция ... (spread) позволяет распылить коллекцию элементов (массив, строку или объект) в место, где ожидается набор отдельных значений. 
Конечно есть некоторые ограничения, например нельзя распылить массив в объект и наоборот.

Можно привести аналогию с ящиком яблок. Поставив ящик на пол не вынимая из него яблоки, получим аналог массива значений. 
Если высыпать яблоки из ящика на пол, произойдёт распыление - набор отдельных значений.

Отличие всего одно - в JavaScript распыление не изменяет оригинальную коллекцию, то есть делается копия каждого элемента. 
После распыления останется и ящик полный яблок, и копия каждого яблока на полу.

Например, метод Math.max(аргументы) ищет и возвращает самый большой из аргументов (чисел), то есть ожидает не массив значений, а произвольное количество аргументов.

const temps = [14, -4, 25, 8, 11];

// В консоли будет массив
console.log(temps);
// ❌ Так не сработает, потому что передаём целый массив
console.log(Math.max(temps)); // NaN

// В консоли будет набор отдельных чисел
console.log(...temps);
// ✅ Распылим коллекцию элементов как отдельные аргументы
console.log(Math.max(...temps)); // 25

То есть запись Math.max(...[14, -4, 25, 8, 11]), после интерпретации превращается в Math.max(14, -4, 25, 8, 11) - синтаксис ... возвращает распакованный массив, 
то есть распыляет его элементы как отдельные аргументы.




spread: создание нового массива
Операция ... (spread) позволяет создать копию массива или «склеить» произвольное количество массивов в один новый. 
Раньше для этого использовали методы slice() и concat(), но операция распыления позволяет сделать тоже самое в более краткой форме.

const temps = [14, -4, 25, 8, 11];

// Это точная, но независимая копия массива temps
const copyOfTemps = [...temps];
console.log(copyOfTemps); // [14, -4, 25, 8, 11]

В примере выше у нас есть ящик яблок temps и мы хотим сделать его точную копию. Берём пустой ящик и пересыпаем в него яблоки из исходного ящика temps - распыляем 
его в другую коллекцию. При этом ящик temps не изменится, в нём все ещё будут яблоки, а в новом ящике - их точные копии.

В следующем примере мы ссыпаем яблоки из двух ящиков в один новый. Оригинальные ящики (массивы) не изменятся, а в новом будут копии всех их яблок (элементов). 
Порядок распыления важен - он влияет на порядок элементов в новой коллекции.

const lastWeekTemps = [14, 25, 11];
const currentWeekTemps = [23, 17, 18];
const allTemps = [...lastWeekTemps, ...currentWeekTemps];
console.log(allTemps); // [14, 25, 11, 23, 17, 18]




spread: создание нового объекта
Операция ... (spread) позволяет распылить свойства произвольного количества объектов в один новый.

const first = { propA: 5, propB: 10 };
const second = { propC: 15 };
const third = { ...first, ...second };
console.log(third); // { propA: 5, propB: 10, propC: 15 }

Порядок распыления имеет значение. Имена свойств объекта уникальные, поэтому свойства распыляемого объекта могут перезаписать значение уже существующего свойства, 
если их имена совпадают.

const first = { propA: 5, propB: 10, propC: 50 };
const second = { propC: 15, propD: 20 };

const third = { ...first, ...second };
console.log(third); // { propA: 5, propB: 10, propC: 15, propD: 20 }

const fourth = { ...second, ...first };
console.log(fourth); // { propA: 5, propB: 10, propC: 50, propD: 20 }

Если бы яблоки в ящике имели наклейки с метками, то в одном ящике не может быть двух яблок с одинаковыми метками. 
Поэтому при пересыпании второго ящика, все яблоки, метки которых совпадут с теми что уже есть в новом, заменят те что уже есть.

Во время распыления можно добавлять свойства в произвольное место. Главное помнить про уникальность имени свойства и о том, что его значение может быть перезаписано.

const first = { propA: 5, propB: 10, propC: 50 };
const second = { propC: 15 };

const third = { propB: 20, ...first, ...second };
console.log(third); // { propA: 5, propB: 10, propC: 15 }

const fourth = { ...first, ...second, propB: 20 };
console.log(fourth); // { propA: 5, propB: 20, propC: 15 }

const fifth = { ...first, propB: 20, ...second };
console.log(fifth); // { propA: 5, propB: 20, propC: 15 }






rest: сбор всех аргументов функции
Операция ... (rest) позволяет собрать группу независимых элементов в новую коллекцию. 
Синтаксически это близнец операции распыления, но отличить их просто - распыление это когда ... находится в правой части операции присваивания, 
а сбор это когда ... находится в её левой части.

Вернёмся к аналогии с яблоками. Если на полу лежат яблоки и у нас есть пустой ящик, то операция rest позволит «собрать» яблоки в ящик. 
При этом оригинальные яблоки останутся на полу, а в ящике будет копия каждого яблока.

Одна из областей применения операции rest это создание функций которые могут принимать произвольное количество аргументов.

// Как объявить параметры функции так,
// чтобы можно было передать любое кол-во аргументов?
function multiply() {
  // ...
}

multiply(1, 2);
multiply(1, 2, 3);
multiply(1, 2, 3, 4);

Если убрать весь «синтаксический шум» и посмотреть на аргументы и параметры функции, то аргументы находятся в правой части операции присваивания, 
а параметры в левой, потому что значения аргументов присваиваются объявленным параметрам. Значит можно «собрать» все аргументы функции в один 
параметр используя операцию rest.

function multiply(...args) {
  console.log(args); // массив всех аргументов
}

multiply(1, 2);
multiply(1, 2, 3);
multiply(1, 2, 3, 4);

Имя параметра может быть произвольным. Чаще всего его называют args, restArgs или otherArgs, сокращённое от arguments.





rest: сбор части аргументов функции
Операция ... (rest) также позволяет собрать в массив только ту часть аргументов, которая необходима, объявив параметры до «сбора».

function multiply(firstNumber, secondNumber, ...otherArgs) {
  console.log(firstNumber); // Значение первого аргумента
  console.log(secondNumber); // Значение второго аргумента
  console.log(otherArgs); // Массив остальных аргументов
}

multiply(1, 2);
multiply(1, 2, 3);
multiply(1, 2, 3, 4);

Все агументы, для которых будут объявлены параметры, передадут им свои значения, остальные аргументы будут помещены в массив. 
Операция rest собирает все оставшиеся аргументы и поэтому должна идти последней в подписи функции, иначе будет ошибка.
*/

/**
  |============================
  | Деструктуризация объектов
  |============================
*/
/* 
При разработке программ данные приходят, как правило, в виде массивов и объектов, значения которых необходимо записать в локальные переменные. 
Для того, чтобы делать это максимально просто, в современном стандарте есть синтаксис деструктуризирующего присваивания.



Деструктуризация объектов
Сложные данные всегда представлены объектом. Множественные обращения к свойствам объекта визуально загрязняют код.

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  isPublic: true,
  rating: 8.38,
};

const accessType = book.isPublic ? "публичном" : "закрытом";
const message = `Книга ${book.title} автора ${book.author} с рейтингом ${book.rating} находится в ${accessType} доступе.`;


Деструктуризация позволяет «распаковать» значения свойств объекта в локальные переменные. Это делает код в месте их использования менее «шумным».

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  isPublic: true,
  rating: 8.38,
};

// Деструктуризируем
const { title, author, isPublic, rating, coverImage } = book;
console.log(coverImage); // undefined

const accessType = isPublic ? "публичном" : "закрытом";
const message = `Книга ${title} автора ${author} с рейтингом ${rating} находится в ${accessType} доступе.`;

Деструктуризация всегда находится в левой части операции присвоения. Переменным внутри фигурных скобок присваиваются значения свойств объекта. 
Если имя переменной и имя свойства совпадают, то происходит присваивание, в противном случае ей будет присвоено undefined. 
Порядок объявления переменных в фигурных скобках не важен.




Значения по умолчанию
Для того чтобы избежать присвоения undefined при деструктуризации несуществующих свойств объекта, можно задать переменным значения по умолчанию, 
которые будут присвоены только в случае когда в объекте нет свойства с таким именем.

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
};

// Добавим картинку обложки если её нет в объекте книги
const {
  title,
  coverImage = "https://via.placeholder.com/640/480",
  author,
} = book;

console.log(title); // The Last Kingdom
console.log(author); // Bernard Cornwell
console.log(coverImage); // https://via.placeholder.com/640/480




Изменение имени переменной
При деструктуризации можно изменить имя переменной в которую распаковывается значение свойства. 
Сначала пишем имя свойства из которого хотим получить значение, после чего ставим двоеточие и пишем имя переменной в которую необходимо поместить значение 
этого свойства.

const firstBook = {
  title: "The Last Kingdom",
  coverImage:
    "https://images-na.ssl-images-amazon.com/images/I/51b5YG6Y1rL.jpg",
};

const {
  title: firstTitle,
  coverImage: firstCoverImage = "https://via.placeholder.com/640/480",
} = firstBook;

console.log(firstTitle); // The Last Kingdom
console.log(firstCoverImage); // https://images-na.ssl-images-amazon.com/images/I/51b5YG6Y1rL.jpg

Такая запись читается как «Создать переменную firstTitle, в которую поместить значение свойства title из объекта firstBook» и т. д.




Деструктуризация в циклах
При переборе массива объектов циклом for...of получаеются множественные обращения к свойствам объекта.

const books = [
  {
    title: "The Last Kingdom",
    author: "Bernard Cornwell",
    rating: 8.38,
  },
  {
    title: "На берегу спокойных вод",
    author: "Роберт Шекли",
    rating: 8.51,
  },
];

for (const book of books) {
  console.log(book.title);
  console.log(book.author);
  console.log(book.rating);
}

Для того чтобы сократить количество повторений можно деструктуризировать свойства объекта в локальные переменные в теле цикла.

for (const book of books) {
  const { title, author, rating } = book;

  console.log(title);
  console.log(author);
  console.log(rating);
}

Если в объекте немного свойств, деструктуризацию можно выполнить прямо в месте объявления переменной book.

for (const { title, author, rating } of books) {
  console.log(title);
  console.log(author);
  console.log(rating);
}




Глубокая деструктуризация
Для деструктуризации свойств вложенных объектов используются те же принципы, что и в трёх предыдущих упражнениях.

const user = {
  name: "Jacques Gluke",
  tag: "jgluke",
  stats: {
    followers: 5603,
    views: 4827,
    likes: 1308,
  },
};

const {
  name,
  tag,
  stats: { followers, views: userViews, likes: userLikes = 0 },
} = user;

console.log(name); // Jacques Gluke
console.log(tag); // jgluke
console.log(followers); // 5603
console.log(userViews); // 4827
console.log(userLikes); // 1308
*/

/**
  |============================
  | Деструктуризация с rest ...
  |============================
*/
/* 
Если деструктуризация осуществляется из объекта - получаем объект
function foo({name, age, ...props})     // props - объект


Если деструктуризация осуществляется из массива - получаем массив
function foo([name, age, ...props])     // props - массив
*/

/**
  |============================
  | Деструктуризация массивов
  |============================
*/
/* 
Деструктуризирующее присваивание можно использовать и для массивов, но с некоторыми особенностями.

Вместо фигурных скобок {} используются квадратные [].
Переменным, указанным в квадратных скобках [], будут последовательно присваиваться значения элементов массива.
Например, есть массив цветов из которого нужно в отдельные переменные получить значения каждой составляющей цвета.

const rgb = [200, 255, 100];
const [red, green, blue] = rgb;

console.log(`R:${red},G:${green},B:${blue}`); // "R:200,G:255,B:100"

После ключевого слова const или let ставим открывающую и закрывающую квадратные скобки, как при объявлении массива. 
Внутри скобок, через запятую, указываем имена переменных, в которые будут помещены значения массива.

В результате такой записи будут созданы 3 переменные и в них будут помещены элементы в нумерованном порядке - от 0 и до конца массива.

При деструктуризации массивов, значение переменной может быть присвоено после ее объявления. На практике это используется редко.

const rgb = [200, 255, 100];
let red, green, blue;

[red, green, blue] = rgb;

console.log(`R:${red},G:${green},B:${blue}`); // "R:200,G:255,B:100"

Если переменных больше чем элементов массива, им будет присвоено undefined, поэтому можно указывать значения по умолчанию.

const rgb = [200, 100, 255];

const [red, green, blue, alfa = 0.3] = rgb;

console.log(`R:${red},G:${green},B:${blue},Alfa:${alfa}`); // "R:200,G:100,B:255,Alfa:0.3"

Иногда из массива необходимо деструктуризировать только первые N элементов, а остальные сохранить в одну переменную в виде массива. 
При деструкции массива можно распаковать и присвоить оставшуюся часть элементов массива переменной, используя операцию ... (rest).

const rgb = [200, 255, 100];

const [red, ...colors] = rgb;

console.log(red); // "200"
console.log(colors); // [255, 100]

Элементы можно пропускать. Допустим, из массива rgb необходимо взять только последнее значение. 
На практике эта возможность используется редко.

const rgb = [200, 100, 255];

const [, , blue] = rgb;

console.log(`Blue: ${blue}`); // "Blue: 255"
*/

/**
  |============================
  | Паттерн «Объект параметров»
  |============================
*/
/* 
Если функция принимает более двух-трёх аргументов, очень просто запутаться в какой последовательности что передавать. 
В результате получается очень неочевидный код в месте её вызова.

function doStuffWithBook(title, numberOfPages, downloads, rating, public) {
  // (код функии)
  console.log(title);
  console.log(numberOfPages);
  // И так далее
}

doStuffWithBook("The Last Kingdom", 736, 10283, 8.38, true);
// ❌ Что такое 736? Что такое 10283? Что такое true?


Паттерн «Объект параметров» помогает решить эту проблему, заменяя набор параметров всего одним - объектом с именованными свойствами.

function doStuffWithBook(book) {
  // (код функии)
  console.log(book.title);
  console.log(book.numberOfPages);
  // И так далее
}

Тогда во время её вызова передаём один объект с необходимыми свойствами.

// ✅ Всё понятно
doStuffWithBook({
  title: "The Last Kingdom",
  numberOfPages: 736,
  downloads: 10283,
  rating: 8.38,
  isPublic: true,
});

Ещё один плюс в том, что можно деструктуризировать объект в параметре book. Это можно сделать в теле функции.

function doStuffWithBook(book) {
  const { title, numberOfPages, downloads, rating, isPublic } = book;
  console.log(title);
  console.log(numberOfPages);
  // И так далее
}

Или сразу в сигнатуре (подписи) функции, разницы нет.

function doStuffWithBook({
  title,
  numberOfPages,
  downloads,
  rating,
  isPublic,
}) {
  console.log(title);
  console.log(numberOfPages);
  // И так далее
}
*/

/**
  |============================
  | Object.freeze(obj), set, get
  |============================
*/
/* 
Object.freeze(obj) не допускает любые изменения объекта obj


Используется часто вместе с сеттерами и геттерами (set, get), которыми можно устанавливать правила для внесения изменений в объект.
set name(newName) {
  return
}
get name() {
  return this.name
}
*/

/**
  |============================
  | Оператор опциональной (безопасной) последовательности ?.
  |============================
*/

/* 
Оператор опциональной последовательности ?. позволяет получить значение свойства, находящегося на любом уровне вложенности в цепочке связанных между собой объектов, 
без необходимости проверять каждое из промежуточных свойств в ней на существование. ?. работает подобно оператору ., за исключением того, что не выбрасывает исключение,
если объект, к свойству или методу которого идёт обращение, равен null или undefined. В этих случаях он возвращает undefined.

Таким образом, мы получаем более короткий и понятный код при обращении к вложенным по цепочке свойствам объекта, когда есть вероятность, что какое-то из них отсутствует.

const countPlayers = Object.keys(obj)?.length;

const dogName = adventurer.dog?.name;
*/

/**
  |============================
  | Безопасная деструктуризация с использованием пустых значений по умолчанию = {}
  |============================
*/
/* 
При деструктуризации и глубокой деструктуризации объектов, которые используются как аргументы, вероятна работа с объектом, не имеющим всех деструктуризируемых свойств.
В этом случае будет осуществояться деструктуризация их undefined свойств, что приведет к ошибке. 
Поэтому рекомендуется задавать значения по умолчанию для таких свойств и объектов, например, - = {} - пустой объект. В таком случае при деструктуризаии 
из таких свойств и объектов будем получать не ошибку, а значения переменных undefined.

function displayProductInfo({name, price, category, details: {brand, color, weight} = {},} = {}) {
  console.log(name);
}
*/

/**
  |============================
  | Колбэк-функции
  |============================
*/
/* 
Функции не отличаются от чисел, строк или массивов - это просто специальный тип данных (объект высшего порядка), значение, которое можно хранить в переменной 
или передавать как аргумент в другую функцию.

function greet(name) {
  return `Добро пожаловать ${name}.`;
}

// Вызываем функцию greet и выводим результат в консоль
console.log(greet("Манго")); // Добро пожаловать Манго.

// Выводим функцию greet в консоль не вызывая её
console.log(greet); // ƒ greet() { return `Добро пожаловать ${name}.`; }

В первом логе мы вызываем функцию greet при помощи круглых скобок и в консоль выводится результат её выполнения. 
Во втором логе передаётся ссылка на функцию, а не результат вызова (отсуствуют круглые скобки), поэтому в консоль выводится её тело. 
Это значит, что функцию можно присвоить в переменную или передать как аргумент другой функции.

Функция обратного вызова (callback, колбэк) - это функция, которая передаётся другой функции в качестве аргумента и та, в свою очередь, вызывает переданную функцию.

Функция высшего порядка(higher order function) - функция, принимающая в качестве параметров другие функции или возвращающая функцию как результат.

// Колбэк-функция
function greet(name) {
  console.log(`Добро пожаловать ${name}.`);
}

// Функция высшего порядка
function registerGuest(name, callback) {
  console.log(`Регистрируем гостя ${name}.`);
  callback(name);
}

registerGuest("Манго", greet);

Мы передали ссылку на функцию greet как аргумент, поэтому она будет присвоена в параметр callback и вызвана внури функции registerGuest через круглые скобки. 
Имя параметра для колбэка может быть произвольным, главное помнить, что значением будет функция.




Инлайн колбэки
Если колбэк-функция маленькая и нужна только для передачи аргументом, её можно объявить прямо при вызове функции в которую передаём колбэк. 
Такая функция будет доступна только как значение параметра и больше нигде в коде.

function registerGuest(name, callback) {
  console.log(`Регистрируем гостя ${name}.`);
  callback(name);
}

// Передаём инлайн функцию greet как колбэк
registerGuest("Манго", function greet(name) {
  console.log(`Добро пожаловать ${name}.`);
});

// Передаём инлайн функцию notify как колбэк
registerGuest("Поли", function notify(name) {
  console.log(`Уважаемый(ая) ${name}, ваш номер будет готов через 30 минут.`);
});




Несколько колбэков
Функция может принимать произвольное количество колбэков. Например, представим что мы пишем логику принятия звонков для телефона. 
Программа должна включить автоответчик если абонент недоступен, или соединить звонок в противном случае. 
Доступность абонента будем имитировать генератором случайного числа, чтобы между разными вызовами функции можно было получить различные результаты.

function processCall(recipient) {
  // Имитируем доступность абонента случайным числом
  const isRecipientAvailable = Math.random() > 0.5;

  if (!isRecipientAvailable) {
    console.log(`Абонент ${recipient} недоступен, оставьте сообщение.`);
    // Логика активации автоответчика
  } else {
    console.log(`Соединяем с ${recipient}, ожидайте...`);
    // Логика принятия звонка
  }
}

processCall("Манго");

Проблема такого подхода в том, что функция processCall делает слишком много и привязывает проверку доступности абонента к двум заранее определённым действиям. 
Что если в будущем вместо автоответчика нужно будет оставлять голограмму?

Мы могли бы написать функцию так, чтобы она возвращала какое-то значение и потом по результату её выполнения делать проверки и выполнять нужный код. 
Но проверки не относятся к внешнему коду и будут его засорять.

Выполним рефакторинг функции так, чтобы она принимала два колбэка onAvailable и onNotAvailable, и вызывала их по условию.

function processCall(recipient, onAvailable, onNotAvailable) {
  // Имитируем доступность абонента случайным числом
  const isRecipientAvailable = Math.random() > 0.5;

  if (!isRecipientAvailable) {
    onNotAvailable(recipient);
    return;
  }

  onAvailable(recipient);
}

function takeCall(name) {
  console.log(`Соединяем с ${name}, ожидайте...`);
  // Логика принятия звонка
}

function activateAnsweringMachine(name) {
  console.log(`Абонент ${name} недоступен, оставьте сообщение.`);
  // Логика активации автоответчика
}

function leaveHoloMessage(name) {
  console.log(`Абонент ${name} недоступен, записываем голограмму.`);
  // Логика записи голограммы
}

processCall("Манго", takeCall, activateAnsweringMachine);
processCall("Поли", takeCall, leaveHoloMessage);

Колбэки применяются для обработки действий пользователя на странице, при обработке запросов на сервер, выполнения заранее неизвестных функций и т. п. 
В этом и заключается их суть - это функции предназначенные для отложенного выполнения.




Абстрагирование повторения
Абстракция - скрытие деталей реализации. Позволяет думать о задачах на более высоком (абстрактном) уровне. Функции это хороший способ построения абстракций.

Например, скрипт выполняет какое-то действие определенное количество раз. Для этого можно написать цикл for.

for (let i = 0; i < 10; i += 1) {
  console.log(i);
}

Можем ли мы абстрагировать «делать что-то N раз» как функцию? - да, напишем функцию, которая вызывает console.log() N раз.

function repeatLog(n) {
  for (let i = 0; i < n; i += 1) {
    console.log(i);
  }
}

repeatLog(5);

Но что, если мы хотим сделать что-то, кроме логирования чисел? Поскольку «делать что-то» можно представить как функцию, а функции - это просто значения, 
мы можем передать действие как аргумент.

function printValue(value) {
  console.log(value);
}

function prettyPrint(value) {
  console.log("Logging value: ", value);
}

function repeat(n, action) {
  for (let i = 0; i < n; i += 1) {
    action(i);
  }
}

// Передаем printValue как callback-функцию
repeat(3, printValue);
// 0
// 1
// 2

// Передаем prettyPrint как callback-функцию
repeat(3, prettyPrint);
// Logging value: 0
// Logging value: 1
// Logging value: 2
*/

/**
  |============================
  | Метод forEach
  |============================
*/
/* 
Перебирающий метод массива который используется как замена циклов for и for...of при работе с коллекцией данных.

массив.forEach(function callback(element, index, array) {
  // Тело коллбек-функции
});

Поэлементно перебирает массив.
Вызызвает коллбек-функцию для каждого элемента массива.
Ничего не возвращает.
Аргументы коллбек-функции это значение текущего элемента element, его индекс index и сам исходный массив array. 
Объявлять можно только те параметры которые нужны, чаще всего это элемент, главное не забывать про их порядок.

const numbers = [5, 10, 15, 20, 25];

// Классический for
for (let i = 0; i < numbers.length; i += 1) {
  console.log(`Индекс ${i}, значение ${numbers[i]}`);
}

// Перебирающий forEach
numbers.forEach(function (number, index) {
  console.log(`Индекс ${index}, значение ${number}`);
});

Единственным случаем, когда стоит использовать циклы for или for...of для перебора массива, это задачи с прерыванием выполнения цикла. 
Прервать выполнение метода forEach нельзя, он всегда перебирает массив до конца.

*/

/**
  |============================
  | Стрелочные функции
  |============================
*/
/* 
Стрелочные функции имеют сокращённый, более лаконичный синтаксис, что уменьшает объем кода, особенно когда функция маленькая или если она используется как коллбек.

Все стрелки создаются как функциональное выражение, и если функция не анонимна, то она должна быть присвоена переменной.

// Обычное объявление функции
function classicAdd(a, b, c) {
  return a + b + c;
}

// Тоже самое как стрелочная функция
const arrowAdd = (a, b, c) => {
  return a + b + c;
};

Ключевое слово function не используется, вместо этого сразу идёт объявление параметров, за которыми следует символ => и тело функции.

Если параметров несколько, то они перечисляются через запятую в круглых скобках, между знаками равно = и стрелкой =>.

const add = (a, b, c) => {
  return a + b + c;
};

Если параметр один, его объявление может быть без круглых скобок.

const add = a => {
  return a + 5;
};

Если параметров нет, то обязательно должны быть пустые круглые скобки.

const greet = () => {
  console.log("Привет!");
};

Если используем деструктуризацию, то обязательно должны быть  круглые скобки, даже если параметр всего один.
const greet = ({a}) => {
  return a + 5;
};



Неявный возврат
В стрелочной функции после символа => идёт её тело. Здесь может быть два варианта: с фигурными скобками и без них.

const add = (a, b, c) => {
  console.log(a, b, c);
  return a + b + c;
};

Если фигурные скобки есть, и функция должна возвращать какое-то значение, необходимо явно поставить return. Это называется явный возврат (explicit return). 
Такой синтаксис используется в том случае, если в теле функции нужно выполнить ещё какие-то инструкции кроме возврата значения.

const add = (a, b, c) => a + b + c;

Если фигурных скобок нет, то возвращается результат выражения стоящего после =>. Это называется неявный возврат (implicit return). 
В примере вернётся результат выражения сложения параметров a, b и c.

Синтаксис неявного возврата сильно сокращает «шум» объявления функции с телом и возвращаемым выражением, но подходит только в случае когда в теле функции 
не нужно выполнять никаких дополнительных инструкций кроме возврата значения.

// До
function classicAdd(a, b, c) {
  return a + b + c;
}

// После
const arrowAdd = (a, b, c) => a + b + c;




Псевдомассив arguments
У стрелочных функций нет локальной переменной arguments, содержащей все аргументы. Если необходимо собрать все аргументы в массив, используется операция rest.

const add = (...args) => {
  console.log(args);
};

add(1, 2, 3); // [1, 2, 3]






Стрелочные функции как коллбеки
Анонимные стрелочные функции отлично подходят как коллбеки для перебирающих методов массива из-за более краткого синтаксиса объявления, 
особенно если не нужно тело функции.

const numbers = [5, 10, 15, 20, 25];

// Объявление функции
numbers.forEach(function (number, index) {
  console.log(`Индекс ${index}, значение ${number}`);
});

// Анонимная стрелочная функция
numbers.forEach((number, index) => {
  console.log(`Индекс ${index}, значение ${number}`);
});

Стрелочную коллбек-функцию также можно объявлять отдельно и передавать на неё ссылку. 
Это стоит делать если одна функция используется в нескольих местах программы или если она громоздкая.

const numbers = [5, 10, 15, 20, 25];

const logMessage = (number, index) => {
  console.log(`Индекс ${index}, значение ${number}`);
};

numbers.forEach(logMessage);
*/

/**
  |============================
  | Разновидности кода
  |============================
*/
/* 
Императивное программирование
Описывает процесс вычисления в виде заданной последовательности инструкций, изменяющих состояние программы. Описание того, как что-то выполняется.
Императивный стиль программирования - это такой, который дает машине набор детальных инструкций для выполнения задачи. 
Например цикл for, который предоставляет точные указания для итерации по индексам массива.
Можно провести аналогию с рецептом приготовления блюда. Рецепт - это набор пошаговых инструкций для получения желаемого результата.


Декларативное программирование
Описывает то, что мы хотим получить в результате, а не как это сделать. Порядок выполнения и способ достижения не важен.
Когда мы пишем HTML-код, то декларативно, при помощи тегов и атрибутов, описываем то, что хотим получить в результате. 
Браузер читает этот код и сам выполняет все необходимые операции по созданию HTML-элементов и помещению их на страницу.
Можно провести аналогию с меню ресторана. Это декларативный набор возможных к заказу блюд, детали приготовления и подачи которых скрыты.
Декларативное описание задачи более наглядно и легче формулируется. Мы говорим, что хотим сделать, вызвав метод или функцию. 
Ее реализация, скорее всего использует императивный код, но он скрыт внутри и не усложняет понимание основного кода.



Императивный vs декларативный
Рассмотрим разницу подходов на примере базовой операции фильтрации коллекции. Напишем код перебора и фильтрации массива чисел по какому-то критерию.

// Императивный подход
const numbers = [1, 2, 3, 4, 5];
const filteredNumbers = [];

for (let i = 0; i < numbers.length; i += 1) {
  if (numbers[i] > 3) {
    filteredNumbers.push(numbers[i]);
  }
}

console.log(filteredNumbers); // [4, 5]


// Декларативный подход
const numbers = [1, 2, 3, 4, 5];
const filteredNumbers = numbers.filter(value => value > 3);
console.log(filteredNumbers); // [4, 5]

Метод filter() скрывает в себе логику перебора коллекции и вызывает callback-функцию, которую мы ему передаем для каждого элемента, 
возвращая массив элементов, подошедших под критерий.
*/

/**
  |============================
  | Чистые функции
  |============================
*/
/* 
Функция с побочными эффектами - это функция которая в процессе выполнения может изменять или использовать глобальные переменные, 
изменять значение аргументов ссылочного типа, выполнять операции ввода-вывода и т. п.

const dirtyMultiply = (array, value) => {
  for (let i = 0; i < array.length; i += 1) {
    array[i] = array[i] * value;
  }
};

const numbers = [1, 2, 3, 4, 5];
dirtyMultiply(numbers, 2);
// Произошла мутация исходных данных - массива numbers
console.log(numbers); // [2, 4, 6, 8, 10]

Функция dirtyMultiply(array, value) умножает каждый элемент массива array на число value. Она изменяет (мутирует) исходный массив по ссылке.



Чистая функция (pure function) - это функция результат которой зависит только от значений переданных аргументов. 
При одинаковых аргументах она всегда возвращает один и тот же результат и не имеет побочных эффектов, то есть не изменяет значения аргументов.

Напишем реализацию чистой функции умножения элементов массива, возвращающей новый массив, не изменяя исходный.

const pureMultiply = (array, value) => {
  const newArray = [];

  array.forEach(element => {
    newArray.push(element * value);
  });

  return newArray;
};

const numbers = [1, 2, 3, 4, 5];
const doubledNumbers = pureMultiply(numbers, 2);

// Не произошло мутации исходных данных
console.log(numbers); // [1, 2, 3, 4, 5]
// Функция вернула новый массив с изменёнными данными
console.log(doubledNumbers); // [2, 4, 6, 8, 10]
*/

/**
  |============================
  | Перебирающие методы массива
  |============================
*/
/* 
В JavaScript есть методы массивов пришедшие из функциональных языков. Большинство из них это чистые функции. 
Они создают новый массив, заполняют его, применяя к значению каждого элемента указанную коллбек-функцию, после чего возвращают этот новый массив.

Все перебирающие методы массивов имеют схожий синтаксис. Исходный массив array, вызов метода method и callback-функция callback в качестве аргумента метода.

array.method(callback[currentValue, index, array])

В большинстве методов, аргументами callback-функции являются значение элемента currentValue (первый параметр), позиция элемента index (второй параметр) 
и сам исходный массив array (третий параметр).

array.method((item, idx, arr) => {
  // логика которая будет применяться на каждой итерации
});

Все параметры, кроме значения элемента item, необязательны. Названия параметров могут быть любые, но есть неофициальные соглашения.

array.method(item => {
  // логика которая будет применяться на каждой итерации
});
*/

/**
  |============================
  | Метод map()
  |============================
*/
/* 
Метод map(callback) используется для трансформации массива. Он вызывает коллбек-функцию для каждого элемента исходного массива, а результат её работы записывает 
в новый массив, который и будет результатом выполнения метода.

массив.map((element, index, array) => {
  // Тело коллбек-функции
});

Поэлементно перебирает оригинальный массив.
Не изменяет оригинальный массив.
Результат работа коллбек-функции записывается в новый массив.
Возвращает новый массив такой же длины.
Его можно использовать для того, чтобы изменить каждый элемент массива. Оригинальный массив используется как эталон, на базе которого можно сделать другую коллекцию.

const planets = ["Земля", "Марс", "Венера", "Юпитер"];

const planetsInUpperCase = planets.map(planet => planet.toUpperCase());
console.log(planetsInUpperCase); // ['ЗЕМЛЯ', 'МАРС', 'ВЕНЕРА', 'ЮПИТЕР']

const planetsInLowerCase = planets.map(planet => planet.toLowerCase());
console.log(planetsInLowerCase); // ['земля', 'марс', 'венера', 'юпитер']

// Оригинальный массив не изменился
console.log(planets); // ['Земля', 'Марс', 'Венера', 'Юпитер']

Использование анонимных стрелочных функций с неявным возвратом сильно сокращает «шум» объявления коллбек-функции, делая код чище и проще для восприятия.

Массив объектов
Мы уже знаем что повседневная задача это манипуляция массивом объектов. Например, получить массив значений свойства из всех объектов. 
Есть массив студентов, а нужно получить отдельный массив их имён.

const students = [
  { name: "Манго", score: 83 },
  { name: "Поли", score: 59 },
  { name: "Аякс", score: 37 },
  { name: "Киви", score: 94 },
  { name: "Хьюстон", score: 64 },
];

const names = students.map(student => student.name);
console.log(names); // ['Манго', 'Поли', 'Аякс', 'Киви', 'Хьюстон']

Используя метод map() можно перебрать массив объектов, и в коллбек-функции вернуть значение свойства каждого из них.
*/

/**
  |============================
  | В чем разница между Map и ForEach?
  |============================
*/
/* 
forEach() —  выполняет указанную функцию для каждого элемента массива.
map()  — создаёт новый массив с результатом вызова указанной функции для каждого элемента массива.

Функция forEach() фактически ничего не возвращает (undefined). Она просто вызывает указанную функцию для каждого элемента вашего массива. 
Этот каллбек разрешает мутировать вызывающий массив.
В то времк как, map() вызовет указанную функцию для каждого элемента массива. Разница в том, что map() использует возвращаемые значения и фактически 
возвращает новый массив того же размера.

Функция map() выделяет память и сохраняет возвращаемые значения. 
forEach() же в свою очередь отбрасывает возвращаемые значения и всегда возвращает undefined . 
forEach() позволяет функции обратного вызова мутировать текущий массив. В то время как map() вместо этого вернет новый массив.
*/

/**
  |============================
  | Метод flatMap()
  |============================
*/
/* 
Метод flatMap(callback) аналогичен методу map(), но применяется в случаях когда результат это многомерный массив который необходимо «разгладить».

массив.flatMap((element, index, array) => {
  // Тело коллбек-функции
});

В массиве students хранится список студентов со списком предметов которые посещает студент в свойстве courses. Несколько студентов могут посещать один и тот же предмет. Необходимо составить список всех предметов которые посещает эта группа студентов, пока даже повторяющихся.

const students = [
  { name: "Манго", courses: ["математика", "физика"] },
  { name: "Поли", courses: ["информатика", "математика"] },
  { name: "Киви", courses: ["физика", "биология"] },
];

students.map(student => student.courses);
// [['математика', 'физика'], ['информатика', 'математика'], ['физика', 'биология']]

students.flatMap(student => student.courses);
// ['математика', 'физика', 'информатика', 'математика', 'физика', 'биология'];

Он вызывает коллбек-функцию для каждого элемента исходного массива, а результат её работы записывает в новый массив. 

Отличие от map() в том, что новый массив «разглаживается» на глубину равную единице (одна вложенность). Этот разглаженный массив и есть результат работы flatMap().
*/

/**
  |============================
  | Метод Flat(n)
  |============================
*/
/* 
Метод Flat(n) Разглаживает массив на заданную глубину - n

const arr1 = [0, 1, 2, [3, [4, [5]]]]
const result = arr`.flat(3)
console.log(result)        //    


Определяем глубину n с помощью рекурсивной функции
const arr = [0, 1, 2, [3, [4, [5]]]]
function findDepth(arr) {
  let depth = 0;
  for (const item of arr) {
    if (Array.isArray(item)) {
      depth += 1;
      depth += findDepth(item);
    }
  }
  return depth;
}


*/

/**
  |============================
  | Метод filter()
  |============================
*/
/* 
Метод filter(callback) используется для единственной операции - фильтрации массива, то есть когда необходимо выбрать более одного элемента из коллекции 
по какому-то критерию.

массив.filter((element, index, array) => {
  // Тело коллбек-функции
});

Не изменяет оригинальный массив.
Поэлементно перебирает оригинальный массив.
Возвращает новый массив.
Добавляет в возвращаемый массив элементы которые удовлетворяют условию коллбек-функции.
Если коллбек вернул true элемент добавляется в возвращаемый массив.
Если коллбек вернул false элемент не добавляется в возвращаемый массив.
Если ни один элемент не удовлетворил условию, возвращает пустой массив.


const values = [51, -3, 27, 21, -68, 42, -37];

const positiveValues = values.filter(value => value >= 0);
console.log(positiveValues); // [51, 27, 21, 42]

const negativeValues = values.filter(value => value < 0);
console.log(negativeValues); // [-3, -68, -37]

const bigValues = values.filter(value => value > 1000);
console.log(bigValues); // []

// Оригинальный массив не изменился
console.log(values); // [51, -3, 27, 21, -68, 42, -37]

То есть метод filter вызывает коллбек-функцию для каждого элемента исходного массива и если результат её выполнения true, текущий элемент добавляет в новый массив.

Фильтрация уникальных элементов
Используя метод filter() можно выполнить фильтрацию массива так, что в нём останутся только уникальные элементы. 
Этот приём работает только с массивом примитивных значений - не объектов.

Вернёмся к группе студентов и массиву всех посещаемых предметов, которые мы получили методом flatMap().

const students = [
  { name: "Манго", courses: ["математика", "физика"] },
  { name: "Поли", courses: ["информатика", "математика"] },
  { name: "Киви", courses: ["физика", "биология"] },
];

const allCourses = students.flatMap(student => student.courses);
// ['математика', 'физика', 'информатика', 'математика', 'физика', 'биология'];

В переменной allCourses хранится массив всех посещаемых предметов, которые могут повторяться. 
Задача заключается в том, чтобы сделать новый массив, в котором будут только уникальные предметы, то есть без повторений.

const uniqueCourses = allCourses.filter(
  (course, index, array) => array.indexOf(course) === index
);

Используя array.indexOf(course) выполняем поиск первого совпадения текущего элемента course и получаем его индекс в оригинальном массиве всех курсов. 
В параметре index хранится индекс текущего элемента course при переборе массива методом filter.

Если результат indexOf() и значение index равны - это уникальный элемент, потому что это первый раз когда такое значение встречается в массиве 
и на текущей итерации фильтр обрабатывает именно его.

# Массив всех курсов
['математика', 'физика', 'информатика', 'математика', 'физика', 'биология'];

Для элемента 'математика' под индексом 0:

indexOf() вернёт 0, потому что ищет первое совпадение.
Значение параметра index будет 0.
Они равны, значит это уникальный элемент.
Для элемента 'математика' под индексом 3:

indexOf() вернёт 0, потому что ищет первое совпадение.
Значение параметра index будет 3.
Они не равны, значит это повторяющийся - не уникальный элемент.



Массив объектов
При работе с массивом объектов выполняется фильтрация по значению какого-то свойства. В результате получается новый массив отфильтрованных объектов.

Например, есть массив студентов с баллами за тест. Необходимо отфильтровать лучших (балл выше 80), худших (балл ниже 50) и средних студентов (балл от 50 до 80).

const LOW_SCORE = 50;
const HIGH_SCORE = 80;
const students = [
  { name: "Манго", score: 83 },
  { name: "Поли", score: 59 },
  { name: "Аякс", score: 37 },
  { name: "Киви", score: 94 },
  { name: "Хьюстон", score: 64 },
];

const best = students.filter(student => student.score >= HIGH_SCORE);
console.log(best); // Массив объектов с именами Манго и Киви

const worst = students.filter(student => student.score < LOW_SCORE);
console.log(worst); // Массив с одним объектом Аякс

// В коллбек-функции удобно деструктуризировать свойства объекта
const average = students.filter(
  ({ score }) => score >= LOW_SCORE && score < HIGH_SCORE
);
console.log(average); // Массив объектов с именами Поли и Хьюстон
*/

/**
  |============================
  | Метод find()
  |============================
*/
/* 

Если метод filter(callback) используется для поиска всех элементов удовлетворяющим условию, то метод find(callback) позволяет найти и вернуть первый подходящий элемент,
после чего перебор массива прекращается. То есть он ищет до первого совпадения.

массив.find((element, index, array) => {
  // Тело коллбек-функции
});

Не изменяет оригинальный массив.
Поэлементно перебирает оригинальный массив.
Возвращает первый элемент удовлетворяющий условию, то есть когда коллбек возвращает true.
Если ни один элемент не подошёл, то есть для всех элементов коллбек вернул false, метод возвращает undefined.
Метод find() используется для одной задачи - поиска элемента по уникальному значению свойства. 
Например, поиск пользователя по почте, автомобиля по серийному номеру, книги по названию и т. п.

const colorPickerOptions = [
  { label: "red", color: "#F44336" },
  { label: "green", color: "#4CAF50" },
  { label: "blue", color: "#2196F3" },
  { label: "pink", color: "#E91E63" },
  { label: "indigo", color: "#3F51B5" },
];

colorPickerOptions.find(option => option.label === "blue"); // { label: 'blue', color: '#2196F3' }
colorPickerOptions.find(option => option.label === "pink"); // { label: 'pink', color: '#E91E63' }
colorPickerOptions.find(option => option.label === "white"); // undefined
*/

/**
  |============================
  | Метод findIndex()
  |============================
*/
/* 

Метод findIndex(callback) это современная замена методу indexOf(). Позволяет выполнять поиск по более сложным условиям чем просто равенство. 
Используется как для поиска в массиве примитивов, так и в массиве обьектов.

массив.findIndex((element, index, array) => {
  // Тело коллбек-функции
});

Не изменяет оригинальный массив.
Поэлементно перебирает оригинальный массив.
Возвращает индекс первого элемента удовлетворяющего условию, то есть когда коллбек возвращает true.
Если ни один элемент не подошёл, то есть для всех элементов коллбек вернул false, метод возвращает -1.
const colorPickerOptions = [
  { label: "red", color: "#F44336" },
  { label: "green", color: "#4CAF50" },
  { label: "blue", color: "#2196F3" },
  { label: "pink", color: "#E91E63" },
  { label: "indigo", color: "#3F51B5" },
];

colorPickerOptions.findIndex(option => option.label === "blue"); // 2
colorPickerOptions.findIndex(option => option.label === "pink"); // 3
colorPickerOptions.findIndex(option => option.label === "white"); // -1
*/

/**
  |============================
  | Методы every() и some()
  |============================
*/
/* 

Метод every()
Проверяет проходят ли все элементы массива тест предоставляемый коллбек-функцией. Возвращает true или false.

массив.every((element, index, array) => {
  // Тело коллбек-функции
});

Не изменяет оригинальный массив.
Поэлементно перебирает оригинальный массив.
Возвращает true если все элементы массива удовлетворяют условию.
Возвращает false если хотябы один элемент массив не удовлетворяет условию.
Перебор массива прекращается если коллбек возвращает false.
// Все элементы больше либо равны нулю? - да
[1, 2, 3, 4, 5].every(value => value >= 0); // true

// Все элементы больше либо равны нулю? - нет
[1, 2, 3, -10, 4, 5].every(value => value >= 0); // false



Метод some()
Проверяет проходит ли хотя бы один элемент массива тест предоставляемый коллбек-функцией. Возвращает true или false.

массив.some((element, index, array) => {
  // Тело коллбек-функции
});

Не изменяет оригинальный массив.
Поэлементно перебирает оригинальный массив.
Возвращает true если хотя бы один элемент массива удовлетворяет условию.
Возвращает false если ни один элемент массив не удовлетворяет условию.
Перебор массива прекращается если коллбек возвращает true.
// Есть хотя бы один элемент больше либо равный нулю? - да
[1, 2, 3, 4, 5].some(value => value >= 0); // true

// Есть хотя бы один элемент больше либо равный нулю? - да
[-7, -20, 3, -10, -14].some(value => value >= 0); // true

// Есть хотя бы один элемент меньше нуля? - нет
[1, 2, 3, 4, 5].some(value => value < 0); // false

// Есть хотя бы один элемент меньше нуля? - да
[1, 2, 3, -10, 4, 5].some(value => value < 0); // true




Массив объектов
При работе с массивом объектов проверяется значение какого-то их свойства 
Например, есть массив объектов фруктов, необходимо узнать все ли фрукты есть в наличии и есть ли в наличии хоть какие-то фрукты более 0 штук.

const fruits = [
  { name: "apples", amount: 100 },
  { name: "bananas", amount: 0 },
  { name: "grapes", amount: 50 },
];

// every вернет true только если всех фруктов будет больше чем 0 штук
const allAvailable = fruits.every(fruit => fruit.amount > 0); // false

// some вернет true если хотябы одного фрукта будет больше чем 0 штук
const anyAvailable = fruits.some(fruits => fruits.amount > 0); // true
*/

/**
  |============================
  | Метод reduce()
  |============================
*/
/* 
Метод reduce(callback, initialValue) используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата, как аккумулятор. 
Немного сложнее других в усвоении, но результат стоит того.

массив.reduce((previousValue, element, index, array) => {
  // Тело коллбек-функции
}, initialValue);

Не изменяет оригинальный массив.
Поэлементно перебирает оригинальный массив.
Возвращает что угодно.
Делает что угодно.
Легче всего представить его работу на примере подсчёта суммы элементов массива.

const total = [2, 7, 3, 14, 6].reduce((previousValue, number) => {
  return previousValue + number;
}, 0);

console.log(total); // 32

Первый параметр коллбек-функции (previousValue) это аккумулятор, то есть промежуточный результат. 
Значение которое вернёт коллбек-функция на текущей итерации, будет значением этого параметра на следующей.

Вторым аргументом для reduce() можно передать необязательное начальное значение аккумулятора - параметр initialValue.

# Вначале метод reduce() создаёт внутреннюю переменную-аккумулятор и присваивает ей значение параметра initialValue или первого элемента
перебираемого массива, если initialValue не задан.
previousValue = 0

# Далее коллбек-функция вызывается для каждого элемента массива. Текущее значение параметра previousValue это то, что вернула коллбек-функция на прошлой итерации.
Итерация 1 -> previousValue = 0 -> number = 2 -> return 0 + 2 -> return 2
Итерация 2 -> previousValue = 2 -> number = 7 -> return 2 + 7 -> return 9
Итерация 3 -> previousValue = 9 -> number = 3 -> return 9 + 3 -> return 12
Итерация 4 -> previousValue = 12 -> number = 14 -> return 12 + 14 -> return 26
Итерация 5 -> previousValue = 26 -> number = 6 -> return 26 + 6 -> return 32

# После того как весь массив перебран, метод reduce() возвращает значение аккумулятора.
Результат - 32

То есть метод reduce() используется когда необходимо взять «много» и привести к «одному». В повседневных задачах его применение сводится к работе с числами.




Массив объектов
При работе с массивом объектов выполняется редуцирование по значению какого-то свойства. Например, есть массив студентов с баллами за тест. 
Необходимо получить средний бал.

const students = [
  { name: "Манго", score: 83 },
  { name: "Поли", score: 59 },
  { name: "Аякс", score: 37 },
  { name: "Киви", score: 94 },
  { name: "Хьюстон", score: 64 },
];

// Название аккумулятора может быть произвольным, это просто параметр функции
const totalScore = students.reduce((total, student) => {
  return total + student.score;
}, 0);

const averageScore = totalScore / students.length;




Продвинутый reduce
Допустим у нас есть следующая задача: из массива постов твиттера отдельного пользователя необходимо посчитать сумму всех лайков. 
Можно перебрать циклом for или forEach, каждое из этих решений потребует дополнительного кода. А можно использовать reduce.

const tweets = [
  { id: "000", likes: 5, tags: ["js", "nodejs"] },
  { id: "001", likes: 2, tags: ["html", "css"] },
  { id: "002", likes: 17, tags: ["html", "js", "nodejs"] },
  { id: "003", likes: 8, tags: ["css", "react"] },
  { id: "004", likes: 0, tags: ["js", "nodejs", "react"] },
];

// Пройдем по всем элементам коллекции и прибавим значения свойства likes к аккумулятору, начальное значение которого укажем 0.

const likes = tweets.reduce((totalLikes, tweet) => totalLikes + tweet.likes, 0);

console.log(likes); // 32

// Наверное подсчет лайков не одиночная операция, поэтому напишем функцию для подсчета лайков из коллекции

const countLikes = tweets => {
  return tweets.reduce((totalLikes, tweet) => totalLikes + tweet.likes, 0);
};

console.log(countLikes(tweets)); // 32

Заметили свойство tags у каждого поста? Продолжая тему reduce, мы соберем в массив все теги, которые встречаются в постах.

const tweets = [
  { id: "000", likes: 5, tags: ["js", "nodejs"] },
  { id: "001", likes: 2, tags: ["html", "css"] },
  { id: "002", likes: 17, tags: ["html", "js", "nodejs"] },
  { id: "003", likes: 8, tags: ["css", "react"] },
  { id: "004", likes: 0, tags: ["js", "nodejs", "react"] },
];

// Пройдем по всем элементам коллекции и добавим значения свойства tags к аккумулятору, начальное значение которого укажем пустым массивом [].
// На каждой итерации пушим в аккумулятор все элементы tweet.tags и возвращаем его.

const tags = tweets.reduce((allTags, tweet) => {
  allTags.push(...tweet.tags);

  return allTags;
}, []);

console.log(tags);

// Наверное сбор тегов не одиночная операция, поэтому напишем функцию для сбора тегов из коллекции
const getTags = tweets =>
  tweets.reduce((allTags, tweet) => {
    allTags.push(...tweet.tags);

    return allTags;
  }, []);

console.log(getTags(tweets));


После того, как мы собрали все теги из постов, хорошо бы было посчитать количество уникальных тегов в массиве. И снова reduce тут как тут.

const tweets = [
  { id: "000", likes: 5, tags: ["js", "nodejs"] },
  { id: "001", likes: 2, tags: ["html", "css"] },
  { id: "002", likes: 17, tags: ["html", "js", "nodejs"] },
  { id: "003", likes: 8, tags: ["css", "react"] },
  { id: "004", likes: 0, tags: ["js", "nodejs", "react"] },
];

const getTags = tweets =>
  tweets.reduce((allTags, tweet) => {
    allTags.push(...tweet.tags);

    return allTags;
  }, []);

const tags = getTags(tweets);

// Вынесем callback-функцию отдельно, а в reducе передадим ссылку на нее. Это стандартная практика если callback-функция довольно большая.
// Если в объекте-аккумуляторе acc нету своего свойства с ключем tag, то создаем его и записывает ему значение 0. В противном случае увеличиваем значение на 1.

const getTagStats = (acc, tag) => {
  if (!acc.hasOwnProperty(tag)) {
    acc[tag] = 0;
  }

  acc[tag] += 1;

  return acc;
};

// Начальное значение аккумулятора это пустой объект {}

const countTags = tags => tags.reduce(getTagStats, {});

const tagCount = countTags(tags);
console.log(tagCount);
*/

/**
  |============================
  | Метод sort()
  |============================
*/
/* 
Метод sort() сортирует элементы массива, но в отличии от остальных перебирающих методов, он сортирует исходный массив.

Сортирует и изменяет исходный массив.
Возвращает изменённый массив, то есть ссылку на отсортированный исходный.
По умолчанию сортирует по возрастанию.
Сортировка происходит путём приведения значений к строке и сравнения порядковых номеров в таблице Unicode.
Такой массив чисел будет отсортирован по возврастанию.

const scores = [61, 19, 74, 35, 92, 56];
scores.sort();
console.log(scores); // [19, 35, 56, 61, 74, 92]

Но, так как по умолчанию значения приводятся к строке, стандартная сортировка чисел работает необычно. 
Поэтому в следующем упражнении мы рассмотрим как задавать свой порядок сортировки.

const scores = [27, 2, 41, 4, 7, 3, 75];
scores.sort();
console.log(scores); // [2, 27, 3, 4, 41, 7, 75]

Массив строк сортируется по алфавиту.

const students = ["Вика", "Андрей", "Олег", "Юля", "Борис", "Катя"];
students.sort();
console.log(students); // [ 'Андрей', 'Борис', 'Вика', 'Катя', 'Олег', 'Юля' ]

При этом порядковый номер заглавных букв меньше чем у прописных.

const letters = ["b", "B", "a", "A", "c", "C"];
letters.sort();
console.log(letters); // ['A', 'B', 'C', 'a', 'b', 'c']




Из-за того, что сортируется исходный массив, нарушается принцип чистоты функций и нельзя удобно сделать несколько производных коллекций на базе исходной. 
Например, сделать коллекцию отсортированную по возрастанию, а другую по убыванию. Поэтому перед сортировкой делают полную копию исходного массива и сортируют уже её.

const scores = [61, 19, 74, 35, 92, 56];
const ascendingScores = [...scores].sort();

console.log(scores); // [61, 19, 74, 35, 92, 56]
console.log(ascendingScores); // [19, 35, 56, 61, 74, 92]




Свой порядок сортировки чисел
Для указания своего порядка сортировки методу sort(compareFunction) нужно передать коллбек-функцию с двумя параметрами. 
Это функция сравнения (compare function), порядок сортировки зависит от её результата. Метод sort() будет вызывать её для произвольных двух элементов.

массив.sort((a, b) => {
  // Тело коллбек-функции
});

a - первый элемент для сравнения.
b - второй элемент для сравнения.
Если вызов compareFunction(a, b) возвращает любое отрицательное значение, то есть a меньше b, сортировка поставит a перед b. Это сортировка по возрастанию.

const scores = [61, 19, 74, 35, 92, 56];
const ascendingScores = [...scores].sort((a, b) => a - b);
console.log(ascendingScores); // [19, 35, 56, 61, 74, 92]

Если вызов compareFunction(a, b) возвращает любое положительное значение больше нуля, то есть b больше a, сортировка поставит b перед a. Это сортировка по убыванию.

const scores = [61, 19, 74, 35, 92, 56];
const descendingScores = [...scores].sort((a, b) => b - a);
console.log(descendingScores); // [92, 74, 61, 56, 35, 19]

Eсли вызов compareFunction(a, b) вернёт 0, сортировка оставит a и b неизменными по отношению друг к другу, но отсортирует их по отношению ко всем другим элементам. 
Но вообще не важно, что возвращать, если их взаимный порядок не имеет значения.




Свой порядок сортировки строк
Для сортировки строк в алфавитном порядке, по возрастанию или убыванию, используется метод строк localeCompare().

firstString.localeCompare(secondString)

Он вызывается на строке которую нужно сравнить (firstString) с той, что передана ему как аргумент (secondString).

"a".localeCompare("b"); // -1
"b".localeCompare("a"); // 1
"a".localeCompare("a"); // 0
"b".localeCompare("b"); // 0

Возвращает отрицательное значение если firstString должна быть перед secondString.
Возвращает положительное значение больше нуля если firstString должна быть после secondString.
Если строки одинаковы, возвращается ноль.
Это удобно использовать при сортировке строк, так как метод sort() ожидает такие же значения от коллбек-функции.

const students = ["Вика", "Андрей", "Олег", "Юля", "Борис", "Катя"];

const inAlphabetOrder = [...students].sort((a, b) => a.localeCompare(b));
console.log(inAlphabetOrder); // ['Андрей', 'Борис', 'Вика', 'Катя', 'Олег', 'Юля']

const inReversedOrder = [...students].sort((a, b) => b.localeCompare(a));
console.log(inReversedOrder); // ['Юля', 'Олег', 'Катя', 'Вика', 'Борис', 'Андрей']




Сортировка объектов
При работе с массивом объектов сортировка выполняется по числовому или строчному значению какого-то свойства. 
Например, есть группа студентов с баллами за тест. Необходимо отсортировать массив объектов по возрастанию и убыванию количества баллов, и по имени студента.

const students = [
  { name: "Манго", score: 83 },
  { name: "Поли", score: 59 },
  { name: "Аякс", score: 37 },
  { name: "Киви", score: 94 },
];

const inAscendingScoreOrder = students.sort(
  (firstStudent, secondStudent) => firstStudent.score - secondStudent.score
);

const inDescendingScoreOrder = students.sort(
  (firstStudent, secondStudent) => secondStudent.score - firstStudent.score
);

const inAlphabeticalOrder = students.sort((firstStudent, secondStudent) =>
  firstStudent.name.localeCompare(secondStudent.name)
);
*/

/**
  |============================
  | Цепочки методов
  |============================
*/
/* 
Есть массив объектов с именами, баллами и посещаемыми предметами каждого студента.

const students = [
  { name: "Манго", score: 83, courses: ["математика", "физика"] },
  { name: "Поли", score: 59, courses: ["информатика", "математика"] },
  { name: "Аякс", score: 37, courses: ["физика", "биология"] },
  { name: "Киви", score: 94, courses: ["литература", "информатика"] },
];

Необходимо получить массив их имён отсортированный по возрастанию баллов за тест. 
Для этого мы отсортируем копию массива методом sort(), после чего методом map() составим массив значений свойства name из сортированного массива.

const sortedByAscendingScore = [...students].sort((a, b) => a.score - b.score);
const names = sortedByAscendingScore.map(student => student.name);

console.log(names); // ['Аякс', 'Поли', 'Манго', 'Киви']

Проблема в том, что у нас появляются промежуточные переменные после каждой операции кроме финальной. 
Переменная sortedByAscendingScore лишняя и необходима только для хранения промежуточного результата.

Избавиться от таких «мёртвых» переменных можно группируя вызовы методов в цепочки. Каждый следующий метод будет выполняться на результате работы предыдущего.

const names = [...students]
  .sort((a, b) => a.score - b.score)
  .map(student => student.name);

console.log(names); // ['Аякс', 'Поли', 'Манго', 'Киви']

Делаем копию исходного массива перед сортировкой.
На копии вызываем метод sort().
К результату работы метода sort() применяем метод map().
Переменной names присваивается результат работы метода map().



Получим сортированный по алфавиту массив уникальных посещаемых предметов.

const uniqueSortedCourses = students
  .flatMap(student => student.courses)
  .filter((course, index, array) => array.indexOf(course) === index)
  .sort((a, b) => a.localeCompare(b));

console.log(uniqueSortedCourses); // ['биология', 'информатика', 'литература', 'математика', 'физика']

На исходном массиве вызываем flatMap() и делаем разглаженный массив всех курсов.
К результату метода flatMap() применяем метод filter() для фильтрации уникальных элементов.
На результате метода filter() вызываем sort().
Переменной uniqueSortedCourses присваивается результат работы метода sort().
Цепочка методов может быть произвольной длины, но обычно не более 2-3 операций. 
Во-первых, перебирающие методы используются для сравнительно простых операций над коллекцией. 
Во-вторых, вызов каждого последующего метода, это дополнительный перебор массива, что при достаточном количестве, может сказаться на производительности.


*/

/**
  |============================
  | Комментарии и инструкции к коду 
  |============================
*/
/* 
Перед кодом функции, метода прописываем /**
VS Code автоматически предложит расшифровать и прокомментировать параметры функций и методов
*/

/**
  |============================
  | Контекст выполнения функции
  |============================
*/
/* 
Можно с уверенностью сказать, что ключевое слово this это одна из самых запутанных концепций JavaScript на старте обучения. 
Новички часто подставляют this методом научного тыка до тех пор, пока скрипт не сработает.

Контекст в JavaScript похож на контекст в предложении:

Петя бежит быстро, потому что Петя пытается поймать поезд.
Петя бежит быстро, потому что он пытается поймать поезд.
Второе предложение звучит лаконичнее. Предметом предложения является Петя и мы можем сказать, что контекст предложения - это Петя, 
потому что он в центре внимания в это конкретное время в предложении. Даже местоимение «кто» относится к Пете.

И точно так же объект может быть текущим контекстом исполнения функции.

// Петя бежит быстро, потому что Петя пытается поймать поезд.
const petya = {
  username: "Petya",
  showName() {
    console.log(petya.username);
  },
};

petya.showName();

Обращение к свойствам объекта внутри методов, используя имя самого объекта, аналогично использованию Петя вместо он.

Внутри функций можно использовать зарезервированное ключевое слово this. Во время исполнения функции, в this записывается ссылка на объект, 
в контексте которого она была вызвана. Таким образом, в теле функции мы можем получить доступ к свойствам и методам этого объекта.

// Петя бежит быстро, потому что он (this) пытается поймать поезд.
const petya = {
  username: "Petya",
  showName() {
    console.log(this.username);
  },
};

petya.showName();

Разберем пример с коллекцией книг.

const bookShelf = {
  authors: ["Бернард Корнуэлл", "Роберт Шекли"],
  getAuthors() {
    return this.authors;
  },
  addAuthor(authorName) {
    this.authors.push(authorName);
  },
};

console.log(bookShelf.getAuthors()); // ["Бернард Корнуэлл", "Роберт Шекли"]
bookShelf.addAuthor("Ли Танит");
console.log(bookShelf.getAuthors()); // ["Бернард Корнуэлл", "Роберт Шекли", "Ли Танит"]

Методы getAuthors и addAuthor это функции (методы объекта), которые вызываются в контексте объекта bookShelf. 
Во время их выполнения в this записывается ссылка на объект bookShelf и мы можем обратиться к его свойствам и методам.
*/

/**
  |============================
  | Правила определения this
  |============================
*/
/* 
Необходимо усвоить всего одно правило для определения this - значение контекста внутри функции (не стрелочной) определятся не в момент ее создания, 
а в момент вызова. То есть значение this определяется тем, как вызывается функция, а не где она была объявлена.

this в глобальной области видимости
В глобальной области видимости, если скрипт выполняется не в строгом режиме, this ссылается на объект window. 
В строгом режиме значение this, в глобальной области видимости, будет undefined.

function foo() {
  console.log(this);
}

foo(); // window без "use strict" и undefined с "use strict"




this в методе объекта
Если функция была вызвана как метод объекта, то контекст будет ссылаться на объект, частью которого является метод.

const petya = {
  username: "Petya",
  showThis() {
    console.log(this);
  },
  showName() {
    console.log(this.username);
  },
};

petya.showThis(); // {username: "Petya", showThis: ƒ, showName: ƒ}
petya.showName(); // 'Petya'

Разберем более сложный пример для лучшего понимания.

Сначала создадим функцию в глобальной области видимости и вызовем ее.
После чего присвоим ее в свойство объекта и вызовем как метод этого объекта.

function showThis() {
  console.log("this in showThis: ", this);
}

// Вызываем в глобальном контексте
showThis(); // this in showThis: Window

const user = {
  username: "Mango",
};

// Записываем ссылку на функцию в свойство объекта
// Обратите внимание, что это не вызов - нет ()
user.showContext = showThis;

// Вызываем функцию в контексте объекта this будет указывать на текущий объект, в контексте которого осуществляется вызов, а не на глобальный объект.

user.showContext(); // this in showThis: {username: "Mango", showContext: ƒ}





this в callback-функциях
При передаче методов объекта как колбэк-функций, контекст не сохраняется. 
Колбэк это ссылка на метод, которая присваивается как значение параметра, вызываемого без объекта.

const customer = {
  firstName: "Jacob",
  lastName: "Mercer",
  getFullName() {
    return `${this.firstName} ${this.lastName}`;
  },
};

function makeMessage(callback) {
  // callback() это вызов метода getFullName без объекта
  console.log(`Обрабатываем заявку от ${callback()}.`);
}

makeMessage(customer.getFullName); // Будет ошибка при вызове функции

ИНТЕРЕСНО
Решение этой проблемы рассматривается в секции про метод bind() и методы объекта.





this в стрелочных функциях
Стрелочные функции не имеют своего this. В отличии от обычных функций, изменить значение this внутри стрелки после её объявления нельзя.

ИНТЕРЕСНО
Контекст внутри стрелки определяется местом её объявления, а не вызова и ссылается на контекст родительской функции.

Стрелочные функции также игнорируют наличие строгого режима. Если стрелка запомнила глобальный контекст, то this в ней будет содержать ссылку на 
window независимо от того, выполняется скрипт в строгом режиме или нет.

const showThis = () => {
  console.log("this in showThis: ", this);
};

showThis(); // this in showThis: window

const user = {
  username: "Mango",
};
user.showContext = showThis;

user.showContext(); // this in showThis: window

Ограничивая стрелочные функции постоянным контекстом, JavaScript-движки могут лучше их оптимизировать, в отличие от обычных функций, 
значение this которых может быть изменено.

Пример не практичный, но отлично показывает как работает контекст для стрелок. Значение контекста берется из родительской области видимости.

const hotel = {
  username: "Resort hotel",
  showThis() {
    const foo = () => {
      // Стрелки запоминают контекст во время объявления,
      // из родительской области видимости
      console.log("this in foo: ", this);
    };

    foo();
    console.log("this in showThis: ", this);
  },
};

hotel.showThis();
// this in foo: {username: 'Resort hotel', showThis: ƒ}
// this in showThis: {username: 'Resort hotel',showThis: ƒ}
*/

/**
  |============================
  | Методы функций
  |============================
*/
/* 
Бывают ситуации когда функцию нужно вызвать в контексте какого-то объекта, при этом функция не является его методом. 
Для этого у функций есть методы call, apply и bind.




Метод call()
foo.call(obj, arg1, arg2, ...)

Метод call вызовет функцию foo так, что в this будет ссылка на объект obj, а также передаст аргументы arg1, arg2 и т. д.

function greetGuest(greeting) {
  console.log(`${greeting}, ${this.username}.`);
}

const mango = {
  username: "Манго",
};
const poly = {
  username: "Поли",
};

greetGuest.call(mango, "Добро пожаловать"); // Добро пожаловать, Манго.
greetGuest.call(poly, "С приездом"); // С приездом, Поли.




Метод apply
Метод apply это аналог метода call за исключением того, что синтаксис передачи аргументов требует не перечисление, а массив, даже если аргумент всего один.

foo.call(obj, arg1, arg2, ...)

foo.apply(obj, [arg1, arg2, ...])

Метод apply вызовет функцию foo так, что в this будет ссылка на объект obj, а также передаст элементы массива как отдельные аргументы arg1, arg2 и т. д.

function greetGuest(greeting) {
  console.log(`${greeting}, ${this.username}.`);
}

const mango = {
  username: "Манго",
};
const poly = {
  username: "Поли",
};

greetGuest.apply(mango, ["Добро пожаловать"]); // Добро пожаловать, Манго.
greetGuest.apply(poly, ["С приездом"]); // С приездом, Поли.





Метод bind()
Методы call и apply вызывают функцию «на месте», то есть сразу. Но в случае колбэк-функций, когда необходимо не сразу вызвать функцию, 
а передать ссылку на неё, причём с привязанным контекстом, используется метод bind.

foo.bind(obj, arg1, arg2, ...)

Метод bind создаёт и возвращает копию функции foo с привязанным контекстом obj и аргументами arg1, arg2 и т. д. 
Получается копия функции которую можно передать куда угодно и вызвать когда угодно.

function greet(clientName) {
  return `${clientName}, добро пожаловать в «${this.service}».`;
}

const steam = {
  service: "Steam",
};
const steamGreeter = greet.bind(steam);
steamGreeter("Манго"); // "Манго, добро пожаловать в «Steam»."

const gmail = {
  service: "Gmail",
};
const gmailGreeter = greet.bind(gmail);
gmailGreeter("Поли"); // "Поли, добро пожаловать в «Gmail»."




bind() и методы объекта
При передаче методов объекта как колбэк-функций, контекст не сохраняется. Колбэк это ссылка на метод, которая присваивается как значение параметра,
вызываемого без объекта.

const customer = {
  firstName: "Jacob",
  lastName: "Mercer",
  getFullName() {
    return `${this.firstName} ${this.lastName}`;
  },
};

function makeMessage(callback) {
  // callback() это вызов метода getFullName без объекта
  console.log(`Обрабатываем заявку от ${callback()}.`);
}

makeMessage(customer.getFullName); // Будет ошибка при вызове функции

В строгом режиме, значение this в методе getFullName, при вызове как колбэк-функции callback(), будет undefined. 
При обращении к свойствам firstName и lastName будет ошибка, так как undefined это не объект.

Метод bind используется для привязки контекста при передаче методов объекта как колбэк-функций. 
Передадим колбэком не оригинальный метод getFullName, а его копию с привязанным контекстом к объекту customer.

// ❌ Было
makeMessage(customer.getFullName); // Будет ошибка при вызове функции

// ✅ Стало
makeMessage(customer.getFullName.bind(customer)); // Обрабатываем заявку от Jacob Mercer.
*/

/**
  |============================
  | Объектно-ориентированное программирование
  |============================
*/
/* 
Процедурное программирование - набор не связанных явно функций и переменных для хранения и обработки информации. Этот подход прост и прямолинеен 
и подходит для задач где нет тесно связанных сущностей (данных и функций для их обработки).

Рассмотрим пример процедурного кода где есть переменные и функция для подсчета результата.

const baseSalary = 30000;
const overtime = 10;
const rate = 20;

const getWage = (baseSalary, overtime, rate) => {
  return baseSalary + overtime * rate;
};

getWage(baseSalary, overtime, rate);



Объектно-ориентированное программирование (ООП) - методология, основанная на представлении программы в виде совокупности объектов, каждый из которых 
содержит данные (свойства) и методы для взаимодействия с ними.

Используем ООП, собрав данные в объект employee.

const employee = {
  baseSalary: 30000,
  overtime: 10,
  rate: 20,
  getWage() {
    return this.baseSalary + this.overtime * this.rate;
  },
};

employee.getWage();

При таком подходе у метода нет параметров, используются свойства объекта, которые задаются при создании объекта и, возможно, так же изменяются другими методами. 
На выходе получаем сущность с простым интерфейсом, что понижает сложность программы.

ИНТЕРЕСНО
Идеологически, ООП - это подход к программированию как к моделированию, решающий основную задачу - структурирование информации с точки зрения управляемости, 
что существенно улучшает контроль процесса моделирования.




Сущности ООП
Представьте себе, что мы проектируем автомобиль. У него будет двигатель, четыре колеса, бензобак и т. д. 
Автомобиль должен иметь возможность заводиться, набирать и сбавлять скорость. Мы знаем как взаимодействует двигатель и колёса, 
то есть согласно каким законам взаимодействуют разные части машины.



Класс
Мы описываем все запчасти из которых состоит автомобиль, то каким образом эти запчасти взаимодействуют между собой и что должен сделать водитель, 
чтобы машина затормозила, включились фары и другое. Результатом нашей работы будет некоторый эскиз (шаблон, схема). Мы только что разработали то, что в 
ООП называется класс.


Класс - способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт).

В нашем случае, класс описывает сущность – автомобиль. Свойствами класса будут двигатель, колеса, фары и т. д. 
Методами класса будут открыть дверь, завести двигатель, увеличить скорость и т. п.



Экземпляр
Мы спроектировали чертежи и машины, разработанные по ним, сходят с конвейера. Каждая из них точно повторяет чертеж, все системы взаимодействуют именно так, 
как мы спроектировали, но каждая машина уникальна. Они все имеют номер кузова и двигателя, но все номера разные, автомобили различаются цветом, 
отделкой салона. Эти автомобили являются экземплярами класса.

Экземпляр (объект) - это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом. 
Это то, что создано по чертежу, то есть по описанию из класса.

Говоря простым языком, объект имеет конкретные значения свойств и методы, работающие с этими свойствами на основе правил, заданных в классе. 
В данном примере, если класс - это некоторый абстрактный автомобиль на чертеже, то объект - это конкретный автомобиль, стоящий у нас под окнами.




Интерфейс
Когда мы подходим к автомату с кофе или садимся за руль автомобиля, существует некоторый набор элементов управления, с которыми мы можем взаимодействовать.

Интерфейс - это набор свойств и методов класса, доступных для использования при работе с экземпляром.
По сути, интерфейс описывает класс, чётко определяя все возможные действия над ним. Хороший пример интерфейса - приборная панель автомобиля, 
которая позволяет вызвать такие методы как увеличение скорости, торможение, поворот, переключение передач, включение фар и т. п.

При описании интерфейса класса очень важно соблюсти баланс между гибкостью и простотой. Класс с простым интерфейсом будет легко использовать, 
но будут существовать задачи, которые с помощью него решить будет не под силу.

Если интерфейс будет гибким, то скорее всего, он будет состоять из достаточно сложных методов с большим количеством параметров, 
которые будут позволять делать очень многое, но его использование будет сопряжено с большими сложностями и риском совершить ошибку, что-то перепутав.
*/

/**
  |============================
  | Прототипное наследование
  |============================
*/
/* 
Прототипное наследование
ООП в JavaScript построено на прототипном наследовании. Объекты можно организовать в цепочки так, чтобы свойство не найденное в одном объекте, 
автоматически искалось бы в другом. Связующим звеном выступает специальное скрытое свойство [[Prototype]], которое в консоли браузера отображается как __proto__.



Прототип объекта



Метод Object.create(obj) создаёт и возвращает новый объект, связывая его с объектом obj.

const animal = {
  legs: 4,
};
const dog = Object.create(animal);
dog.name = "Манго";

console.log(dog); // { name: 'Манго', __proto__: animal }
console.log(animal.isPrototypeOf(dog)); // true

Объект, на который указывает ссылка в __proto__, называется прототипом. В нашем примере объект animal это прототип для объекта dog. 
Метод isPrototypeOf() проверяет является ли объект animal прототипом для dog и возвращает true или false.

console.log(dog.hasOwnProperty("name")); // true
console.log(dog.name); // 'Манго'

console.log(dog.hasOwnProperty("legs")); // false
console.log(dog.legs); // 4

Обращение dog.name работает очевидным образом - возвращает собственное свойство name объекта dog. 
При обращении к dog.legs интерпретатор ищет свойство legs в объекте dog, не находит и продолжает поиск в объекте по ссылке из dog.__proto__, 
то есть, в данном случае, в объекте animal - его прототипе.

То есть прототип - это резервное хранилище свойств и методов объекта, автоматически используемое при их поиске. 
У объекта, который выступает прототипом может также быть свой прототип, у того свой, и так далее.

Поиск свойства выполняется до первого совпадения. Интерпретатор ищет свойство по имени в объекте, если не находит, то обращается к свойству __proto__, 
т. е. переходит по ссылке к объекту-прототипу, а затем и прототипу прототипа. Если интерпретатор доберется до конца цепочки и не найдет свойства с таким именем, 
то вернёт undefined.

ИНТЕРЕСНО
В спецификации свойство __proto__ обозначено как [[Prototype]]. Двойные квадратные скобки здесь важны, они указывают на то, что это внутреннее, служебное свойство.



Метод hasOwnProperty()
После того как мы узнали о том, как происходит поиск свойств объекта, должно стать понятно, почему цикл for...in не делает различия между свойствами объекта 
и его прототипа.

const animal = { eats: true };
const dog = Object.create(animal);
dog.barks = true;

for (const key in dog) {
  console.log(key); // barks, eats
}

Именно поэтому мы используем метод obj.hasOwnProperty(prop), который возвращает true, если свойство prop принадлежит самому объекту obj, а не его прототипу, 
иначе false.

const animal = {
  eats: true,
};
const dog = Object.create(animal);
dog.barks = true;

for (const key in dog) {
  if (!dog.hasOwnProperty(key)) continue;

  console.log(key); // barks
}




Метод Object.keys(obj) вернет массив только собственных ключей объекта obj, поэтому на практике используют именно его, а не for...in.

const animal = {
  eats: true,
};
const dog = Object.create(animal);
dog.barks = true;

const dogKeys = Object.keys(dog);

console.log(dogKeys); // ['barks']
*/

/**
  |============================
  | Классы
  |============================
*/
/* 
Синтаксис литерала объекта позволяет создать один объект. Но часто нужно создать много однотипных объектов с одинаковым набором свойств, 
но разными значениями и методами для взаимодействия с ними. Всё это нужно сделать динамичекски, во время выполнения программы. 
Для этого используют классы - специальный синтаксис объявления функции для создания объектов.





Объявление класса
Объявление класса начинается с ключевого слова class, после которого идёт имя класса и фигурные скобки - его тело. 
Классы принято называть с большой буквы, а в самом названии отражать тип создаваемого объекта (существительное).

class User {
  // Тело класса
}

const mango = new User();
console.log(mango); // {}

const poly = new User();
console.log(poly); // {}

Результат вызова new User() это объект, который называется экземпляр класса, потому что содержит данные и поведение, описываемые классом.

ИНТЕРЕСНО
Как строить класс, зависит от того, что вам нужно. В нашем случае, класс представляет собой пользователя, поэтому мы добавим туда поля для имени и почты.





Конструктор класса
Для инициализации экземпляра в классе есть метод constructor. Если он не объявлен, создаётся конструктор по умолчанию - пустая функция, которая не изменяет экземпляр.

class User {
  // Синтаксис объявления метода класса
  constructor(name, email) {
    // Инициализация свойств экземпляра
    this.name = name;
    this.email = email;
  }
}

const mango = new User("Манго", "mango@mail.com");
console.log(mango); // { name: 'Манго', email: 'mango@mail.com' }

const poly = new User("Поли", "poly@mail.com");
console.log(poly); // { name: 'Поли', email: 'poly@mail.com' }

Вызов класса с оператором new приводит к созданию нового объекта и вызову конструктора в контексте этого объекта. 
То есть this внутри конструктора будет ссылаться на новосозданный объект. Это позволяет добавлять каждому объекту свойства с одинаковыми именами, но разными значениями.

Свойства name и email называются публичные свойства, потому что они будут собственными свойствами объекта-экземпляра и к ним можно будет получить доступ 
обратившись через точку.





Объект параметров
Класс может принимать большое количество входных данных для свойств будущего объекта. 
Поэтому к ним также можно применить паттерн «Объект параметров, передавая один объект с логично именованными свойствами, вместо несвязанного набора аргументов.

class User {
  // Деструктуризируем объект
  constructor({ name, email }) {
    this.name = name;
    this.email = email;
  }
}

const mango = new User({
  name: "Манго",
  email: "mango@mail.com",
});
console.log(mango); // { name: "Манго", email: "mango@mail.com" }

const poly = new User({
  name: "Поли",
  email: "poly@mail.com",
});
console.log(poly); // { name: "Поли", email: "poly@mail.com" }






Методы класса
Для работы со свойствами будущего экземпляра используются методы класса - функции которые будут доступны экземпляру в его прототипе.

class User {
  constructor({ name, email }) {
    this.name = name;
    this.email = email;
  }

  // Метод getEmail
  getEmail() {
    return this.email;
  }

  // Метод changeEmail
  changeEmail(newEmail) {
    this.email = newEmail;
  }
}





Приватные свойства
Инкапсуляция - это концепция позволяющая скрыть внутренние детали класса. 
Пользователь класса должен получать доступ только к публичному интерфейсу - набору публичных свойств и методов класса.

В классах инкапсуляция реализуется приватными свойствами, доступ к которым можно получить только внутри класса.

Допустим, почта пользователя должна быть недоступна для прямого изменения из вне, то есть приватна. 
Добавляя к имени свойства символ # мы делаем его приватным. Объявление приватного свойства до инициализации в конструкторе - обязательно.

class User {
  // Необязательное объявление публичных свойств
  name;
  // Обязательное объявление приватных свойств
  #email;

  constructor({ name, email }) {
    this.name = name;
    this.#email = email;
  }

  getEmail() {
    return this.#email;
  }

  changeEmail(newEmail) {
    this.#email = newEmail;
  }
}

const mango = new User({
  name: "Манго",
  email: "mango@mail.com",
});
mango.changeEmail("mango@supermail.com");
console.log(mango.getEmail()); // mango@supermail.com
console.log(mango.#email); // Будет ошибка, это приватное свойство

Методы класса также могут быть приватными, то есть доступны только в теле класса. Для этого перед их именем необходимо поставить символ #.






Геттеры и сеттеры
Геттеры и сеттеры - это более краткий синтаксис объявления методов для взаимодействия со свойствами. 
Геттер и сеттер имитируют обычное публичное свойство класса, но позволяют изменять другие свойства более удобным способом. 
Геттер выполняется при попытке получить значение свойства, а сеттер - при попытке его изменить.

Геттеры и сеттеры хорошо использовать для простых операций чтения и изменения значения свойств, особенно приватных, как их публичный интерфейс. 
Для работы со свойством которое хранит массив или объект они не подойдут.

class User {
  #email;

  constructor({ name, email }) {
    this.name = name;
    this.#email = email;
  }

  // Геттер email
  get email() {
    return this.#email;
  }

  // Сеттер email
  set email(newEmail) {
    this.#email = newEmail;
  }
}

Мы объявили геттер и сеттер email поставив перед именем свойства ключевые слова get и set. 
Внутри этих методов мы или возвращаем значение приватного свойства #email или изменяем его значение. Геттер и сеттер идут впаре и должны называться одинаково.

const mango = new User({ name: "Манго", email: "mango@mail.com" });
console.log(mango.email); // mango@mail.com
mango.email = "mango@supermail.com";
console.log(mango.email); // mango@supermail.com

При обращении к mango.email вызызвается геттер get email() {...} и выполняется его код. 
ри попытке записи mango.email = "mango@supermail.com" вызывается сеттер set email(newEmail) {...} и строка "mango@supermail.com" будет значением параметра newEmail.

Плюс в том, что это методы, а значит при записи можно выполнить дополнительный код, например с какими-то проверками, 
в отличии от выполнениях этой же операции напрямую со свойством.

set email(newEmail) {
  if(newEmail === "") {
    console.error("Ошибка! Почта не может быть пустой строкой!");
    return;
  }

  this.#email = newEmail;
}





Статические свойства
Кроме публичных и приватных свойств будущего экземпляра, в классе можно объявить его собственные свойства, доступные только классу, 
но не его экземплярам - статические свойства (static). Они полезны для хранения информации относящейся к самому классу.

Добавим классу пользователя приватное свойство role - его роль, определяющую набор прав, например администратор, редактор, просто пользователь и т п. 
Возможные роли пользователей будем хранить как статическое свойство Roles - объект со свойствами.

Статические свойства объявляются в теле класса. Перед именем свойства добавляется ключевое слово static.

class User {
  // Объявление и инициализация статического свойства
  static Roles = {
    ADMIN: "admin",
    EDITOR: "editor",
  };

  #email;
  #role;

  constructor({ email, role }) {
    this.#email = email;
    this.#role = role;
  }

  get role() {
    return this.#role;
  }

  set role(newRole) {
    this.#role = newRole;
  }
}

const mango = new User({
  email: "mango@mail.com",
  role: User.Roles.ADMIN,
});

console.log(mango.Roles); // undefined
console.log(User.Roles); // { ADMIN: "admin", EDITOR: "editor" }

console.log(mango.role); // "admin"
mango.role = User.Roles.EDITOR;
console.log(mango.role); // "editor"

Статические свойства также могут быть приватные, то есть доступные только внутри класса. 
Для этого имя свойства должно начинаться с символа #, также как приватные свойства. 
Обращение к приватному статическому свойству вне тела класса вызовет ошибку.





Статические методы
В классе можно объявить не только методы будущего экземпляра, но и методы доступные только классу - статические методы, которые могут быть как публичные так и приватные. 
Синтаксис объявления аналогичен статическим свойствам, за исключением того что значением будет метод.

class User {
  static #takenEmails = [];

  static isEmailTaken(email) {
    return User.#takenEmails.includes(email);
  }

  #email;

  constructor({ email }) {
    this.#email = email;
    User.#takenEmails.push(email);
  }
}

const mango = new User({ email: "mango@mail.com" });

console.log(User.isEmailTaken("poly@mail.com"));
console.log(User.isEmailTaken("mango@mail.com"));

Особенность статических методов в том, что во время их вызова ключевое слово this ссылается на сам класс. 
Это значит что статический метод может получить доступ к статическим свойствам класса, но не к свойствам экземпляра. 
Логично, потому что статические методы вызывает сам класс, а не его экземпляры.





Наследование классов
Ключевое слово extends позволяет реализовать наследование классов, когда один класс (дочерний, производный) наследует свойства и методы другого класса (родителя).

class Child extends Parent {
  // ...
}

В выражении class Child extends Parent дочерний класс Child наследует (расширяет) от родительского класса Parent.

Это означает, что мы можем объявить базовый класс, который хранит общие характеристики и методы для группы производных классов, 
которые наследуют свойства и методы родителя, но также добавляют свои уникальные.

Например, в приложении есть пользователи разных ролей - администратор, писатель статей, контент менеджер и т. п. 
У каждого типа пользователя есть набор общих характеристик, например почта и пароль, но также есть и уникальные.

Сделав независимые классы для каждого типа пользователя мы получим дублирование общих свойств и методов, и при необходимости изменить например 
название свойства, придётся проходить по всем классам, это неудобно и трудозатратно.

Вместо этого можно сделать общий класс User, который будет хранить набор общих свойств и методов, после чего сделать классы для каждого типа пользователя 
которые наследуют этот набор от класса User. При необходимости изменить что-то общее, достаточно будет поменять только код класса User.

class User {
  #email;

  constructor(email) {
    this.#email = email;
  }

  get email() {
    return this.#email;
  }

  set email(newEmail) {
    this.#email = newEmail;
  }
}

class ContentEditor extends User {
  // Тело класса ContentEditor
}

const editor = new ContentEditor("mango@mail.com");
console.log(editor); // { email: "mango@mail.com" }
console.log(editor.email); // "mango@mail.com"

Класс ContentEditor наследует от класса User его конструктор, геттер и сеттер email, а также одноимённое публичное свойство. 
Важно помнить что приватные свойства и методы класса-родителя не наследуются классом-ребёнком.





Конструктор дочернего класса
Первым делом в конструкторе дочернего класса необходимо вызвать специальную функцию super(аргументы) - это псевдоним конструктора родительского класса. 
В противном случае, при попытке обратиться к this в конструкторе дочернего класса, будет ошибка. 
При вызове конструктора класса родителя передаём необходимые ему аргументы для инициализации свойств.

class User {
  #email;

  constructor(email) {
    this.#email = email;
  }

  get email() {
    return this.#email;
  }

  set email(newEmail) {
    this.#email = newEmail;
  }
}

class ContentEditor extends User {
  constructor({ email, posts }) {
    // Вызов конструктора родительского класса User
    super(email);
    this.posts = posts;
  }
}

const editor = new ContentEditor({ email: "mango@mail.com", posts: [] });
console.log(editor); // { email: 'mango@mail.com', posts: [] }
console.log(editor.email); // 'mango@mail.com'





Методы дочернего класса
В дочернем классе можно объявлять методы которые будут доступны только его экземплярам.

// Представим что выше есть объявление класса User

class ContentEditor extends User {
  constructor({ email, posts }) {
    super(email);
    this.posts = posts;
  }

  addPost(post) {
    this.posts.push(post);
  }
}

const editor = new ContentEditor({ email: "mango@mail.com", posts: [] });
console.log(editor); // { email: 'mango@mail.com', posts: [] }
console.log(editor.email); // 'mango@mail.com'
editor.addPost("post-1");
console.log(editor.posts); // ['post-1']
*/

/**
  |============================
  | Копирование объектов
  |============================
*/

/* 
При копровании объектов есть определенные сложности. Дело в том что многие доступные методы копирования подрзумевают только коирование первого уровня свойств 
(ключей) объекта.
Вложенные функции и объекты являются самостятельными узами, на них распространяется правила "копирования по ссылке, а не по значению".
Соответственно в новом объекте они не будут скопированны, а на них просто будут созданы ссылки.

Варианты копирования первого уровня вложенности:

const admin = JSON.parse(JSON.stringify(user)) // копирование объекта user в admin
const admin = Object.({}, user) // копирование объекта user в admin
const admin = {...user} // копирование объекта user в admin



Вариант полного копирования объекта с полноценным копированием всех вложенных функций и объектов - глубокое копирование с помощью рекурсии (рекурсия объекта)

const deepClone = obj => {
  if (obj === null) return null;
  // Создаем поверхностный клона оригинала.
  let clone = Object.assign({}, obj);

  // Определяем, какие пары ключ-значение
  // необходимо глубоко клонировать.
  Object.keys(clone).forEach(
    key =>
      (clone[key] =
        typeof obj[key] === "object" ? deepClone(obj[key]) : obj[key])
  );

  // Проверяем является ли obj массивом и не пустой ли он.
  return Array.isArray(obj) && obj.length
    // Если obj массив и он не пуст, тогда
    // указываем объекту clone длину исходного массива что бы
    // конвертировать clone в массив и вернуть его.
    ? (clone.length = obj.length) && Array.from(clone)
    // Если obj пустой массив,
    : Array.isArray(obj)
    // то возвращаем его
    ? Array.from(obj)
    // в других случаях obj это объект и мы возвращаем копию clone.
    : clone;
};

// Пример:

const a = { foo: "bar", obj: { a: 1, b: 2 } };
const b = deepClone(a);
// a !== b true
// a.obj !== b.obj true


*/

/**
  |============================
  | Объектная модель документа
  |============================
*/
/* 
Когда мы работаем с браузером, доступный функционал состоит из нескольких модулей, так как JavaScript сам по себе не имеет инструментов для работы с браузером.

Объектная модель документа (Document Object Model) - независимый от языка интерфейс для работы с HTML-документом. 
Содержит набор свойств и методов позволяющих искать, создавать и удалять элементы, реагировать на действия пользователя и многое другое. 
То есть соединяет страницу с языком программирования.

DOM это отражение HTML-документа - древовидная структура, в которой каждый узел это JavaScript-объект со свойствами и методами, 
представляющий часть HTML-документа. Каждый элемент в документе, весь документ в целом, заголовок, ссылка, абзац - это части DOM этого документа, 
поэтому все они могут быть изменены из JavaScript-кода.

Объектная модель браузера (Browser Object Model) - независимый от языка интерфейс для работы с вкладкой браузера. 
Содержит набор свойств и методов, позволяющих получить доступ непосредственно к текущей вкладке и ряду функций браузера. 
Включает объект работы с историей навигации, местоположением и многое другое.



HTML-документ и DOM
Согласно DOM-модели, каждый тег образует отдельный элемент-узел, каждый фрагмент текста - текстовый элемент. 
HTML-документ это иерархическое дерево, в котором у каждого элемента (кроме корневого) есть только один родитель, т. е. элемент, 
внутри которого он располагается. Это дерево образуется за счет вложенной структуры тегов и текстовых элементов.

Чтобы отобразить HTML-документ, браузер сначала преобразовывает его в формат, который он понимает - DOM. 
У движка браузера есть специальный фрагмент кода - HTML-парсер, который используется для преобразования HTML в DOM.

В HTML вложенность определяет отношения родитель-ребенок между элементами. В DOM объекты связаны в древовидной структуре данных, фиксируя эти отношения.
Браузер строит DOM постепенно, как только приходят первые фрагменты кода, он начинает парсить HTML, добавляя узлы в древовидную структуру.

После того как DOM-дерево построено, в нем можно найти элемент с помощью JavaScript и выполнять с ним какие-то действия, так как каждый элемент 
имеет интерфейс с множеством свойств и методов.



DOM-дерево
Визуализируем дерево HTML-документа используя сервис генератора DOM-дерева.

<!DOCTYPE html>
<html>
  <head>
    <title>Document title</title>
  </head>
  <body>
    <h1>Page title</h1>
    <ul>
      <li><a href="#">Link 1</a></li>
      <li><a href="#">Link 2</a></li>
    </ul>
  </body>
</html>

DOCTYPE: html
HTML
-HEAD
--#text:
--TITLE
---#text: Document title
--#text:
-#text:
BODY
-#text:
-H1
--#text: Page title
-#text:
-UL
--#text:
--LI
---A href="#"
----#text: Link 1
--#text:
--LI
---A href="#"
----#text: Link 2
--#text:
-#text:

В этом дереве два типа узлов.

Узлы-элементы (element node) - образуются тегами, естественным образом одни элементы вложены в другие. 
Структура дерева образована исключительно за счет них.

Текстовые узлы (text node) - образуются текстом внутри элементов. Текстовый узел содержит только строку текста и не может иметь потомков, 
то есть он всегда на самом нижнем уровне иерархии. Пробелы и переносы строк - это тоже текстовые узлы.

ИНТЕРЕСНО
Из этого правила есть исключения: пробелы до head игнорируются, а любое содержимое после body не создаёт элемент, браузер переносит его в конец body.
*/

/**
  |============================
  | Навигация по DOM
  |============================
*/
/* 
DOM предоставляет широкий спектр возможностей при работе с элементом и его содержимым, но для этого на него сначала нужно получить ссылку. 
Доступ к DOM начинается с объекта document, от него можно добраться до любых элементов.

ИНТЕРЕСНО
document это часть глобального объекта window, который доступен в скрипте, когда он выполняется в браузере. Также как alert, console.log, prompt и многие другие.

Элементы DOM-дерева имеют иерархическое отношение друг к другу. Для описания отношений используются термины предок (ancestor), потомок (descendant), 
родитель (parent), ребенок (child) и сосед (sibling).

Самый верхний элемент называется корневым (root node).
Каждый элемент, кроме корневого, имеет только одного родителя.
У элемента может быть сколько угодно детей.
Соседи - это элементы с общим родителем.
Дочерние элементы (дети) - элементы, которые лежат непосредственно внутри текущего (первая вложенность).
Потомки – все элементы, которые лежат внутри текущего, вместе с их детьми, детьми их детей и так далее. То есть всё поддерево.

Для навигации по этой иерархии у элементов есть следующие свойства.

elem.parentNode - выберет родителя elem.
elem.childNodes - псевдомассив, хранит все дочерние элементы, ВКЛЮЧАЯ ТЕКСТОВЫЕ.
elem.children - псевдомассив, хранит только дочерние узлы-элементы, то есть соответствующие тегам, БЕЗ УЧЕТА ТЕКСТОВЫХ ЭЛЕМЕНТОВ
elem.firstChild - выберет первый дочерний элемент внутри elem, ВКЛЮЧАЯ ТЕКСТОВЫЕ узлы.
elem.firstElementChild - выберет первый дочерний узел-элемент внутри elem БЕЗ УЧЕТА ТЕКСТОВЫХ ЭЛЕМЕНТОВ.
elem.lastChild - выберет последний дочерний элемент внутри elem, ВКЛЮЧАЯ ТЕКСТОВЫЕ узлы.
elem.lastElementChild - выберет последний дочерний узел-элемент внутри elem БЕЗ УЧЕТА ТЕКСТОВЫХ ЭЛЕМЕНТОВ.
elem.previousSibling - выберет элемент «слева» от elem (его предыдущего соседа) ВКЛЮЧАЯ ТЕКСТОВЫЕ узлы.
elem.previousElementSibling - выберет узел-элемент «слева» от elem (его предыдущего соседа) БЕЗ УЧЕТА ТЕКСТОВЫХ ЭЛЕМЕНТОВ..
elem.nextSibling - выберет элемент «справа» от elem (его следующего соседа) ВКЛЮЧАЯ ТЕКСТОВЫЕ узлы
elem.nextElementSibling - выберет узел-элемент «справа» от elem (его следующего соседа) БЕЗ УЧЕТА ТЕКСТОВЫХ ЭЛЕМЕНТОВ..

ИНТЕРЕСНО
DOM-коллекции, такие как childNodes и children - псевдомассивы (NodeList), у них нет большинства методов массива.
*/

/**
  |============================
  | Поиск элементов
  |============================
*/
/* 
Итак, мы уже знаем что DOM-элемент - это объект со свойствами и методами. 
Самое время научиться быстро находить элемент по произвольному CSS-селектору. 

Группа методов elem.querySelector* это современный стандарт для поиска элементов. Они позволяют найти элемент или группу элементов по CSS-селектору любой сложности.

element.querySelector(selector);

Используется если необходимо найти только один, чаще всего уникальный элемент.

Возвращает ПЕРВЫЙ найденный элемент внутри element, соответствующий CSS-селектору selector.
Если ничего не найдено, вернет null.
element.querySelectorAll(selector);

Используется если необходимо найти коллекцию элементов, то есть получить массив ссылок на элементы с одинаковым селектором. 
Например, все элементы списка с классом menu-item.

Возвращает псевдомассив всех элементов внутри element, удовлетворяющих CSS-селектору selector.
Если ничего не найдено, вернет пустой массив.
*/

/**
  |============================
  | Свойства и атрибуты
  |============================
*/
/* 
Во время построения DOM-дерева, некоторые стандартные HTML-атрибуты становятся свойствами элементов. Посмотрим на несколько часто использующихся свойств.

value - содержит текущий текстовый контент элементов форм.
checked - хранит состояние чекбокса или радиокнопки.
name - хранит значение, указанное в HTML-атрибуте name.
src - путь к изображению тега <img>.




Свойство textContent
elem.textContent возвращает текстовый контент внутри элемента. 
Доступно для чтения и записи. Не зависимо что будет передано в textContent, данные всегда будут записаны как текст.




Свойство classList
В свойстве classList хранится объект с методами для работы с классами элемента.

elem.classList.contains("cls") - возвращает true или false в зависимости от того, есть ли у элемента класс cls.
elem.classList.add("cls") - добавляет класс cls в список классов элемента.
elem.classList.remove("cls") - удаляет класс cls из списка классов элемента.
elem.classList.toggle("cls") - если класса cls нет, то добавляет его, если есть, наоборот удаляет.
elem.classList.replace("oldClass", "newClass") - заменяет существующий класс oldClass на указанный newClass.




Свойство style
Используется для чтения и изменения инлайновых стилей. Возвращает объект CSSStyleDeclaration, который содержит список всех свойств, определенных только 
во встроенных стилях элемента, а не весь CSS. При записи свойства записываются в camelCase, то есть background-color превращается в element.style.backgroundColor и т. д.

const button = document.querySelector(".btn");

button.style.backgroundColor = "teal";
button.style.fontSize = "24px";
button.style.textAlign = "center";

console.log(button.style); // inline styles object

ИНТЕРЕСНО
На практике стилизация элементов выполняется добавленим CSS-классов. 
Свойство style используется для добавления каких-то динамических стилей, например во время анимации.





Атрибуты
DOM-элементам соответствуют HTML-теги у которых есть текстовые атрибуты. 
Доступ к атрибутам осуществляется при помощи стандартных методов. Эти методы работают со значением, которое находится в HTML.

elem.hasAttribute(name) - проверяет наличие аттрибута, возвращает true или false.
elem.getAttribute(name) - получает значение атрибута и возвращает его.
elem.setAttribute(name, value) - устанавливает атрибут.
elem.removeAttribute(name) - удаляет атрибут.
elem.attributes - свойство, возвращает объект всех атрибутов элемента.




data-атрибуты
Позволяют добавить тегу произвольный атрибут и получить его значение в JavaScript. 
Эту возможность используют для того, чтобы упростить написание кода, например связать данные и разметку по уникальному идентификатору, 
указать тип действия кнопки и т. п.

<button type="button" data-action="save">Save</button>
<button type="button" data-action="close">Close</button>

Для получения значения data-атрибута используется свойство dataset, после которого идет имя атрибута. То есть data- отбрасывается, 
а остальное имя записывается как имя свойства объекта.

const saveBtn = document.querySelector('button[data-action="save"]');
console.log(saveBtn.dataset.action); // "save"

const closeBtn = document.querySelector('button[data-action="close"]');
console.log(closeBtn.dataset.action); // "close"

*/

/**
  |============================
  | Создание и удаление элементов
  |============================
*/
/* 
DOM API позволяет не только выбирать или изменять уже существующие, но и удалять, а так же создавать новые элементы, после чего добавлять их в документ.

Создание
document.createElement(tagName);

Создает элемент с именем tagName и возвращает ссылку на него как результат своего выполнения. 
tagName - это строка, указывающая тип создаваемого элемента. Элемент создается в памяти, в DOM его еще нет.

const heading = document.createElement("h1");
console.log(heading); // <h1></h1>

heading.textContent = "This is a heading";
console.log(heading); // <h1>This is a heading</h1>

const image = document.createElement("img");
image.src = "https://placeimg.com/640/480/nature";
image.alt = "Nature";
console.log(image); // <img src="https://placeimg.com/640/480/nature" alt="Nature" />






Добавление
Чтобы созданный элемент был отображен на странице, его необходимо добавить к уже существующему элементу в DOM-дереве. 
Допустим, что добавляем в некий элемент element, для этого есть методы.

element.append(el1, el2, ...) - добавляет один или несколько элементов после всех детей элемента element.
element.prepend(el1, el2, ...) - добавляет один или несколько элементов перед всеми детьми элемента element.
element.after(el1, el2, ...) - добавляет один или несколько элементов после элемента element.
element.before(el1, el2, ...) - добавляет один или несколько элементов перед элементом element.
Во всех этих методах, el это элементы или строки, в любом сочетании и количестве. Строки добавляются как текстовые узлы.

ИНТЕРЕСНО
Если элемент для вставки уже находится в DOM, то он изымается из своего старого места и добавляется в новое. 
Отсюда вытекает правило - один и тот же элемент не может быть одновременно в двух местах.

const list = document.querySelector(".usernames");

// Adds an item to the end of the list
const lastItem = document.createElement("li");
lastItem.textContent = "Poly";
list.append(lastItem);

// Adds an item to the beginning of the list
const firstItem = document.createElement("li");
firstItem.textContent = "Ajax";
list.prepend(firstItem);

// Adds a title before the list
const title = document.createElement("h2");
title.textContent = "USERNAMES";
list.before(title);

// Adds a paragraph after the list
const text = document.createElement("p");
text.textContent =
  "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Nostrum tenetur assumenda fugiat maxime, soluta aspernatur quasi nihil in asperiores ad distinctio illo et debitis error iure voluptate numquam maiores nisi. Lorem ipsum dolor sit amet, consectetur adipisicing elit. Nostrum tenetur assumenda fugiat maxime, soluta aspernatur quasi nihil in asperiores ad distinctio illo et debitis error iure voluptate numquam maiores nisi!";
list.after(text);




Удаление
elem.remove();

Для того, чтобы удалить элемент используется метод remove(). Он вызывается на самом элементе elem, который необходимо удалить
const text = document.querySelector('.text');
text.remove();




Оптимизация работы с DOM
Современные браузеры стараются оптимизировать процесс отрисовки страницы без вмешательства разработчика. 
Тем не менее, изменение DOM-дерева это дорогая операция, поэтому необходимо стараться минимизировать количество обращений к DOM.

Repaint - происходит, когда изменения затронули стили влияющие на внешний вид элемента, но не на геометрию. 
Например opacity, background-color, visibility и outline. Браузер отрисовывает элемент заново, с учётом нового стиля. 
Также проверяется видимость других элементов, один или более могут оказаться скрыты под изменившим внешний вид.

Reflow - происходит когда изменения затрагивают содержимое, структуру документа, положение элементов. 
Идет пересчет позиционирования и размеров, что ведет к перерисовке части или всего документа. 
Изменение размера одного родительского контейнера повлияет на всех его детей и предков. 
Имеет значительно большее влияние на производительность, чем repaint.

Все вышеперечисленные операции блокируют браузер. Страница не может выполнять никакие другие операции в то время, когда происходит reflow или repaint. 

Причинами могут быть:

Манипуляции с DOM (добавление, удаление, изменение, перестановка элементов)
Изменение содержимого, в т.ч. текста в полях форм
Расчёт или изменение CSS-свойств
Добавление и удаление таблиц стилей
Манипуляции с атрибутом class
Манипуляции с окном браузера (изменения размеров, прокрутка)
Активация псевдоклассов (например :hover)
*/

/**
  |============================
  | Свойство innerHTML
  |============================
*/
/* 
Еще один способ создать DOM-элементы и поместить их в дерево - это использовать строки с тегами и позволить браузеру сделать всю тяжелую работу. 
У такого подхода есть свои плюсы и минусы.




Чтение
Свойство innerHTML хранит содержимое элемента, включая теги, в виде строки. Возвращаемое значение это всегда валидный HTML-код.

const article = document.querySelector(".article");
console.log(article.innerHTML);

const title = document.querySelector(".article .title");
console.log(title.innerHTML);

const text = document.querySelector(".article .text");
console.log(text.innerHTML);

const link = document.querySelector(".article .link");
console.log(link.innerHTML);




Изменение
Свойство innerHTML доступно как для чтения, так и для записи. Если записать в него строку с HTML-тегами, то браузер во время парсинга строки 
превратит их в валидные элементы и добавит в DOM-дерево.

const title = document.querySelector(".article .title");
title.innerHTML = 'New and <span class="accent">improved</span> title';


ИНТЕРЕСНО
Если в свойство innerHTML записать пустую строку, то содержимое элемента будет очищено. Это простой и быстрый способ удаления всего содержимого.



При таком подходе, в отличии от document.createElement(), мы не получаем ссылку на созданный DOM-элемент. 
Это первый шаг на пути к шаблонизации - создания большого количества однотипной разметки с разными данными по заранее определённому шаблону. 
Например, как в списке товаров интернет магазина и т. п.

Однотипная (шаблонная) разметка создается из массива данных. Приём заключается в переборе этого массива и составлении одной строки с HTML тегами, 
которую потом записываем в innerHTML элемента.

const technologies = ["HTML", "CSS", "JavaScript", "React", "Node"];
const list = document.querySelector(".list");

const markup = technologies
  .map((technology) => `<li class="list-item">${technology}</li>`)
  .join("");

// Check the console, you'll see a single string with HTML tags
console.log(markup);

// Adding all the markup in one operation
list.innerHTML = markup;




Добавление
Изменение elem.innerHTML полностью удалит и пересоздаст всех потомков элемента elem. 
Если элемент изначально не пустой, то будут дополнительные затраты на сериализацию уже существующей разметки, а это плохо.

const article = document.querySelector(".article");
const htmlString = `<p class="article-text">Nullam quis ante. Vestibulum dapibus nunc ac augue. In consectetuer turpis ut velit.</p>
   <a class="link" href="#">Read more...</a>`;

// Replace += with = operator. See the difference? 
// Article title is lost because we overwrite element content.
article.innerHTML += htmlString;


ИНТЕРЕСНО
Используйте свойство elem.innerHTML для добавления только в случае когда элемент elem пустой или если надо полностью заменить его содержимое.




Метод insertAdjacentHTML()
Современный метод для добавления строки с HTML-тегами до, после или внутрь элемента. Решает проблему innerHTML с повторной сериализацией содержимого элемента 
при добавлении разметки к уже существующей.

elem.insertAdjacentHTML(position, string);

Аргумент position - это строка, позиция относительно элемента elem. Принимает одно из четырёх значений.

"beforebegin" - перед elem
"afterbegin" - внутри elem, перед всеми детьми
"beforeend" - внутри elem, после всех детей
"afterend" - после elem

const list = document.querySelector(".list");

const newTechnologies = ["React", "TypeScript", "Node.js"];
const markup = newTechnologies
  .map((technology) => `<li class="list-item new">${technology}</li>`)
  .join("");

list.insertAdjacentHTML("beforeend", markup);
list.insertAdjacentHTML("beforebegin", "<h2>Popular technologies</h2>");


ИНТЕРЕСНО
"beforebegin" и "afterend" работают только в том случае, если elem уже находится в DOM-дереве.
*/

/**
  |============================
  | Подключение скриптов
  |============================
*/
/* 
Загрузка и выполнение скрипта указанного в теге <script> без каких-либо атрибутов, блокируют обработку HTML-документа и построение DOM. Это проблема.

<script src="path-to-script.js"></script>

Когда анализатор встречает такой тег, обработка HTML-документа приостанавливается и начинается загрузка файла скрипта указанного в атрибуте src. 
После загрузки скрипт выполняется, и только потом возобновляется обработка HTML. Это называется «блокирующий» скрипт.

Атрибуты defer и async были введены чтобы дать разработчикам возможность лучше контролировать как загружать скрипты и когда именно их выполнять.

Атрибут defer
<script defer src="path-to-script.js"></script>

Атрибут defer указывает браузеру загружать файл скрипта в фоновом режиме, паралельно обработке HTML-документа и построению DOM. 
Скрипт будет выполнен только после того как HTML-документ обработан, а DOM построен. 
Такие скрипты не блокируют построение DOM-дерева и гарантированно выполняются в том порядке, в котором указаны в HTML-документе.

https://textbook.edu.goit.global/javascript-yk5evp/v2/img/lesson-11/defer.png


Атрибут async
<script async src="path-to-script.js"></script>

Загрузка скрипта с атрибутом async не блокирует построение DOM, но он выполняется сразу после загрузки. 
Это значит, что такие скрипты могут заблокировать построение DOM, и выполняются в произвольном порядке.

https://textbook.edu.goit.global/javascript-yk5evp/v2/img/lesson-11/async.png


*/

/**
  |============================
  | События
  |============================
*/
/* 
Событие это сигнал от браузера о том, что на веб-странице что-то произошло. 
События используются для реакции на действия пользователя и исполнения кода связанного с определенным событием. 
Существует много видов событий: мыши, клавиатуры, элементов форм, загрузки изображений, буфера обмена, изменение стадии CSS анимации или перехода, 
изменение размеров окна и много других.

Одно действие может вызывать несколько событий. Например, клик вызывает сначала mousedown, а затем mouseup и click. 
В тех случаях, когда одно действие генерирует несколько событий, их порядок фиксирован. То есть, обработчики вызовутся в порядке mousedown → mouseup → click.

Для того, чтобы элемент реагировал на действия пользователя, ему необходимо добавить слушателя (обработчик) события. 
То есть функцию, которая будет вызвана, как только событие произошло.




Метод addEventListener()
Добавляет слушателя события на элемент.

element.addEventListener(event, handler, options);

event - имя события, строка, например "click".
handler - коллбэк-функция которая будет вызвана при наступлении события.
options - необязательный объект параметров с расширенными настройками.
const button = document.querySelector(".my-button");

button.addEventListener("click", () => {
  console.log("Button was clicked");
});

Для коллбэка можно (и желательно) использовать отдельную функцию и передавать на неё ссылку. Именованная функция повышает читаемость кода.

const button = document.querySelector(".my-button");

const handleClick = () => {
  console.log("Button was clicked");
};

button.addEventListener("click", handleClick);

На одном элементе может быть сколько угодно обработчиков событий, даже событий одного типа. Коллбэк-функции будут вызываться в порядке регистрации их в коде.

const multiBtn = document.querySelector("#multiple");

const firstCallback = () => {
  console.log("First callback!");
};
const secondCallback = () => {
  console.log("Second callback!");
};
const thirdCallback = () => {
  console.log("Third callback!");
};

multiBtn.addEventListener("click", firstCallback);
multiBtn.addEventListener("click", secondCallback);
multiBtn.addEventListener("click", thirdCallback);




Метод removeEventListener()
Удаляет слушателя события с элемента. Аргументы аналогичны методу addEventListener().

element.removeEventListener(event, handler, options);

Для удаления нужно передать ссылку именно на ту коллбэк-функцию, которая была назначена в addEventListener(). 
В таком случае для коллбэков используют отдельную функцию и передают её по имени (ссылку).

const addListenerBtn = document.querySelector('.js-add');
const removeListenerBtn = document.querySelector('.js-remove');
const btn = document.querySelector(".target-btn");

const handleClick = () => {
  console.log("click event listener callback");
};

addListenerBtn.addEventListener("click", () => {
  btn.addEventListener("click", handleClick);
  console.log("click event listener was added to btn");
});

removeListenerBtn.addEventListener("click", () => {
  btn.removeEventListener("click", handleClick);
  console.log("click event listener was removed from btn");
});




Ключевое слово this
Если коллбэком будет функция которая использует this, по умолчанию контекст внутри неё будет ссылаться на DOM-элемент на котором висит слушатель.

const mango = {
  username: "Mango",
  showUsername() {
    console.log(this);
    console.log(`My username is: ${this.username}`);
  },
};

const btn = document.querySelector(".js-btn");

// ✅ Работает
mango.showUsername();

// ❌ this будет ссылаться на button если использовать showUsername как callback
btn.addEventListener("click", mango.showUsername); // не работает

// ✅ Не забывайте привязывать контекст методов объекта
btn.addEventListener("click", mango.showUsername.bind(mango));
*/

/**
  |============================
  | Объект события
  |============================
*/
/* 
Чтобы обработать событие, недостаточно знать о том, что это клик или нажатие клавиши, могут понадобиться детали. 
Например текущее значение текстового поля, элемент, на котором произошло событие, встроенные методы и другое.

Каждое событие представляет собой объект, который содержит информацию о деталях события и автоматически передается первым аргументом в обработчик события. 
Все события происходят от базового класса Event.

const handleClick = event => {
  console.log(event);
};

button.addEventListener("click", handleClick);

Параметр event это и есть обьект события, который автоматически передается первым аргументом при вызове коллбэк функции. 
Мы можем называть его как угодно, но обычно его объявляют как e, evt или event.

Некоторые свойства объекта события:

event.type - тип события.
event.currentTarget - элемент, на котором выполняется обработчик события.

-------------------------------
const button = document.querySelector(".btn");

const handleClick = (event) => {
  console.log("event: ", event);
  console.log("event type: ", event.type);
  console.log("currentTarget: ", event.currentTarget);
};

button.addEventListener("click", handleClick);
-------------------------------



Действия браузера по умолчанию
Некоторые события вызывают действие браузера встроенное по умолчанию как реакция на определенный тип события. 
Например клик по ссылке инициирует переход на новый адрес, указанный в href, а отправка формы перезагружает страницу. 
Чаще всего это поведение нежелательно и его необходимо отменить.

Для отмены действия браузера по умолчанию на объекте события есть стандартный метод preventDefault().


const form = document.querySelector(".register-form");

form.addEventListener("submit", (event) => {
  event.preventDefault();
  const {
    elements: { username, password }
  } = event.currentTarget;
  console.log(username.value, password.value);
});
*/

/**
  |============================
  | События клавиатуры
  |============================
*/
/* 
Есть два основных события клавиатуры: keydown и keyup. В отличии от других, события клавиатуры обрабатываются на документе, а не на конкретном элементе. 
Объекты событий клавиатуры происходят от базового класса KeyboardEvent.

document.addEventListener("keydown", event => {
  console.log("Keydown: ", event);
});

document.addEventListener("keyup", event => {
  console.log("Keyup: ", event);
});

При нажатии клавиши сначала происходит keydown, после чего keyup, когда клавишу отжали. На практике, в основном обрабатывают только событие keydown, 
так как оно происходит быстрее чем keyup и пользователь раньше видит результат нажатия. События keydown и keyup срабатывают при нажатии любой клавиши, 
включая служебные (Ctrl, Shift, Alt, Escape и другие).

ИНТЕРЕСНО
Раньше было еще одно событие клавиатуры - keypress. Многие посты на форумах и блогах по-прежнему могут его использовать, но будьте осторожны - 
оно устарело и поддержка в новых браузерах может прекратиться в любой момент.




Свойства key и code
Свойство key возвращает символ сгенерированный нажатием клавиши, принимая во внимание состояние клавиш модификаторов, например Shift, а так же текущий язык. 
Свойство code возвращает код физической клавиши на клавиатуре и не изменяется между языками.

document.addEventListener("keydown", event => {
  console.log("key: ", event.key);
  console.log("code: ", event.code);
});




Клавиши-модификаторы
Для обработки комбинации клавиш, например Ctrl + s или любую другую, на объекте события есть свойства ctrlKey, altKey, shiftkey и metaKey, 
хранящие булевое значение сигнализирующее о том, была зажата клавиша-модификатор или нет.

document.addEventListener("keydown", event => {
  event.preventDefault();

  if ((event.ctrlKey || event.metaKey) && event.code === "KeyS") {
    console.log("«Ctrl + s» or «Command + s» combo");
  }
});

Некоторые комбинации клавиш могут конфликтовать с поведением браузера по умолчанию. 
Например, Ctrl + d или Command + d делает закладку. Нужно стараться проектировать систему комбинаций страницы так, чтобы она не пересекалась 
со встроенной в браузер. Но, в крайнем случае, поведение по умолчанию можно отменить вызвав метод event.preventDefault().

ИНТЕРЕСНО
Не так давно, вместо свойств key и code использовали свойство keyCode. Многие посты на форумах и блогах по-прежнему могут использовать его, 
но будьте осторожны - оно устарело, не используйте свойство keyCode.
*/

/**
  |============================
  | События элементов форм
  |============================
*/
/* 
Событие submit
Отправка формы происходит при клике по кнопке с атрибутом type="submit" или нажатии клавиши Enter, находясь в каком-нибудь её текстовом поле. 
Событие submit можно применить для валидации (проверки) формы перед отправкой, так как на объекте события есть много полезных свойств связанных 
с элементами формы. Сабмит формы перезагружает страницу, поэтому не забывайте отменять действие по умолчанию методом preventDefault().


const registerForm = document.querySelector(".form");

registerForm.addEventListener("submit", handleSubmit);

function handleSubmit(event) {
  event.preventDefault();
  const form = event.currentTarget;
  const login = form.elements.login.value;
  const password = form.elements.password.value;
  
  if (login === "" || password === "") {
    return console.log("Please fill in all the fields!");
  }

  console.log(`Login: ${login.value}, Password: ${password.value}`);
  form.reset();
}

ИНТЕРЕСНО
Свойство elements DOM-элемента формы содержит обьект со ссылками на все её элементы у которых есть атрибут name. 
Поэтому в примере мы получаем значение полей обращаясь к login.value и password.value.




Событие change
Происходит после изменения элемента формы. Для текстовых полей или textarea событие произойдёт не при каждом вводе символа, а при потере фокуса, 
что не всегда удобно. Например, пока вы набираете что-то в текстовом поле - события нет, но как только фокус пропал, произойдет событие change. 
Для остальных элементов, например select, чекбоксов и радио-кнопок, событие change срабатывает сразу при выборе значения.

const select = document.querySelector(".pizza-select");
const textOutput = document.querySelector(".text-output");
const valueOutput = document.querySelector(".value-output");

select.addEventListener("change", setOutput);

function setOutput(event) {
  const selectedOptionValue = event.currentTarget.value;
  const selectedOptionIndex = event.currentTarget.selectedIndex;
  const selectedOptionText =
    event.currentTarget.options[selectedOptionIndex].text;

  textOutput.textContent = selectedOptionText;
  valueOutput.textContent = selectedOptionValue;
}


ИНТЕРЕСНО
Обратите внимание на полезные свойства при работе с элементом <select> в примере. Разберитесь что хранится в свойствах value, selectedIndex и options.




Событие input
Происходит только на текстовых полях и textarea, и создаётся каждый раз при изменении значения элемента, не дожидаясь потери фокуса. 
На практике input это самое главное событие для работы с текстовыми полями формы.


const textInput = document.querySelector(".text-input");
const output = document.querySelector(".output");

textInput.addEventListener("input", (event) => {
  output.textContent = event.currentTarget.value;
});




События focus и blur
Элемент получает фокус при клике мыши или переходе клавишей Tab. Момент получения фокуса и потери очень важен, при получении фокуса мы можем 
подгрузить данные для автозаполнения, начать отслеживать изменения и т. п. При потере фокуса - проверить введённые данные.

При фокусировке элемента происходит событие focus, а когда фокус исчезает, например пользователь кликает в другом месте экрана, происходит событие blur. 
Активировать или отменить фокус можно программно, вызвав в коде одноименные методы focus() и blur() у элемента.

const textInput = document.querySelector(".text-input");
const setFocusBtn = document.querySelector('[data-action="set"]');
const removeFocusBtn = document.querySelector('[data-action="remove"]');

setFocusBtn.addEventListener("click", () => {
  textInput.focus();
});

removeFocusBtn.addEventListener("click", () => {
  textInput.blur();
});

textInput.addEventListener("focus", () => {
  textInput.value = "This input has focus";
});

textInput.addEventListener("blur", () => {
  textInput.value = "";
});

Фокус может быть только на одном элементе страницы в единицу времени и текущий элемент, на котором фокус, доступен как document.activeElement.

ИНТЕРЕСНО
Многие элементы не могут получить фокус. Например, если кликнуть по <div>, то фокусировка на нем не произойдет, потому что это не интерактивный элемент.

*/
