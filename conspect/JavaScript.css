/**
  |============================
  | Подключение скрипта
  |============================
*/
/* Чтобы подключить JavaScript из внешнего файла:

Создайте файл с расширением .js и поместите его в подпапку js.
Затем укажите путь к файлу скрипта в атрибуте src тега script.
Cкрипт подключают перед закрывающим тегом <body> после всего содержимого

<script src="js/script.js"></script> 

Если скрипт подключен в <head>, отрисовка страницы останавливается до тех пор, пока скрипт не загрузится и выполнится полностью.
*/ /**
  |============================
  | Синтаксис
  |============================
*/
/* 
Инструкция (statement) - это связанный набор слов и символов из синтаксиса языка, которые объединяются чтобы выразить одну идею, 
одну инструкцию для машины.
a = b * 2;
    a и b - переменные (как в алгебраическом уравнении), это хранилища данных, которые использует программа. Переменная состоит 
            из идентификатора (имени) и связанного с ним значения.
    2 - просто число. Это называется значением литерала (literal value), так как не хранится в переменной.
    = и * - операторы, производят действия над значениями и переменными.

Инструкции состоят из частей, как в любом языке предложения состоят из фраз, и эти фразы называются выражениями.
Выражение (expression) - ссылка на переменную или значение, или на набор переменных и значений в сочетании с операторами.

Интерфейс - это набор свойств и методов сущности, доступных для использования в исходном коде.

Свойство
У нас с вами есть свойства: рост, вес, цвет глаз, то есть какие-то описательные характеристики. Так же и у данных есть свойства, 
например у строки есть свойство ее длины. Синтаксис обращения к свойству очень простой - через точку.
сущность.имя_свойства
Для наглядности обратимся к свойству строки length, которое содержит кол-во символов строки.
"JavaScript is awesome".length;

Метод
Это вызов действия, например присесть или плавать, то есть какая-то активная операция. Так же и у данных есть свои заранее 
определённые методы, например можно добавить или удалить элементы из коллекции, перевести строку в разный регистр и т. д. 
Синтаксис вызова метода очень похож на обращение к свойству, но в конце добавляется пара круглых скобок.
сущность.имя_метода()
Для примера обратимся к методу строки toUpperCase(), который сделает все буквы заглавными.
"JavaScript is awesome".toUpperCase();

Строгий режим
Новая возможность в спецификации ECMAScript 5, которая позволяет переводить скрипт в режим полного соответствия современному стандарту. 
Это предотвращает определенные ошибки, такие как использование небезопасных и устаревших конструкций.
Для того, чтобы перевести скрипт в строгий режим, достаточно указать директиву в начале js-файла. 
Всегда пишите код в строгом режиме.

script.js
"use strict";
// Это комментарий. Дальше идет весь код JS-файла
*/
/**
  |============================
  | Переменные и типы
  |============================
*/
/* 
Переменные используются для хранения данных и состоят из идентификатора (имени) и области в памяти, где хранится их значение.

Идентификатор - это имя переменной, функции или класса. Состоит из одного или нескольких символов в следующем формате.

Первым символом должна быть буква a-z или A-Z, символ подчеркивания _ или знак доллара $.
Другие символы могут быть буквами a-z, A-Z, цифрами 0-9, подчеркиваниями _ и знаками доллара $.
Идентификаторы чувствительны к регистру. Это значит, что переменные user, usEr и User различны.

Использование camelCase-нотации для идентификаторов это стандарт. Первое слово пишется строчными буквами, а каждое последующее 
начинается с заглавной. Например, user, greetUser, getUserData.

Как называть переменные:
https://bookflow.ru/kak-nazyvat-peremennye/

Есть список зарезервированных ключевых слов, которые имеют специальное значение и используются для определенных конструкций. 
Нельзя использовать ключевые слова как идентификаторы.
abstract	arguments	await	boolean
break	byte	case	catch
char	class	const	continue
debugger	default	delete	do
double	else	enum	eval
export	extends	false	final
finally	float	for	function
goto	if	implements	import
in	instanceof	int	interface
let	long	native	new
null	package	private	protected
public	return	short	static
super	switch	synchronized	this
throw	throws	transient	true
try	typeof	var	void
volatile	while	with	yield

Объявление переменной начинается с ключевого слова const. Такая переменная должна быть сразу инициализирована значением, после 
чего его нельзя переопределить.
Переменные, объявленные как const, обязательно должны быть инициализированы значением во время объявления, иначе будет ошибка.

const yearOfBirth = 2006;

Для того, чтобы объявить переменную, которой в будущем можно будет присвоить новое значение, используется ключевое слово let.
Переменным, объявленным через let, не обязательно сразу присваивать значение.

let age;

Если переменной, объявленной как let, изначально не присвоено значение, она инициализируется специальным значением undefined (не определено).

константы и КОНСТАНТЫ
Имена КОНСТАНТ - переменных, значение которых не изменяется никогда на протяжении работы всего скрипта, обычно записываются 
в формате UPPER_SNAKE_CASE.
Абсолютное большинство переменных – константы в другом смысле, они просто не изменяют значение после присвоения. 
Но при разных запусках скрипта, это значение может быть разным. Имена таких переменных записывают используя формат camelCase.

неопределенные и необъявленные переменные
Неопределенная (undefined) - это переменная, которая была объявлена ключевым слово let, но не инициализирована значением. 
По умолчанию ей присваивается начальное значение undefined.
Необъявленная (undeclared или not defined) - это переменная, которая не была объявлена в доступной области видимости. Попытка обратиться 
к пременной до её объявления вызовет ошибку. Например, чтобы прочитать или изменить её значение.

Примитивные типы
- Number - целые числа и числа с плавающей запятой (точкой).
const age = 20;
- String - строки, последовательность из нуля или более символов. Строка начинается и заканчивается одиночной ', или двойными кавычками ".
const username = "Mango";
- Boolean - логический тип данных, флаги состояния. Всего два значения: true и false. 
const isLoggedIn = true;
- null - особое значение, которое по сути значит ничто. Используется в тех ситуациях, когда необходимо явно указать пустоту. 
К примеру если пользователь ещё ничего не выбрал, то можно сказать что значение null.
let selectedProduct = null;
- undefined - ещё одно специальное значение. По умолчанию, когда переменная объявляется, но не инициализируется, ее значение 
не определено, ей присваивается undefined.
let username;
console.log(username); // undefined

Оператор typeof
Используется для получения типа значения переменной. Возвращает на место своего вызова тип значения переменной указанного после 
него - строку в которой указан тип.
let username;
console.log(typeof username); // "undefined"
let inputValue = null;
console.log(typeof inputValue); // "object"
*/
/**
  |============================
  | Взаимодействие с пользователем
  |============================
*/
/* 
Вывод данных
Для вывода данных есть два метода: console.log() и alert(). 
В круглых скобках указываем имя переменной, значение которой необходимо вывести.
Можно сначала указать какую-то описательную строку, после чего поставить запятую и указать имя переменной.

const username = "Mango";
console.log("Username is ", username);

Метод alert() выводит модальное окно, текст которого соответствует значению переменной (или литерала) которую передадим в скобках.
const message = "JavaScript is awesome!";
alert(message);

Получение данных
Для получения данных от пользователя есть prompt() и confirm(). Это тоже методы из интерфейса window. 
Результатом своего выполнения они возвращают то, что было введено пользователем, поэтому результат их работы можно записать 
в переменную для дальнейшего использования.

confirm() - выводит модальное окно с сообщением, и две кнопки, Ok и Cancel. 
При нажатии на Ok, результатом будет true, при нажатии на Cancel - возвращается false.
const isComing = confirm("Please confirm hotel reservation");
console.log(isComing);

prompt() - выводит модальное окно с полем ввода и кнопками Ok и Cancel. При нажатии Ok, результатом будет то, что ввел пользователь, 
при Cancel - возвращается null.
const hotelName = prompt("Please enter desired hotel name");
console.log(hotelName);
Важная особенность prompt в том, что не зависимо что ввел пользователь, всегда вернется строка. То есть, если пользователь ввел 5, 
то вернется не число 5, а строка "5".
*/
/**
  |============================
  | Основные операторы
  |============================
*/
/* 
Математические операторы
Назначение, функционал и приоритет (порядок) операций ничем не отличаются от школьного курса алгебры. 
Операторы возвращают значение как результат выражения.
Важно запомнить термины составляющих выражения. + - * / % называются операторы, а то, на чем они применяются - операнды.
const x = 10;
const y = 5;
// Сложение
console.log(x + y); // 15
// Вычитание
console.log(x - y); // 5
// Умножение
console.log(x * y); // 50
// Деление
console.log(x / y); // 2
// Остаток от деления
console.log(x % y); // 0
// Сложение с заменой (также есть для всех других операторов)
let value = 5;
// Аналогично записи value = value + 10;
value += 10;
console.log(value); // 15

Операторы сравнения
Используются для сравнения двух значений. Результатом своего выполнения возвращают буль - true или false, то есть «да» или «нет».

a > b и a < b - больше/меньше
a >= b и a <= b - больше/меньше или равно
a == b - равенство
a != b - неравенство
a === b - строгое равенство
a !== b - строгое неравенство

const x = 5;
const y = 10;
const z = 5;

console.log("x > y:", x > y); // false
console.log("x < y:", x < y); // true
console.log("x < z:", x < z); // false
console.log("x <= z:", x <= z); // true
console.log("x === y:", x === y); // false
console.log("x === z:", x === z); // true
console.log("x !== y:", x !== y); // true
console.log("x !== z:", x !== z); // false

«Нестрогие» операторы равенства == и != выполняют преобразование типов сравниваемых значений к числу, что может привести к ошибкам, 
особенно у начинающих.
console.log(5 == "5"); // true
console.log(5 != "5"); // false
На следующей иллюстрации показана таблица сравнения значений используя операторы нестрогого равенства.
https://textbook.edu.goit.global/javascript-yk5evp/v2/img/lesson-01/not-strict-equality.png

Поэтому для проверки равенства или неравенства двух значений используются только операторы === (строгое равенство) и 
!== (строгое неравенство), которые не выполняют приведение типов операндов.
console.log(5 === "5"); // false
console.log(5 === 5); // true
console.log(5 !== "5"); // true
В таком случае, все равно только себе. Перед оценкой ничего не преобразуется.
https://textbook.edu.goit.global/javascript-yk5evp/v2/img/lesson-01/strict-equality.png
*/
/**
  |============================
  | Числа
  |============================
*/
/* 
Все числа в JavaScript, как целые так и дробные, имеют тип Number и записывать их можно не только в десятичной системе счисления.

Приведение к числу
Большинство арифметических операций и математических функций преобразуют значение в число автоматически. Для того чтобы сделать 
это явно, используйте функцию Number(val), передавая ей в val то, что надо привести к числу.
Если значение не возможно привести к числу, результатом будет специальное числовое значение NaN (Not a Number). Аналогичным образом 
происходит преобразование и в других математических операторах и функциях.

const valueA = "5";
console.log(Number(valueA)); // 5
console.log(typeof Number(valueA)); // "number"

const valueB = "random string";
console.log(Number(valueB)); // NaN
console.log(typeof Number(valueB)); // "number"


Методы Number.parseInt() и Number.parseFloat()
Преобразуют строку символ за символом, пока это возможно. При возникновении ошибки возвращается число, которое получилось.

Метод Number.parseInt() парсит из строки целое число.
console.log(Number.parseInt("5px")); // 5
console.log(Number.parseInt("12qwe74")); // 12
console.log(Number.parseInt("12.46qwe79")); // 12
console.log(Number.parseInt("qweqwe")); // NaN

Метод Number.parseFloat() парсит из строки дробное число.
console.log(Number.parseFloat("5px")); // 5
console.log(Number.parseFloat("12qwe74")); // 12
console.log(Number.parseFloat("12.46qwe79")); // 12.46
console.log(Number.parseFloat("qweqwe")); // NaN

Функция Number - преобразует переданное значение в число. 
В случае строки пробельные символы по краям обрезаются, затем, если строку возможно преобразовать в число - то возвращается это число, 
а если нет - возвращается NaN. 
Значение true преобразуется к числу 1, значение false - к числу 0. 
Объекты при численных преобразованиях превращаются в NaN.
 
Преобразуем булевое значение true в число:
Number(true);
Результат выполнения кода:
1
 
А теперь давайте преобразуем булевое значение false:
Number(false);
Результат выполнения кода:
0
 
Давайте в параметр функции введем строку, содержащую число:
Number('53');
В результате преобразования мы получим число:
53
 
А теперь добавим к числу пробелы в начале и в конце строки:
Number(' 5 ');
После выполнения кода лишние пробелы удаляются и в итоге мы получаем число:
5
 
Давайте преобразуем пустую строку:
Number('');
Результат выполнения кода:
0
 
Теперь преобразуем строку, содержащую букву и цифру:
Number('a5');
После выполнения кода получаем значение NaN, показывающее недопустимую математическую операцию:
NaN
 
Давайте поменяем местами в строке букву и цифру:
Number('5a');
Результат выполнения кода останется прежним:
NaN
 
Теперь преобразуем строку, в которой числа разделены пробелом:
Number('5 5');
В результате выполнения кода мы опять увидим, что данная математическая операция недопустима:
NaN
 
Давайте преобразуем булевое значение true, заключенное в строку:
Number('true');
После выполнения кода снова получим NaN:
NaN
 
Теперь преобразуем пустой объект:
Number({});
Результат выполнения кода:
NaN
 
Давайте зададим в параметре функции пустой массив:
Number([]);
В результате мы получим число 0:
0
 
Теперь добавим в массив цифру:
Number([1]);
Массив преобразуется в число:
1
 
Давайте преобразуем массив, включающий две цифры:
Number([1, 2]);
В результате нам снова сообщат, что данная математическая операция недопустима:
NaN



Проверка на число
Для проверки на число можно использовать метод Number.isNaN(val). Он проверяет, является ли указанное значение NaN или нет. 
Метод отвечает на вопрос "Это Not A Number?" и возвращает:
true - если значение val это NaN
false - если значение val это не NaN
Этот метод не производит попытку преобразовать val к числу, а просто выполняет проверку на NaN.

const validNumber = Number("51"); // 51
console.log(Number.isNaN(validNumber)); // false

const invalidNumber = Number("qweqwe"); // NaN
console.log(Number.isNaN(invalidNumber)); // true



Сложение чисел с плавающей точкой

При сложении не целых чисел в JavaScript и других языках программирования, есть особенность. Если кратко, то 0.1 + 0.2 не равно 0.3, 
результат сложения больше чем 0.3. Все от того что машина считает в двоичной системе.
Число 0.1 в двоичной системе счисления - это бесконечная дробь, так как единица на десять в двоичной системе не делится. 
Двоичное значение бесконечных дробей хранится только до определенного знака, поэтому возникает неточность. При сложении 0.1 и 0.2, 
две неточности складываются, получается незначительная, но всё же ошибка в вычислениях.
console.log(0.1 + 0.2 === 0.3); // false
console.log(0.1 + 0.2); // 0.30000000000000004

Конечно, это не означает, что точные вычисления для таких чисел невозможны. Есть несколько методов решения этой проблемы.
Можно сделать их целыми, умножив на N, сложить, а потом результат разделить также на N.
console.log(0.17 + 0.24); // 0.41000000000000003
console.log((0.17 * 100 + 0.24 * 100) / 100); // 0.41
Еще один способ - сложить, а результат отсечь до определённого знака после запятой при помощи метода toFixed().
console.log(0.17 + 0.24); // 0.41000000000000003
console.log((0.17 + 0.24).toFixed(2)); // 0.41




Класс Math
Один из встроенных классов, который предоставляет набор методов для работы с числами.
// Math.floor(num) - возвращает наибольшее целое число, меньшее, либо равное указанному
console.log(Math.floor(1.7)); // 1

// Math.ceil(num) - возвращает наименьшее целое число, большее, либо равное указанному числу.
console.log(Math.ceil(1.2)); // 2

// Math.round(num) - возвращает значение числа, округлённое до ближайшего целого
console.log(Math.round(1.2)); // 1
console.log(Math.round(1.5)); // 2

// Math.max(num1, num2, ...) - возвращает наибольшее число из набора
console.log(Math.max(20, 10, 50, 40)); // 50

// Math.min(num1, num2, ...) - возвращает наименьшее число из набора
console.log(Math.min(20, 10, 50, 40)); // 10

// Math.pow(base, exponent) - возведение в степень 
console.log(Math.pow(2, 4)); // 16

// Math.random() - возвращает псевдослучайное число в диапазоне [0, 1)
console.log(Math.random()); // случайное число между 0 и 1
console.log(Math.random() * (10 - 1) + 1); // псевдослучайное число от 1 до 10

*/

/**
  |============================
  | Строки
  |============================
*/
/* 
Строка - это индексированный набор из нуля или более символов, заключенных в одинарные либо двойные кавычки.
const username = "Mango";
Важно помнить, что индексация элементов строки начинается с нуля. К примеру в строке "JavaScript" буква "J" стоит на позиции с индексом 0.
Содержимое строки нельзя изменить, только прочитать. То есть нельзя взять какой-то символ и заменить его, 
как только строка создана - она такая навсегда. Можно лишь создать целиком новую строку и присвоить в переменную вместо старой.

Конкатенация строк
Если применить оператор + к строке и любому другому типу данных, результатом операции «сложения» будет строка. 
Эта операция называется конкатенация, или сложение строк.
Во время конкатенации, любой тип данных приводится к строке и сшивается со строкой, но есть особенность - последовательность 
записи операндов.
Последовательность операций имеет значение, преобразование типов происходит только в момент операции сложения со строкой, 
до этого момента действуют привычные правила математики.

const message = "Mango " + "is" + " happy";
console.log(message); // Mango is happy
console.log(1 + "2"); // "12"
console.log(1 + "2" + 4); // "124"
console.log(1 + 2 + "4"); // "34"
В последнем примере произошла математическая операция сложения для первых двух чисел 1 и 2, после чего число 3 было преобразовано 
в строку "3" и сшито со строкой "4".



Шаблонные строки
Шаблонные строки это альтернатива конкатенации с более удобным синтаксисом. Шаблонная строка заключена в обратные (косые) 
кавычки вместо двойных или одинарных и может содержать местозаполнители, которые обозначаются знаком доллара и фигурными скобками 
- ${выражение}.

// Используя переменные необходимо составить строку с подставленными значениями
const guestName = "Манго";
const roomNumber = 207;
const greeting =  "Welcome " + guestName + ", your room number is " + roomNumber + "!";
console.log(greeting); // "Welcome Mango, your room number is 207!"

Составлять строки с подставляемыми значениями используя конкатенацию очень неудобно. 
На помощь приходят шаблонные строки и интерполяция.
const guestName = "Манго";
const roomNumber = 207;
const greeting = `Welcome ${guestName}, your room number is ${roomNumber}!`;
console.log(greeting); // "Welcome Mango, your room number is 207!"



Свойство length
Для того чтобы узнать длину строки, то есть количество её символов, у всех строк есть встроенное свойство length, 
значение которого можно получить обратившись к нему через точку после имени переменной или строкового литерала.

const message = "Welcome to Bahamas!";
console.log(message.length); // 19
console.log("There is nothing impossible to him who will try".length); // 47



Методы toLowerCase() и toUpperCase()
Возвращают новую строку в соответствующем регистре, не изменяя оригинальную строку.

const message = "Welcome to Bahamas!";
console.log(message.toLowerCase()); // "welcome to bahamas!"
console.log(message.toUpperCase()); // "WELCOME TO BAHAMAS!"
console.log(message); // "Welcome to Bahamas!"

Чтобы не требовать абсолютно точный ввод можно сделать «нормализацию» введённой пользователем строки, то есть преобразовать 
все её символы в верхний или нижний регистр. Методы строки toLowerCase() и toUpperCase() вернут новую строку в соответствующем 
регистре, не изменяя оригинальную.

const BRAND_NAME = "SAMSUNG";
const userInput = "saMsUng";
const normalizedToUpperCaseInput = userInput.toUpperCase();

console.log(userInput); // 'saMsUng'
console.log(userInput === BRAND_NAME); // false
console.log(normalizedToUpperCaseInput); // 'SAMSUNG'
console.log(normalizedToUpperCaseInput === BRAND_NAME); // true



Метод indexOf()
Возвращает позицию (индекс) на которой находится первое совпадение подстроки или -1, если ничего не найдено.
const message = "Welcome to Bahamas!";
console.log(message.indexOf("to")); // 8
console.log(message.indexOf("hello")); // -1



Метод includes()
Проверяет входит ли подстрока в строку, возвращает буль - true если входит и false в противном случае. 
Регистр символов в строке и подстроке имеет значение, так как например буква "a" не равна букве "А".

const productName = "Ремонтный дроид";
console.log(productName.includes("н")); // true
console.log(productName.includes("Н")); // false
console.log(productName.includes("дроид")); // true
console.log(productName.includes("Дроид")); // false
console.log(productName.includes("Ремонтный")); // true
console.log(productName.includes("ремонтный")); // false



Метод endsWith()
Позволяет определить, заканчивается ли строка символами (подстрокой) указанными в скобках, возвращая true или false.
const jsFileName = "script.js";
console.log(jsFileName.endsWith(".js")); // true
const cssFileName = "styles.css";
console.log(cssFileName.endsWith(".js")); // false



Методы replace() и replaceAll()
Возвращают новую строку, в которой первое (replace) или все совпадения (replaceAll) подстроки заменены на указанное значение.

const jsFileName = "script.js";
const minifiedJsFileName = jsFileName.replace(".js", ".min.js");
console.log(minifiedJsFileName); // "script.min.js"

const cssFileNames = "styles.css, about.css, portfolio.css";
const minifiedCssFileNames = cssFileNames.replaceAll(".css", ".min.css");
console.log(minifiedCssFileNames); // "styles.min.css, about.min.css, portfolio.min.css"



Метод slice()
Метод строк slice(startIndex, endIndex) используется для создания копии части или всей строки. 
Он делает копию элементов строки от startIndex и до, но не включая endIndex и возвращает новую строку, не изменяя оригинал.

const productName = "Repair droid";
console.log(productName.slice(0, 4)); // "Repa"
console.log(productName.slice(3, 9)); // "air dr"
console.log(productName.slice(0, productName.length)); // "Repair droid"
console.log(productName.slice(7, productName.length)); // "droid"
*/

/**
  |============================
  | Логические операторы
  |============================
*/
/* 
Логические операторы используются для проверки условий с множественными выражениями, например в операциях сравнения.

Приведение типов
В логических операциях осуществляется приведение типов операндов к true или false. 
Приведение происходит если в коде обнаружен логический оператор.
Truthy и Falsy - термины, которые используются для тех значений, которые, в логической операции, приводятся к true или false, 
хотя изначально не были булями.



Логическое «И»
Оператор && приводит все операнды к булю и возвращает значение одного из них. 
Левый операнд если его можно привести к false, и правый в остальных случаях.

выражение && выражение

В следующем примере оба условия вернут true, поэтому результатом всего выражения будет true - вернётся значение правого операнда.
const age = 20;
console.log(age > 10 && age < 30); // true && true -> true
Если хотябы один из операндов будет приведён к false, результатом выражения будет его значение.

const age = 50;
console.log(age > 10 && age < 30); // true && false -> false
console.log(age > 80 && age < 120); // false && true -> false
То есть логическое «И» запинается на лжи и возвращает то на чём запнулось или последний операнд.

console.log(1 && 5); // true && true -> 5
console.log(5 && 1); // true && true -> 1
console.log(0 && 2); // false && true -> 0
console.log(2 && 0); // true && false -> 0
console.log("" && "Mango"); // false && true -> ""
console.log("Mango" && ""); // true && false -> ""
console.log("Mango" && "Poly"); // true && true -> "Poly"
console.log("Poly" && "Mango"); // true && true -> "Mango"



Логическое «ИЛИ»
Оператор || приводит все операнды к булю и возвращает значение одного из них. 
Левый операнд если его можно привести к true, и правый в остальных случаях.

выражение || выражение

В следующем примере условие слева вернёт true, поэтому результатом всего выражения будет true - вернётся значение первого операнда 
которое было приведено к true.
const age = 5;
console.log(age < 10 || age > 30); // true || false -> true

Тут результатом тоже будет true, так как хотябы один из операндов, в этом случае правый, был приведён к true.
const age = 40;
console.log(age < 10 || age > 30); // false || true -> true

А здесь ни одно из условий не выполняется, поэтому получаем false - значение последнего операнда.
const age = 20;
console.log(age < 10 || age > 30); // false || false -> false

То есть логическое «ИЛИ» запинается на правде и возвращает то на чём запнулось или последний операнд.

console.log(true || false); // true
console.log(false || true); // true
console.log(true || true); // true

console.log(3 || false); // 3
console.log(false || 3); // 3
console.log(3 || true); // 3
console.log(true || 3); // true



Логическое «НЕ»
Все операторы которые мы рассматривали до этого были бинарными - содержащими два операнда, левый и правый. 
Логическое «НЕ» это унарный оператор - выполняющий операцию над одним операндом справа.

!выражение

Оператор ! приводит операнд к булю, если необходимо, а затем делает инверсию - заменяет его на противоположный 
true -> false или false -> true.

console.log(!true); // false
console.log(!false); // true
console.log(!3); // !3 -> !true -> false
console.log(!"Mango"); // !"Mango" -> !true -> false
console.log(!0); // !0 -> !false -> true
console.log(!""); // !"" -> !false -> true

const isOnline = true;
const isNotOnline = !isOnline; // !isOnline -> !true -> false
*/
/**
  |============================
  | Ветвления
  |============================
*/
/* 
Ветвления используются для выполнения различного кода в зависимсти от условия. Принцип работы простой - результат условия 
приводится к булю true или false, после чего поток программы направляется в ту или иную ветку.



Инструкция if
Входные данные, которые приводятся к булю называются условием. Условие помещают за оператором if в круглых скобках. 
Если условие приводится к true, то выполняется код в фигурных скобках тела if.
Если условие приводится к false, код в фигурных скобках будет пропущен.

let cost = 0;
const subscription = "pro";
if (subscription === "pro") {
  cost = 100;
}
console.log(cost); // 100

let cost = 0;
const subscription = "free";
if (subscription === "pro") {
  cost = 100;
}
console.log(cost); // 0



Инструкция if...else
Расширяет синтаксис if тем, что в случае если условие приводится к false, выполнится код в фигурных скобках после оператора else.
Если условие приводится к true, тело блока else игнорируется.

let cost;
const subscription = "free";
if (subscription === "pro") {
  cost = 100;
} else {
  cost = 0;
}
console.log(cost); // 0

let cost;
const subscription = "pro";
if (subscription === "pro") {
  cost = 100;
} else {
  cost = 0;
}
console.log(cost); // 100



Инструкция else...if
Конструкция if...else может проверить и среагировать на выполнение или невыполнение только одного условия.
Блок else...if позволяет добавить после else еще один оператор if с условием. В конце цепочки может быть классический блок else, 
который выполнится только в случае, когда ни одно из условий не приведётся к true.
При первом же true проверки прекратятся и выполнится только один сценарий, соответствующий этому true. 
Поэтому подобную запись следует читать как: ищу первое совпадение условия, игнорирую все остальное.

let cost;
const subscription = "premium";

if (subscription === "free") {
  cost = 0;
} else if (subscription === "pro") {
  cost = 100;
} else if (subscription === "premium") {
  cost = 500;
} else {
  console.log("Invalid subscription type");
}

console.log(cost); // 500
*/

/**
  |============================
  | Тернарный оператор
  |============================
*/
/* 
Тернарный оператор используется как более синтаксически краткая замена инструкции if...else, когда одной и той же переменной 
необходимо присвоить разные значения по условию.

<условие> ? <выражение_если_условие_истинно> : <выражение_если_условие_ложно>

Работает по такой схеме:
Вычисляется условие.
Если условие истинно, то есть приводится к true, вычисляется выражение после ?.
Если условие ложно, то есть приводится к false, вычисляется выражение после :.
Значение вычисленного выражения возвращается как результат работы тернарного оператора.

Тернарный оператор должен использоваться в простых операциях присваивания или возврата. 
го использование для описания сложных ветвлений - плохая практика (антипаттерн).

let type;
const age = 20;
if (age >= 18) {
  type = "adult";
} else {
  type = "child";
}
console.log(type); // "adult"

Выполним рефакторинг заменив if...else тернарным оператором.

const age = 20;
const type = age >= 18 ? "adult" : "child";
console.log(type); // "adult"

Запишем операцию поиска большего числа.

const num1 = 5;
const num2 = 10;
let biggerNumber;
if (num1 > num2) {
  biggerNumber = num1;
} else {
  biggerNumber = num2;
}
console.log(biggerNumber); // 10

Код работает верно, получаем большее число из двух, но это решение кажется слишком громоздким, учитывая, насколько проста проблема. 
Используем тернарный оператор.

const num1 = 5;
const num2 = 10;
const biggerNumber = num1 > num2 ? num1 : num2;

console.log(biggerNumber); // 10
*/

/**
  |============================
  | Инструкция switch
  |============================
*/
/* 
В некоторых случаях неудобство чтения сложных ветвлений if...else можно избежать используя более «плоский» синтаксис инструкции 
ветвления switch.
Область применения switch ограничена задачами с одним общим вопросом (что сравнивать) и множеством вариантов ответов (с чем сравнивать).
Его синтаксис состоит из блока switch(значение) - что нужно сравнить и множества отдельных случаев case значение - с чем нужно сравнить. 
Для сравнения используется оператор строгого равенства ===. То есть нельзя сравнить на больше или меньше, только на равенство.

switch (значение) {
  case значение:
    инструкции;
    break;
  case значение:
    инструкции;
    break;
  default:
    инструкции;
}

Значение в блоке switch(значение) - строка или число, которое сравнивается на строгое равенство со всеми значениями в блоках case 
значение по порядку, сверху вниз.
Оператор break в завершении каждого блока case необходим чтобы прервать дальнейшие проверки и сразу перейти к коду за switch 
в том случае, когда проверка на равенство вернула true.
Если оператор break будет отсутствовать, то после того как выполнится какое-то условие case, все последующие за ним блоки кода будут 
ыполняться один за другим, что может привести к нежелательным последствиям при неверном применении.
Если ни одного совпадения значений не произошло, необходимо выполнить код по умолчанию, как в блоке else для инструкции if...else. 
Для этого после всех блоков case добавляется блок default. Оператор break после блока default не нужен, так как это и так последнее 
что будет выполнено в switch и управление будет передано коду за ним.

let cost;
const subscription = "premium";

switch (subscription) {
  case "free":
    cost = 0;
    break;

  case "pro":
    cost = 100;
    break;

  case "premium":
    cost = 500;
    break;

  default:
    console.log("Invalid subscription type");
}

console.log(cost); // 500
*/

/**
  |============================
  | Область видимости
  |============================
*/
/* 
Область видимости переменных (variable scope) - доступность переменных в определённом месте кода.

Глобальная область видимости используется по умолчанию. Все и вся имеют доступ к переменным объявленным в ней. 
Например, переменная value объявлена в глобальной области видимости, то есть вне какого-то блока, и доступна в любом месте 
после объявления.

const value = 5;
if (true) {
  console.log("Block scope: ", value); // 5
}

console.log("Global scope: ", value); // 5

Любая конструкция использующая фигурные скобки {} (условия, циклы, функции и т. п.) создает новую локальную область видимости, 
и переменные, объявленные в этой области видимости, используя let или const, не доступны вне этого блока.

if (true) {
  const value = 5;
  console.log("Block scope: ", value); // 5
}

console.log("Global scope: ", value); // ReferenceError: value is not defined

Глубина вложенности областей видимости не ограничена, и все они будут работать по одному принципу - область видимости имеет доступ 
ко всем переменным объявленным выше по иерархии вложенности, но не может получить доступ к переменным объявленным во вложенных 
областях видимости.
*/

/**
  |============================
  | Циклы
  |============================
*/
/* 
Цикл - управляющая конструкция в высокоуровневых языках программирования, предназначенная для организации многократного 
исполнения набора инструкций.
Тело цикла - последовательность инструкций, предназначенная для многократного исполнения.
Итерация - единичное выполнение тела цикла.
Условие выхода - выражение, определяющее будет в очередной раз выполняться итерация, или цикл завершится.
Счётчик - переменная, хранящая текущий номер итерации. Цикл не обязательно содержит счётчик, и он не обязан быть один, 
условие выхода из цикла может зависеть от нескольких изменяемых в цикле переменных.




Цикл while
Цикл с предусловием — цикл, который выполняется пока истинно некоторое условие, указанное перед его началом. 
Это условие проверяется до выполнения тела цикла, поэтому тело может быть не выполнено ни разу, если условие с самого начала ложно.

while (condition) {
  // код, тело цикла (statement)
}

Конструкция while создает цикл, который выполняет блок кода, пока условие проверки оценивается как true.
condition, то есть условие, вычисляется перед каждой итерацией цикла.
Если condition оценивается как true, оператор while выполняет statement.
Если condition оценивается как false, выполнение цикла прерывается и скрипт продолжает выполнять инструкции после цикла while.

Сделаем счетчик.

let counter = 0;
while (counter < 10) {
  console.log("counter: ", counter);
  counter += 1;
}

Будем заполнять места в отеле до тех пор пока текущее количество клиентов не будет равно максимально допустимому.

let clientCounter = 18;
const maxClients = 25;
while (clientCounter < maxClients) {
  console.log(clientCounter);
  clientCounter += 1;
}




Цикл do...while
Цикл с постусловием - цикл, в котором условие проверяется после выполнения тела цикла. Отсюда следует, что тело всегда выполняется 
хотя бы один раз.

do {
  // statement
} while (condition);

Конструкция do...while создает цикл, который выполняет блок кода до тех пор, пока condition не вернёт false.
В отличие от цикла while, цикл do...while всегда выполняет statement как минимум один раз, прежде чем он оценит condition.
Внутри цикла нужно внести изменения в некоторую переменную, чтобы убедиться, что выражение равно false после итераций. 
В противном случае будет бесконечный цикл.

let password = "";
do {
  password = prompt("Введите пароль длиннее 4-х символов", "");
} while (password.length < 5);

console.log("Ввели пароль: ", password);




Цикл for
Цикл со счётчиком - цикл, в котором некоторая переменная изменяет своё значение от заданного начального до конечного значения 
с некоторым шагом и для каждого значения этой переменной тело цикла выполняется один раз.

В большинстве процедурных языков программирования реализуется конструкцией for, в которой указывается счётчик, требуемое 
количество итераций и шаг, с которым изменяется счётчик.

for (initialization; condition; post-expression) {
  // statements
}

Алгоритм исполнения цикла for:

Инициализация (initialization) - выполняется один раз перед началом цикла. Используется для создания переменной-счётчика и указания 
её начального значения.
Условие (condition) - выражение, оцениваемое перед каждой итерацией (повторением) цикла. Тело цикла выполняется только тогда, 
когда выражение приводится к true. Цикл завершается, если значение будет false.
Тело (statements) - набор инструкций для выполнения на каждом повторении. Выполняется если выражение условия приводится к true.
Пост-выражение (post-expression) - выполняется в конце каждого повторения цикла, перед проверкой условия. Используется для 
обновления переменной-счётчика.
Переменные-счетчики, по традиции, называются буквами i, j и k.

for (let i = 0; i <= 20; i += 5) {
  console.log(i);
}

В примере объявляется перемнная-счетчик i, инициализируется значением 0 и цикл выполняется до тех пор, пока i <= 20, то есть 
условие приводится к true. После каждой итерации счётчик увеличивается на 5.

Посчитаем сумму чисел до определенного значения.

const target = 3;
let sum = 0;

for (let i = 0; i <= target; i += 1) {
  sum += i;
}

console.log(sum);

Вспомним про операцию a % b и выведем остаток от деления используя цикл.

const max = 10;
for (let i = 0; i < max; i += 1) {
  console.log(`${max} % ${i} = `, max % i);
}




Оператор break
Прервать выполнение цикла можно в любой момент. Для этого сущестует оператор break, который полностью прекращает выполнение цикла 
и передаёт управление на строку за его телом.

Найдём число 3. Как только выполнится условие if, цикл прекратит своё выполнение (будет прерван).

for (let i = 0; i <= 5; i += 1) {
  console.log(i);

  if (i === 3) {
    console.log("Нашли число 3, прерываем выполнение цикла");
    break;
  }
}

console.log("Лог после цикла");





Оператор continue
Прерывает не весь цикл, а только выполнение текущей итерации. Его используют, если понятно, что на текущей итерации цикла делать 
больше нечего или вообще ничего делать не нужно и пора переходить на следующую итерацию.

Используем цикл для вывода только нечетных чисел. Для чётных i срабатывает continue, выполнение тела прекращается и управление 
передаётся на следующую итерацию.

const number = 10;

for (let i = 0; i < number; i += 1) {
  if (i % 2 === 0) {
    continue;
  }

  console.log("Нечетное i: ", i); // 1, 3, 5, 7, 9
}
*/
