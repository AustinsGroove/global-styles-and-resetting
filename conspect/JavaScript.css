/**
  |============================
  | Подключение скрипта
  |============================
*/
/* Чтобы подключить JavaScript из внешнего файла:

Создайте файл с расширением .js и поместите его в подпапку js.
Затем укажите путь к файлу скрипта в атрибуте src тега script.
Cкрипт подключают перед закрывающим тегом <body> после всего содержимого

<script src="js/script.js"></script> 

Если скрипт подключен в <head>, отрисовка страницы останавливается до тех пор, пока скрипт не загрузится и выполнится полностью.
*/ /**
  |============================
  | Синтаксис
  |============================
*/
/* 
Инструкция (statement) - это связанный набор слов и символов из синтаксиса языка, которые объединяются чтобы выразить одну идею, 
одну инструкцию для машины.
a = b * 2;
    a и b - переменные (как в алгебраическом уравнении), это хранилища данных, которые использует программа. Переменная состоит 
            из идентификатора (имени) и связанного с ним значения.
    2 - просто число. Это называется значением литерала (literal value), так как не хранится в переменной.
    = и * - операторы, производят действия над значениями и переменными.

Инструкции состоят из частей, как в любом языке предложения состоят из фраз, и эти фразы называются выражениями.
Выражение (expression) - ссылка на переменную или значение, или на набор переменных и значений в сочетании с операторами.

Интерфейс - это набор свойств и методов сущности, доступных для использования в исходном коде.

Свойство
У нас с вами есть свойства: рост, вес, цвет глаз, то есть какие-то описательные характеристики. Так же и у данных есть свойства, 
например у строки есть свойство ее длины. Синтаксис обращения к свойству очень простой - через точку.
сущность.имя_свойства
Для наглядности обратимся к свойству строки length, которое содержит кол-во символов строки.
"JavaScript is awesome".length;

Метод
Это вызов действия, например присесть или плавать, то есть какая-то активная операция. Так же и у данных есть свои заранее 
определённые методы, например можно добавить или удалить элементы из коллекции, перевести строку в разный регистр и т. д. 
Синтаксис вызова метода очень похож на обращение к свойству, но в конце добавляется пара круглых скобок.
сущность.имя_метода()
Для примера обратимся к методу строки toUpperCase(), который сделает все буквы заглавными.
"JavaScript is awesome".toUpperCase();

Строгий режим
Новая возможность в спецификации ECMAScript 5, которая позволяет переводить скрипт в режим полного соответствия современному стандарту. 
Это предотвращает определенные ошибки, такие как использование небезопасных и устаревших конструкций.
Для того, чтобы перевести скрипт в строгий режим, достаточно указать директиву в начале js-файла. 
Всегда пишите код в строгом режиме.

script.js
"use strict";
// Это комментарий. Дальше идет весь код JS-файла
*/
/**
  |============================
  | Переменные и типы
  |============================
*/
/* 
Переменные используются для хранения данных и состоят из идентификатора (имени) и области в памяти, где хранится их значение.

Идентификатор - это имя переменной, функции или класса. Состоит из одного или нескольких символов в следующем формате.

Первым символом должна быть буква a-z или A-Z, символ подчеркивания _ или знак доллара $.
Другие символы могут быть буквами a-z, A-Z, цифрами 0-9, подчеркиваниями _ и знаками доллара $.
Идентификаторы чувствительны к регистру. Это значит, что переменные user, usEr и User различны.

Использование camelCase-нотации для идентификаторов это стандарт. Первое слово пишется строчными буквами, а каждое последующее 
начинается с заглавной. Например, user, greetUser, getUserData.

Как называть переменные:
https://bookflow.ru/kak-nazyvat-peremennye/

Есть список зарезервированных ключевых слов, которые имеют специальное значение и используются для определенных конструкций. 
Нельзя использовать ключевые слова как идентификаторы.
abstract	arguments	await	boolean
break	byte	case	catch
char	class	const	continue
debugger	default	delete	do
double	else	enum	eval
export	extends	false	final
finally	float	for	function
goto	if	implements	import
in	instanceof	int	interface
let	long	native	new
null	package	private	protected
public	return	short	static
super	switch	synchronized	this
throw	throws	transient	true
try	typeof	var	void
volatile	while	with	yield

Объявление переменной начинается с ключевого слова const. Такая переменная должна быть сразу инициализирована значением, после 
чего его нельзя переопределить.
Переменные, объявленные как const, обязательно должны быть инициализированы значением во время объявления, иначе будет ошибка.

const yearOfBirth = 2006;

Для того, чтобы объявить переменную, которой в будущем можно будет присвоить новое значение, используется ключевое слово let.
Переменным, объявленным через let, не обязательно сразу присваивать значение.

let age;

Если переменной, объявленной как let, изначально не присвоено значение, она инициализируется специальным значением undefined (не определено).

константы и КОНСТАНТЫ
Имена КОНСТАНТ - переменных, значение которых не изменяется никогда на протяжении работы всего скрипта, обычно записываются 
в формате UPPER_SNAKE_CASE.
Абсолютное большинство переменных – константы в другом смысле, они просто не изменяют значение после присвоения. 
Но при разных запусках скрипта, это значение может быть разным. Имена таких переменных записывают используя формат camelCase.

неопределенные и необъявленные переменные
Неопределенная (undefined) - это переменная, которая была объявлена ключевым слово let, но не инициализирована значением. 
По умолчанию ей присваивается начальное значение undefined.
Необъявленная (undeclared или not defined) - это переменная, которая не была объявлена в доступной области видимости. Попытка обратиться 
к пременной до её объявления вызовет ошибку. Например, чтобы прочитать или изменить её значение.

Примитивные типы
- Number - целые числа и числа с плавающей запятой (точкой).
const age = 20;
- String - строки, последовательность из нуля или более символов. Строка начинается и заканчивается одиночной ', или двойными кавычками ".
const username = "Mango";
- Boolean - логический тип данных, флаги состояния. Всего два значения: true и false. 
const isLoggedIn = true;
- null - особое значение, которое по сути значит ничто. Используется в тех ситуациях, когда необходимо явно указать пустоту. 
К примеру если пользователь ещё ничего не выбрал, то можно сказать что значение null.
let selectedProduct = null;
- undefined - ещё одно специальное значение. По умолчанию, когда переменная объявляется, но не инициализируется, ее значение 
не определено, ей присваивается undefined.
let username;
console.log(username); // undefined

Оператор typeof
Используется для получения типа значения переменной. Возвращает на место своего вызова тип значения переменной указанного после 
него - строку в которой указан тип.
let username;
console.log(typeof username); // "undefined"
let inputValue = null;
console.log(typeof inputValue); // "object"
*/
/**
  |============================
  | Взаимодействие с пользователем
  |============================
*/
/* 
Вывод данных
Для вывода данных есть два метода: console.log() и alert(). 
В круглых скобках указываем имя переменной, значение которой необходимо вывести.
Можно сначала указать какую-то описательную строку, после чего поставить запятую и указать имя переменной.

const username = "Mango";
console.log("Username is ", username);

Метод alert() выводит модальное окно, текст которого соответствует значению переменной (или литерала) которую передадим в скобках.
const message = "JavaScript is awesome!";
alert(message);

Получение данных
Для получения данных от пользователя есть prompt() и confirm(). Это тоже методы из интерфейса window. 
Результатом своего выполнения они возвращают то, что было введено пользователем, поэтому результат их работы можно записать 
в переменную для дальнейшего использования.

confirm() - выводит модальное окно с сообщением, и две кнопки, Ok и Cancel. 
При нажатии на Ok, результатом будет true, при нажатии на Cancel - возвращается false.
const isComing = confirm("Please confirm hotel reservation");
console.log(isComing);

prompt() - выводит модальное окно с полем ввода и кнопками Ok и Cancel. При нажатии Ok, результатом будет то, что ввел пользователь, 
при Cancel - возвращается null.
const hotelName = prompt("Please enter desired hotel name");
console.log(hotelName);
Важная особенность prompt в том, что не зависимо что ввел пользователь, всегда вернется строка. То есть, если пользователь ввел 5, 
то вернется не число 5, а строка "5".
*/
/**
  |============================
  | Основные операторы
  |============================
*/
/* 
Математические операторы
Назначение, функционал и приоритет (порядок) операций ничем не отличаются от школьного курса алгебры. 
Операторы возвращают значение как результат выражения.
Важно запомнить термины составляющих выражения. + - * / % называются операторы, а то, на чем они применяются - операнды.
const x = 10;
const y = 5;
// Сложение
console.log(x + y); // 15
// Вычитание
console.log(x - y); // 5
// Умножение
console.log(x * y); // 50
// Деление
console.log(x / y); // 2
// Остаток от деления
console.log(x % y); // 0
// Сложение с заменой (также есть для всех других операторов)
let value = 5;
// Аналогично записи value = value + 10;
value += 10;
console.log(value); // 15

Операторы сравнения
Используются для сравнения двух значений. Результатом своего выполнения возвращают буль - true или false, то есть «да» или «нет».

a > b и a < b - больше/меньше
a >= b и a <= b - больше/меньше или равно
a == b - равенство
a != b - неравенство
a === b - строгое равенство
a !== b - строгое неравенство

const x = 5;
const y = 10;
const z = 5;

console.log("x > y:", x > y); // false
console.log("x < y:", x < y); // true
console.log("x < z:", x < z); // false
console.log("x <= z:", x <= z); // true
console.log("x === y:", x === y); // false
console.log("x === z:", x === z); // true
console.log("x !== y:", x !== y); // true
console.log("x !== z:", x !== z); // false

«Нестрогие» операторы равенства == и != выполняют преобразование типов сравниваемых значений к числу, что может привести к ошибкам, 
особенно у начинающих.
console.log(5 == "5"); // true
console.log(5 != "5"); // false
На следующей иллюстрации показана таблица сравнения значений используя операторы нестрогого равенства.
https://textbook.edu.goit.global/javascript-yk5evp/v2/img/lesson-01/not-strict-equality.png

Поэтому для проверки равенства или неравенства двух значений используются только операторы === (строгое равенство) и 
!== (строгое неравенство), которые не выполняют приведение типов операндов.
console.log(5 === "5"); // false
console.log(5 === 5); // true
console.log(5 !== "5"); // true
В таком случае, все равно только себе. Перед оценкой ничего не преобразуется.
https://textbook.edu.goit.global/javascript-yk5evp/v2/img/lesson-01/strict-equality.png
*/
/**
  |============================
  | Числа
  |============================
*/
/* 
Все числа в JavaScript, как целые так и дробные, имеют тип Number и записывать их можно не только в десятичной системе счисления.

Приведение к числу
Большинство арифметических операций и математических функций преобразуют значение в число автоматически. 
Для того чтобы сделать это явно, используйте функцию Number(val), передавая ей в val то, что надо привести к числу.
Если значение не возможно привести к числу, результатом будет специальное числовое значение NaN (Not a Number). Аналогичным образом 
происходит преобразование и в других математических операторах и функциях.

const valueA = "5";
console.log(Number(valueA)); // 5
console.log(typeof Number(valueA)); // "number"

const valueB = "random string";
console.log(Number(valueB)); // NaN
console.log(typeof Number(valueB)); // "number"


Методы Number.parseInt() и Number.parseFloat()
Преобразуют строку символ за символом, пока это возможно. При возникновении ошибки возвращается число, которое получилось.

Метод Number.parseInt() парсит из строки целое число.
console.log(Number.parseInt("5px")); // 5
console.log(Number.parseInt("12qwe74")); // 12
console.log(Number.parseInt("12.46qwe79")); // 12
console.log(Number.parseInt("qweqwe")); // NaN

Метод Number.parseFloat() парсит из строки дробное число.
console.log(Number.parseFloat("5px")); // 5
console.log(Number.parseFloat("12qwe74")); // 12
console.log(Number.parseFloat("12.46qwe79")); // 12.46
console.log(Number.parseFloat("qweqwe")); // NaN

Функция Number - преобразует переданное значение в число. 
В случае строки пробельные символы по краям обрезаются, затем, если строку возможно преобразовать в число - то возвращается это число, 
а если нет - возвращается NaN. 
Значение true преобразуется к числу 1, значение false - к числу 0. 
Объекты при численных преобразованиях превращаются в NaN.
 
Преобразуем булевое значение true в число:
Number(true);
Результат выполнения кода:
1
 
А теперь давайте преобразуем булевое значение false:
Number(false);
Результат выполнения кода:
0
 
Давайте в параметр функции введем строку, содержащую число:
Number('53');
В результате преобразования мы получим число:
53
 
А теперь добавим к числу пробелы в начале и в конце строки:
Number(' 5 ');
После выполнения кода лишние пробелы удаляются и в итоге мы получаем число:
5
 
Давайте преобразуем пустую строку:
Number('');
Результат выполнения кода:
0
 
Теперь преобразуем строку, содержащую букву и цифру:
Number('a5');
После выполнения кода получаем значение NaN, показывающее недопустимую математическую операцию:
NaN
 
Давайте поменяем местами в строке букву и цифру:
Number('5a');
Результат выполнения кода останется прежним:
NaN
 
Теперь преобразуем строку, в которой числа разделены пробелом:
Number('5 5');
В результате выполнения кода мы опять увидим, что данная математическая операция недопустима:
NaN
 
Давайте преобразуем булевое значение true, заключенное в строку:
Number('true');
После выполнения кода снова получим NaN:
NaN
 
Теперь преобразуем пустой объект:
Number({});
Результат выполнения кода:
NaN
 
Давайте зададим в параметре функции пустой массив:
Number([]);
В результате мы получим число 0:
0
 
Теперь добавим в массив цифру:
Number([1]);
Массив преобразуется в число:
1
 
Давайте преобразуем массив, включающий две цифры:
Number([1, 2]);
В результате нам снова сообщат, что данная математическая операция недопустима:
NaN



Проверка на число
Для проверки на число можно использовать метод Number.isNaN(val). Он проверяет, является ли указанное значение NaN или нет. 
Метод отвечает на вопрос "Это Not A Number?" и возвращает:
true - если значение val это NaN
false - если значение val это не NaN
Этот метод не производит попытку преобразовать val к числу, а просто выполняет проверку на NaN.

const validNumber = Number("51"); // 51
console.log(Number.isNaN(validNumber)); // false

const invalidNumber = Number("qweqwe"); // NaN
console.log(Number.isNaN(invalidNumber)); // true



Сложение чисел с плавающей точкой

При сложении не целых чисел в JavaScript и других языках программирования, есть особенность. Если кратко, то 0.1 + 0.2 не равно 0.3, 
результат сложения больше чем 0.3. Все от того что машина считает в двоичной системе.
Число 0.1 в двоичной системе счисления - это бесконечная дробь, так как единица на десять в двоичной системе не делится. 
Двоичное значение бесконечных дробей хранится только до определенного знака, поэтому возникает неточность. При сложении 0.1 и 0.2, 
две неточности складываются, получается незначительная, но всё же ошибка в вычислениях.
console.log(0.1 + 0.2 === 0.3); // false
console.log(0.1 + 0.2); // 0.30000000000000004

Конечно, это не означает, что точные вычисления для таких чисел невозможны. Есть несколько методов решения этой проблемы.
Можно сделать их целыми, умножив на N, сложить, а потом результат разделить также на N.
console.log(0.17 + 0.24); // 0.41000000000000003
console.log((0.17 * 100 + 0.24 * 100) / 100); // 0.41
Еще один способ - сложить, а результат отсечь до определённого знака после запятой при помощи метода toFixed().
console.log(0.17 + 0.24); // 0.41000000000000003
console.log((0.17 + 0.24).toFixed(2)); // 0.41




Класс Math
Один из встроенных классов, который предоставляет набор методов для работы с числами.
// Math.floor(num) - возвращает наибольшее целое число, меньшее, либо равное указанному
console.log(Math.floor(1.7)); // 1

// Math.ceil(num) - возвращает наименьшее целое число, большее, либо равное указанному числу.
console.log(Math.ceil(1.2)); // 2

// Math.round(num) - возвращает значение числа, округлённое до ближайшего целого
console.log(Math.round(1.2)); // 1
console.log(Math.round(1.5)); // 2

// Math.max(num1, num2, ...) - возвращает наибольшее число из набора
console.log(Math.max(20, 10, 50, 40)); // 50

// Math.min(num1, num2, ...) - возвращает наименьшее число из набора
console.log(Math.min(20, 10, 50, 40)); // 10

// Math.pow(base, exponent) - возведение в степень 
console.log(Math.pow(2, 4)); // 16

// Math.random() - возвращает псевдослучайное число в диапазоне [0, 1)
console.log(Math.random()); // случайное число между 0 и 1
console.log(Math.random() * (10 - 1) + 1); // псевдослучайное число от 1 до 10

*/

/**
  |============================
  | Строки
  |============================
*/
/* 
Строка - это индексированный набор из нуля или более символов, заключенных в одинарные либо двойные кавычки.
const username = "Mango";
Важно помнить, что индексация элементов строки начинается с нуля. К примеру в строке "JavaScript" буква "J" стоит на позиции с индексом 0.
Содержимое строки нельзя изменить, только прочитать. То есть нельзя взять какой-то символ и заменить его, 
как только строка создана - она такая навсегда. Можно лишь создать целиком новую строку и присвоить в переменную вместо старой.

Конкатенация строк
Если применить оператор + к строке и любому другому типу данных, результатом операции «сложения» будет строка. 
Эта операция называется конкатенация, или сложение строк.
Во время конкатенации, любой тип данных приводится к строке и сшивается со строкой, но есть особенность - последовательность 
записи операндов.
Последовательность операций имеет значение, преобразование типов происходит только в момент операции сложения со строкой, 
до этого момента действуют привычные правила математики.

const message = "Mango " + "is" + " happy";
console.log(message); // Mango is happy
console.log(1 + "2"); // "12"
console.log(1 + "2" + 4); // "124"
console.log(1 + 2 + "4"); // "34"
В последнем примере произошла математическая операция сложения для первых двух чисел 1 и 2, после чего число 3 было преобразовано 
в строку "3" и сшито со строкой "4".



Шаблонные строки
Шаблонные строки это альтернатива конкатенации с более удобным синтаксисом. Шаблонная строка заключена в обратные (косые) 
кавычки вместо двойных или одинарных и может содержать местозаполнители, которые обозначаются знаком доллара и фигурными скобками 
- ${выражение}.

// Используя переменные необходимо составить строку с подставленными значениями
const guestName = "Манго";
const roomNumber = 207;
const greeting =  "Welcome " + guestName + ", your room number is " + roomNumber + "!";
console.log(greeting); // "Welcome Mango, your room number is 207!"

Составлять строки с подставляемыми значениями используя конкатенацию очень неудобно. 
На помощь приходят шаблонные строки и интерполяция.
const guestName = "Манго";
const roomNumber = 207;
const greeting = `Welcome ${guestName}, your room number is ${roomNumber}!`;
console.log(greeting); // "Welcome Mango, your room number is 207!"



Свойство length
Для того чтобы узнать длину строки, то есть количество её символов, у всех строк есть встроенное свойство length, 
значение которого можно получить обратившись к нему через точку после имени переменной или строкового литерала.

const message = "Welcome to Bahamas!";
console.log(message.length); // 19
console.log("There is nothing impossible to him who will try".length); // 47



Методы toLowerCase() и toUpperCase()
Возвращают новую строку в соответствующем регистре, не изменяя оригинальную строку.

const message = "Welcome to Bahamas!";
console.log(message.toLowerCase()); // "welcome to bahamas!"
console.log(message.toUpperCase()); // "WELCOME TO BAHAMAS!"
console.log(message); // "Welcome to Bahamas!"

Чтобы не требовать абсолютно точный ввод можно сделать «нормализацию» введённой пользователем строки, то есть преобразовать 
все её символы в верхний или нижний регистр. Методы строки toLowerCase() и toUpperCase() вернут новую строку в соответствующем 
регистре, не изменяя оригинальную.

const BRAND_NAME = "SAMSUNG";
const userInput = "saMsUng";
const normalizedToUpperCaseInput = userInput.toUpperCase();

console.log(userInput); // 'saMsUng'
console.log(userInput === BRAND_NAME); // false
console.log(normalizedToUpperCaseInput); // 'SAMSUNG'
console.log(normalizedToUpperCaseInput === BRAND_NAME); // true



Метод indexOf()
Возвращает позицию (индекс) на которой находится первое совпадение подстроки или -1, если ничего не найдено.
const message = "Welcome to Bahamas!";
console.log(message.indexOf("to")); // 8
console.log(message.indexOf("hello")); // -1



Метод includes()
Проверяет входит ли подстрока в строку, возвращает буль - true если входит и false в противном случае. 
Регистр символов в строке и подстроке имеет значение, так как например буква "a" не равна букве "А".

const productName = "Ремонтный дроид";
console.log(productName.includes("н")); // true
console.log(productName.includes("Н")); // false
console.log(productName.includes("дроид")); // true
console.log(productName.includes("Дроид")); // false
console.log(productName.includes("Ремонтный")); // true
console.log(productName.includes("ремонтный")); // false



Метод endsWith()
Позволяет определить, заканчивается ли строка символами (подстрокой) указанными в скобках, возвращая true или false.
const jsFileName = "script.js";
console.log(jsFileName.endsWith(".js")); // true
const cssFileName = "styles.css";
console.log(cssFileName.endsWith(".js")); // false



Методы replace() и replaceAll()
Возвращают новую строку, в которой первое (replace) или все совпадения (replaceAll) подстроки заменены на указанное значение.

const jsFileName = "script.js";
const minifiedJsFileName = jsFileName.replace(".js", ".min.js");
console.log(minifiedJsFileName); // "script.min.js"

const cssFileNames = "styles.css, about.css, portfolio.css";
const minifiedCssFileNames = cssFileNames.replaceAll(".css", ".min.css");
console.log(minifiedCssFileNames); // "styles.min.css, about.min.css, portfolio.min.css"



Метод slice()
Метод строк slice(startIndex, endIndex) используется для создания копии части или всей строки. 
Он делает копию элементов строки от startIndex и до, но не включая endIndex и возвращает новую строку, не изменяя оригинал.

const productName = "Repair droid";
console.log(productName.slice(0, 4)); // "Repa"
console.log(productName.slice(3, 9)); // "air dr"
console.log(productName.slice(0, productName.length)); // "Repair droid"
console.log(productName.slice(7, productName.length)); // "droid"
*/

/**
  |============================
  | Логические операторы
  |============================
*/
/* 
Логические операторы используются для проверки условий с множественными выражениями, например в операциях сравнения.

Приведение типов
В логических операциях осуществляется приведение типов операндов к true или false. 
Приведение происходит если в коде обнаружен логический оператор.
Truthy и Falsy - термины, которые используются для тех значений, которые, в логической операции, приводятся к true или false, 
хотя изначально не были булями.



Логическое «И»
Оператор && приводит все операнды к булю и возвращает значение одного из них. 
Левый операнд если его можно привести к false, и правый в остальных случаях.

выражение && выражение

В следующем примере оба условия вернут true, поэтому результатом всего выражения будет true - вернётся значение правого операнда.
const age = 20;
console.log(age > 10 && age < 30); // true && true -> true
Если хотябы один из операндов будет приведён к false, результатом выражения будет его значение.

const age = 50;
console.log(age > 10 && age < 30); // true && false -> false
console.log(age > 80 && age < 120); // false && true -> false
То есть логическое «И» запинается на лжи и возвращает то на чём запнулось или последний операнд.

console.log(1 && 5); // true && true -> 5
console.log(5 && 1); // true && true -> 1
console.log(0 && 2); // false && true -> 0
console.log(2 && 0); // true && false -> 0
console.log("" && "Mango"); // false && true -> ""
console.log("Mango" && ""); // true && false -> ""
console.log("Mango" && "Poly"); // true && true -> "Poly"
console.log("Poly" && "Mango"); // true && true -> "Mango"



Логическое «ИЛИ»
Оператор || приводит все операнды к булю и возвращает значение одного из них. 
Левый операнд если его можно привести к true, и правый в остальных случаях.

выражение || выражение

В следующем примере условие слева вернёт true, поэтому результатом всего выражения будет true - вернётся значение первого операнда 
которое было приведено к true.
const age = 5;
console.log(age < 10 || age > 30); // true || false -> true

Тут результатом тоже будет true, так как хотябы один из операндов, в этом случае правый, был приведён к true.
const age = 40;
console.log(age < 10 || age > 30); // false || true -> true

А здесь ни одно из условий не выполняется, поэтому получаем false - значение последнего операнда.
const age = 20;
console.log(age < 10 || age > 30); // false || false -> false

То есть логическое «ИЛИ» запинается на правде и возвращает то на чём запнулось или последний операнд.

console.log(true || false); // true
console.log(false || true); // true
console.log(true || true); // true

console.log(3 || false); // 3
console.log(false || 3); // 3
console.log(3 || true); // 3
console.log(true || 3); // true



Оператор нулевого слияния ??

Аналогичен оператору "ИЛИ" ||, но в качестве false воспринимает только null и undefined
То есть это логический оператор, возвращающий значение правого операнда, если значение левого операнда содержит null или undefined, 
в противном случае возвращается значение левого операнда.



Логическое «НЕ»
Все операторы которые мы рассматривали до этого были бинарными - содержащими два операнда, левый и правый. 
Логическое «НЕ» это унарный оператор - выполняющий операцию над одним операндом справа.

!выражение

Оператор ! приводит операнд к булю, если необходимо, а затем делает инверсию - заменяет его на противоположный 
true -> false или false -> true.

console.log(!true); // false
console.log(!false); // true
console.log(!3); // !3 -> !true -> false
console.log(!"Mango"); // !"Mango" -> !true -> false
console.log(!0); // !0 -> !false -> true
console.log(!""); // !"" -> !false -> true

const isOnline = true;
const isNotOnline = !isOnline; // !isOnline -> !true -> false
*/
/**
  |============================
  | Ветвления
  |============================
*/
/* 
Ветвления используются для выполнения различного кода в зависимсти от условия. Принцип работы простой - результат условия 
приводится к булю true или false, после чего поток программы направляется в ту или иную ветку.



Инструкция if
Входные данные, которые приводятся к булю называются условием. Условие помещают за оператором if в круглых скобках. 
Если условие приводится к true, то выполняется код в фигурных скобках тела if.
Если условие приводится к false, код в фигурных скобках будет пропущен.

let cost = 0;
const subscription = "pro";
if (subscription === "pro") {
  cost = 100;
}
console.log(cost); // 100

let cost = 0;
const subscription = "free";
if (subscription === "pro") {
  cost = 100;
}
console.log(cost); // 0



Инструкция if...else
Расширяет синтаксис if тем, что в случае если условие приводится к false, выполнится код в фигурных скобках после оператора else.
Если условие приводится к true, тело блока else игнорируется.

let cost;
const subscription = "free";
if (subscription === "pro") {
  cost = 100;
} else {
  cost = 0;
}
console.log(cost); // 0

let cost;
const subscription = "pro";
if (subscription === "pro") {
  cost = 100;
} else {
  cost = 0;
}
console.log(cost); // 100



Инструкция else...if
Конструкция if...else может проверить и среагировать на выполнение или невыполнение только одного условия.
Блок else...if позволяет добавить после else еще один оператор if с условием. В конце цепочки может быть классический блок else, 
который выполнится только в случае, когда ни одно из условий не приведётся к true.
При первом же true проверки прекратятся и выполнится только один сценарий, соответствующий этому true. 
Поэтому подобную запись следует читать как: ищу первое совпадение условия, игнорирую все остальное.

let cost;
const subscription = "premium";

if (subscription === "free") {
  cost = 0;
} else if (subscription === "pro") {
  cost = 100;
} else if (subscription === "premium") {
  cost = 500;
} else {
  console.log("Invalid subscription type");
}

console.log(cost); // 500
*/

/**
  |============================
  | Тернарный оператор
  |============================
*/
/* 
Тернарный оператор используется как более синтаксически краткая замена инструкции if...else, когда одной и той же переменной 
необходимо присвоить разные значения по условию.

<условие> ? <выражение_если_условие_истинно> : <выражение_если_условие_ложно>

Работает по такой схеме:
Вычисляется условие.
Если условие истинно, то есть приводится к true, вычисляется выражение после ?.
Если условие ложно, то есть приводится к false, вычисляется выражение после :.
Значение вычисленного выражения возвращается как результат работы тернарного оператора.

Тернарный оператор должен использоваться в простых операциях присваивания или возврата. 
го использование для описания сложных ветвлений - плохая практика (антипаттерн).

let type;
const age = 20;
if (age >= 18) {
  type = "adult";
} else {
  type = "child";
}
console.log(type); // "adult"

Выполним рефакторинг заменив if...else тернарным оператором.

const age = 20;
const type = age >= 18 ? "adult" : "child";
console.log(type); // "adult"

Запишем операцию поиска большего числа.

const num1 = 5;
const num2 = 10;
let biggerNumber;
if (num1 > num2) {
  biggerNumber = num1;
} else {
  biggerNumber = num2;
}
console.log(biggerNumber); // 10

Код работает верно, получаем большее число из двух, но это решение кажется слишком громоздким, учитывая, насколько проста проблема. 
Используем тернарный оператор.

const num1 = 5;
const num2 = 10;
const biggerNumber = num1 > num2 ? num1 : num2;

console.log(biggerNumber); // 10
*/

/**
  |============================
  | Инструкция switch
  |============================
*/
/* 
В некоторых случаях неудобство чтения сложных ветвлений if...else можно избежать используя более «плоский» синтаксис инструкции 
ветвления switch.
Область применения switch ограничена задачами с одним общим вопросом (что сравнивать) и множеством вариантов ответов (с чем сравнивать).
Его синтаксис состоит из блока switch(значение) - что нужно сравнить и множества отдельных случаев case значение - с чем нужно сравнить. 
Для сравнения используется оператор строгого равенства ===. То есть нельзя сравнить на больше или меньше, только на равенство.

switch (значение) {
  case значение:
    инструкции;
    break;
  case значение:
    инструкции;
    break;
  default:
    инструкции;
}

Значение в блоке switch(значение) - строка или число, которое сравнивается на строгое равенство со всеми значениями в блоках case 
значение по порядку, сверху вниз.
Оператор break в завершении каждого блока case необходим чтобы прервать дальнейшие проверки и сразу перейти к коду за switch 
в том случае, когда проверка на равенство вернула true.
Если оператор break будет отсутствовать, то после того как выполнится какое-то условие case, все последующие за ним блоки кода будут 
ыполняться один за другим, что может привести к нежелательным последствиям при неверном применении.
Если ни одного совпадения значений не произошло, необходимо выполнить код по умолчанию, как в блоке else для инструкции if...else. 
Для этого после всех блоков case добавляется блок default. Оператор break после блока default не нужен, так как это и так последнее 
что будет выполнено в switch и управление будет передано коду за ним.

let cost;
const subscription = "premium";

switch (subscription) {
  case "free":
    cost = 0;
    break;

  case "pro":
    cost = 100;
    break;

  case "premium":
    cost = 500;
    break;

  default:
    console.log("Invalid subscription type");
}

console.log(cost); // 500
*/

/**
  |============================
  | Паттерн switch(true)
  |============================
*/
/* 
let value = 10;
switch(true) {
  case value > 5:
    // always do this
    break;
  case value > 15:
    // unreachable
  default:
    // unreachable
}
*/

/**
  |============================
  | Область видимости
  |============================
*/
/* 
------ Глобпльная и локальная (блочная) области видимости -----
Область видимости (scope) - механизм который определяет доступность переменных в исполняемом коде.

Область видимости переменных (variable scope) - доступность переменных в определённом месте кода.

Цепочка областей видимости (scope chain) - области видимости образуют иерархию, так что дочерние области имеют доступ к переменным из родительских областей, 
но не наоборот.

Глобальная область видимости используется по умолчанию. Все и вся имеют доступ к переменным объявленным в ней.
Переменные, объявленные на самом верхнем уровне, то есть вне любых конструкций вроде if, while, for и функций, находятся в глобальной области видимости 
и доступны везде после их объявления.
Например, переменная value объявлена в глобальной области видимости, то есть вне какого-то блока, и доступна в любом месте 
после объявления.

const value = 5;
if (true) {
  console.log("Block scope: ", value); // 5
}

console.log("Global scope: ", value); // 5

Переменные, объявленные внутри инструкций if, for, функций и других блоков кода обрамлённых фигурными скобками {}, находятся в 
блочной области видимости и доступны только внутри этого блока кода или вложенных в него.
Любая конструкция использующая фигурные скобки {} (условия, циклы, функции и т. п.) создает новую локальную область видимости, 
и переменные, объявленные в этой области видимости, используя let или const, не доступны вне этого блока.

if (true) {
  const value = 5;
  console.log("Block scope: ", value); // 5
}

console.log("Global scope: ", value); // ReferenceError: value is not defined

Глубина вложенности областей видимости не ограничена, и все они будут работать по одному принципу - область видимости имеет доступ 
ко всем переменным объявленным выше по иерархии вложенности, но не может получить доступ к переменным объявленным во вложенных 
областях видимости.




----- Поиск по цепочке областей видимости -----
Интерпретатор пытается сначала найти переменную в той области видимости, в которой к ней обратились. Если такой переменной в локальной области видимости нет, 
то он выходит наружу, на один уровень за попытку, пока не найдёт значение или не дойдет до самой верхней области видимости (глобальной) и поймет, 
что переменную с таким идентификатором невозможно найти, так как ее просто нет, тогда будет ошибка о том, что переменная не объявлена.




------ Глобальная и функциональная области видимости -----
var не имеет блочной области видимости
Как мы видели в предыдущих примерах, блок кода создает область видимости для переменных, объявленных с помощью ключевых слов const и let. 
Однако это не работает для переменных, объявленных с помощью ключевого слова var.

Рассмотрим пример:
if (true) {
    // область видимости блока if
    var count = 0
    console.log(count) // 0
}
console.log(count) // 0

Переменная count, как и ожидалось, доступна внутри блока if. Однако, она доступна и за пределами данного блока!
Дело в том, что блок кода не создает области видимости для переменных, объявленных с помощью ключевого слова var. Но это делает функция.

Область видимости функции
Функции в JavaScript создают область видимости для всех переменных, независимо от того, с помощью какого ключевого слова они объявлены (var, const или let).

Например:

function run() {
    // область видимости функции run()
    var message = 'Беги, Форрест, беги!'
    console.log(message)
}
run() // 'Беги, Форрест, беги!'
console.log(message) // ReferenceError

Функция run() создает область видимости. Переменная message доступна внутри функции, но недоступна снаружи.



----- Инициализация в разных областях видимости -----
Попытка присвоеить значение переменной до ее инициализации выдаст ошибку.

let a;
if (true) {
  a = 10;
  let a; // ReferenceError: Cannot access "a" before initialization
} 

В данном примере инициализируется глобальная переменная а. Затем внутри блока if  инициализируется локальная переменная a, но перед этим производится попытка
присвоить ей значение а = 10, что выдаст ошибку.






*/

/**
  |============================
  | Циклы
  |============================
*/
/* 
Цикл - управляющая конструкция в высокоуровневых языках программирования, предназначенная для организации многократного 
исполнения набора инструкций.
Тело цикла - последовательность инструкций, предназначенная для многократного исполнения.
Итерация - единичное выполнение тела цикла.
Условие выхода - выражение, определяющее будет в очередной раз выполняться итерация, или цикл завершится.
Счётчик - переменная, хранящая текущий номер итерации. Цикл не обязательно содержит счётчик, и он не обязан быть один, 
условие выхода из цикла может зависеть от нескольких изменяемых в цикле переменных.




Цикл while
Цикл с предусловием — цикл, который выполняется пока истинно некоторое условие, указанное перед его началом. 
Это условие проверяется до выполнения тела цикла, поэтому тело может быть не выполнено ни разу, если условие с самого начала ложно.

while (condition) {
  // код, тело цикла (statement)
}

Конструкция while создает цикл, который выполняет блок кода, пока условие проверки оценивается как true.
condition, то есть условие, вычисляется перед каждой итерацией цикла.
Если condition оценивается как true, оператор while выполняет statement.
Если condition оценивается как false, выполнение цикла прерывается и скрипт продолжает выполнять инструкции после цикла while.

Сделаем счетчик.

let counter = 0;
while (counter < 10) {
  console.log("counter: ", counter);
  counter += 1;
}

Будем заполнять места в отеле до тех пор пока текущее количество клиентов не будет равно максимально допустимому.

let clientCounter = 18;
const maxClients = 25;
while (clientCounter < maxClients) {
  console.log(clientCounter);
  clientCounter += 1;
}




Цикл do...while
Цикл с постусловием - цикл, в котором условие проверяется после выполнения тела цикла. Отсюда следует, что тело всегда выполняется 
хотя бы один раз.

do {
  // statement
} while (condition);

Конструкция do...while создает цикл, который выполняет блок кода до тех пор, пока condition не вернёт false.
В отличие от цикла while, цикл do...while всегда выполняет statement как минимум один раз, прежде чем он оценит condition.
Внутри цикла нужно внести изменения в некоторую переменную, чтобы убедиться, что выражение равно false после итераций. 
В противном случае будет бесконечный цикл.

let password = "";
do {
  password = prompt("Введите пароль длиннее 4-х символов", "");
} while (password.length < 5);

console.log("Ввели пароль: ", password);




Цикл for
Цикл со счётчиком - цикл, в котором некоторая переменная изменяет своё значение от заданного начального до конечного значения 
с некоторым шагом и для каждого значения этой переменной тело цикла выполняется один раз.

В большинстве процедурных языков программирования реализуется конструкцией for, в которой указывается счётчик, требуемое 
количество итераций и шаг, с которым изменяется счётчик.

for (initialization; condition; post-expression) {
  // statements
}

Алгоритм исполнения цикла for:

Инициализация (initialization) - выполняется один раз перед началом цикла. Используется для создания переменной-счётчика и указания 
её начального значения.
Условие (condition) - выражение, оцениваемое перед каждой итерацией (повторением) цикла. Тело цикла выполняется только тогда, 
когда выражение приводится к true. Цикл завершается, если значение будет false.
Тело (statements) - набор инструкций для выполнения на каждом повторении. Выполняется если выражение условия приводится к true.
Пост-выражение (post-expression) - выполняется в конце каждого повторения цикла, перед проверкой условия. Используется для 
обновления переменной-счётчика.
Переменные-счетчики, по традиции, называются буквами i, j и k.

for (let i = 0; i <= 20; i += 5) {
  console.log(i);
}

В примере объявляется перемнная-счетчик i, инициализируется значением 0 и цикл выполняется до тех пор, пока i <= 20, то есть 
условие приводится к true. После каждой итерации счётчик увеличивается на 5.

Посчитаем сумму чисел до определенного значения.

const target = 3;
let sum = 0;

for (let i = 0; i <= target; i += 1) {
  sum += i;
}

console.log(sum);

Вспомним про операцию a % b и выведем остаток от деления используя цикл.

const max = 10;
for (let i = 0; i < max; i += 1) {
  console.log(`${max} % ${i} = `, max % i);
}




Оператор break
Прервать выполнение цикла можно в любой момент. Для этого сущестует оператор break, который полностью прекращает выполнение цикла 
и передаёт управление на строку за его телом.

Найдём число 3. Как только выполнится условие if, цикл прекратит своё выполнение (будет прерван).

for (let i = 0; i <= 5; i += 1) {
  console.log(i);

  if (i === 3) {
    console.log("Нашли число 3, прерываем выполнение цикла");
    break;
  }
}

console.log("Лог после цикла");





Оператор continue
Прерывает не весь цикл, а только выполнение текущей итерации. Его используют, если понятно, что на текущей итерации цикла делать 
больше нечего или вообще ничего делать не нужно и пора переходить на следующую итерацию.

Используем цикл для вывода только нечетных чисел. Для чётных i срабатывает continue, выполнение тела прекращается и управление 
передаётся на следующую итерацию.

const number = 10;

for (let i = 0; i < number; i += 1) {
  if (i % 2 === 0) {
    continue;
  }

  console.log("Нечетное i: ", i); // 1, 3, 5, 7, 9
}
*/

/**
  |============================
  | Массивы
  |============================
*/
/* 
Массив - структура данных для хранения и манипулирования коллекцией индексированных значений.

Создание
Массив объявляется открывающей и закрывающей квадратной скобками [] - литералом массива. 
Внутри скобок каждый элемент массива разделяется запятой.

const clients = ["Mango", "Poly", "Ajax"];

Доступ к элементам
Для доступа к значению элемента массива используется синтаксис квадратных скобок массив[индекс]. 
Между именем переменной хранящей массив и квадратными скобками не должно быть пробела.
Индексация элементов массива начинается с нуля.

const clients = ["Mango", "Poly", "Ajax"];

// Указывая в скобках индекс элемента мы получаем его значение
console.log(clients[0]); // Mango
console.log(clients[1]); // Poly
console.log(clients[2]); // Ajax



Переопределение
В отличии от строк, элементы массива можно изменять обратившись к ним по индексу и присвоив другое значение.

const clients = ["Mango", "Poly", "Ajax"];
clients[0] = "Kiwi";
clients[1] = "Pango";




Длина массива
Длина массива, то есть число его элементов, хранится в свойстве length. 
Это динамическая величина, которая изменяется автоматически при добавлении или удалении элементов.

const clients = ["Mango", "Poly", "Ajax"];
console.log(clients.length); // 3




Индекс последнего элемента
Чаще всего мы заранее в коде не знаем какая будет длина массива. 
Для того чтобы получить значение последнего элемента применяется следующий подход - длина массива всегда на единицу больше 
чем индекс последнего элемента. Используя формулу длина_массива - 1 можно получить значение последнего элемента массива 
произвольной длины.

const clients = ["Mango", "Poly", "Ajax"];
const lastElementIndex = clients.length - 1;
console.log(lastElementIndex); // 2
console.log(clients[lastElementIndex]); // "Ajax"

*/

/**
  |============================
  | Итерация по массиву
  |============================
*/
/* 
Цикл for можно использовать для итерации по массиву, то есть «перебрать» его поэлементно.

const clients = ["Mango", "Ajax", "Poly"];

for (let i = 0; i < clients.length; i += 1) {
  console.log(clients[i]);
}
*/

/**
  |============================
  | Цикл for...of
  |============================
*/
/* 
Конструкция for...of объявляет цикл, перебирающий итерируемые объекты, такие как массивы и строки. 
Тело цикла будет выполняться для значения каждого элемента. Это хорошая замена циклу for если не нужен доступ к счётчику итерации.

for (const variable of iterable) {
  // тело цикла
}

variable — переменная которая будет хранить значение элемента на каждой итерации.
iterable — коллекция, которая имеет перечислимые элементы, например массив.

const clients = ["Mango", "Ajax", "Poly"];

for (const client of clients) {
  console.log(client);
}

const string = "javascript";

for (const character of string) {
  console.log(character);
}
*/

/**
  |============================
  | Операторы break и continue
  |============================
*/
/* 
Будем искать имя клиента в массиве имен, если нашли - прервем цикл, так как нет смысла искать дальше, имена у нас уникальные.

const clients = ["Mango", "Poly", "Ajax"];
const clientNameToFind = "Poly";
let message;

for (const client of clients) {
  // На каждой итерации будем проверять совпадает ли элемент массива с
  // именем клиента. Если совпадает то мы записываем в message сообщение
  // об успехе и делаем break чтобы не искать дальше
  if (client === clientNameToFind) {
    message = "Клиент с таким именем есть в базе данных!";
    break;
  }

  // Если они не совпадают то запишем в message сообщение об отсутствии имени
  message = "Клиента с таким именем нету в базе данных!";
}

console.log(message); // "Клиент с таким именем есть в базе данных!"

Можно изначально задать message значение неудачи поиска, а в цикле перезаписать его на успех, если нашли имя. 
Но break все равно пригодится, так как если у нас массив из 10000 клиентов, а нужный нам стоит на позиции 2, то нет абсолютно 
никакого смысла перебирать оставшиеся 9998 элементов.

const clients = ["Mango", "Poly", "Ajax"];
const clientNameToFind = "Poly";
let message = "Клиента с таким именем нету в базе данных!";

for (const client of clients) {
  if (client === clientNameToFind) {
    message = "Клиент с таким именем есть в базе данных!";
    break;
  }
  // Если не совпадает, то на этой итерации ничего не делаем
}

console.log(message); // Клиент с таким именем есть в базе данных!

Используем цикл для вывода только чисел больше определенного значения.

const numbers = [1, 3, 14, 18, 4, 7, 29, 6, 34];
const threshold = 15;

// Для чисел меньше чем порог срабатывает continue, выполнение тела прекращается
// и управление передаётся на следующую итерацию.
for (let i = 0; i < numbers.length; i += 1) {
  if (numbers[i] < threshold) {
    continue;
  }

  console.log(`Число больше чем ${threshold}: ${numbers[i]}`); // 18, 29, 34
}
*/

/**
  |============================
  | Присвоение по ссылке и по значению
  |============================
*/
/* 
Фундаментальным отличием сложных типов от примитивов, является то, как они хранятся и копируются. 
Примитивы: строки, числа, були,null и undefined, при присваивании копируются целиком, по значению (by value).
Все примитивные типы присваиваются по значению, то есть создается копия.
let a = 5;
let b = a;
a = 10;
console.log(a); // 10
console.log(b); // 5

Со сложными типами всё не так. В переменной, которой присвоен массив или объект, хранится не само значение, а адрес его места в памяти, иными словами - ссылка 
(указатель) на него и передаются они по ссылке (by reference).
Сложные типы - объекты, массивы, функции присваиваются по ссылке, то есть переменная просто получает ссылку на уже существующий объект.
const a = ["Mango"];
const b = a;
a.push("Poly");
console.log(a); // ["Mango", "Poly"]
console.log(b); // ["Mango", "Poly"]
*/

/**
  |============================
  | Методы массива
  |============================
*/
/* 
split(delimiter) превращает строку в массив, «разбив» её по разделителю delimiter. Если разделитель это пустая строка, то получится массив отдельных символов. Разделителем может быть один или несколько символов.

const name = "Mango";
console.log(name.split("")); // ["M", "a", "n", "g", "o"]
const message = "JavaScript это интересно";
console.log(message.split(" ")); // ["JavaScript", "это", "интересно"]





join(delimiter) соединяет элементы массива в строку. В строке элементы будут разделены символом или группой символов указанных в delimiter. 
То есть это операция обратная методу строк split(delimiter).

const words = ["JavaScript", "это", "интересно"];
console.log(words.join("")); // "JavaScriptэтоинтересно"
console.log(words.join(" ")); // "JavaScript это интересно"
console.log(words.join("-")); // "JavaScript-это-интересно"





indexOf(value) возвращает первый индекс, в котором элемент со значением value был найден в массиве, или число -1, если такого элемента нет. 
Используйте indexOf тогда, когда необходимо получить непосредственно индекс элемента.

const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.indexOf("Poly")); // 2
console.log(clients.indexOf("Monkong")); // -1





includes(value) проверяет есть ли в массиве элемент со значением value и возвращает true или false соответственно. 
Область применения этого метода сводится к ситуациям когда необходимо проверить есть ли элемент в массиве и не важна его позиция (индекс).

const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.includes("Poly")); // true
console.log(clients.includes("Monkong")); // false





Проверка множественных условий с includes()
const fruit = "apple";
if (
  fruit === "apple" ||
  fruit === "strawberry" ||
  fruit === "cherry" ||
  fruit === "cranberries"
) {
  console.log("It is a red fruit!");
}

Можем переписать условие используя метод includes(), это очень просто и масштабируемо.

const redFruits = ["apple", "strawberry", "cherry", "cranberries"];
const fruit = "cherry";

const hasFruit = redFruits.includes(fruit);
if (hasFruit) {
  console.log(`${fruit} is a red fruit!`);
}





Методы push() и pop()
Добавляют или удаляют крайние элементы массива. Работают с крайним левым и крайним правым элементом и не могут поставить или удалить элемент с произвольной позиции.

Метод push() добавляет один или несколько элементов в конец массива, без необходимости указывать индексы добавляемых элементов. 
Возвращает длину массива после добавления элементов.

const numbers = [];
numbers.push(1);
console.log(numbers); // [1]
numbers.push(2);
console.log(numbers); // [1, 2]
numbers.push(3);
console.log(numbers); // [1, 2, 3]

Метод pop() удаляет последний элемент из конца массива и возвращает удаленный элемент. Если массив пустой, метод возвращает undefined.

const numbers = [1, 2, 3, 4, 5];

console.log(numbers.pop()); //  5
console.log(numbers); // [1, 2, 3, 4]
console.log(numbers.pop()); //  4
console.log(numbers); // [1, 2, 3]
console.log(numbers.pop()); //  3
console.log(numbers); // [1, 2]




Метод slice()
slice(begin, end) возвращает новый массив, содержащий копию части исходного массива, не изменяя его. 
Копия делается от begin и до, но не включая, end - индексы элементов исходного массива.

const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.slice(1, 3)); // ["Ajax", "Poly"]

Если begin и end не указаны, будет создана полная копия исходного массива.

Если не указан end, копирование будет от start и до конца исходного массива.
const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.slice(1)); // ["Ajax", "Poly", "Kiwi"]

Если значение start отрицательное, а end не указан, то будут скопированы последние start элементов
const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.slice(-2)); // ["Poly", "Kiwi"]





Метод splice()
Швейцарский нож для работы с массивами, если исходный массив нужно изменить. Удаляет, добавляет и заменяет элементы в произвольном месте массива.



Удаление
Чтобы удалить элементы в массиве, передаются два аргумента.

splice(position, num)

position - указывает позицию (индекс) первого элемента для удаления
num - определяет количество удаляемых элементов

! Метод splice изменяет исходный массив и возвращает массив, содержащий удаленные элементы. !
Например, у нас есть массив оценок, который содержит пять чисел от 1 до 5.

const scores = [1, 2, 3, 4, 5];

// Удаляем три элемента массива, начиная с первого элемента (индекс 0)
const deletedScores = scores.splice(0, 3);

// Теперь массив scores содержит два элемента
console.log(scores); // [4, 5]

// А массив deletedScores содержит три удаленных элемента
console.log(deletedScores); // [1, 2, 3]



Добавление
Для того чтобы добавить один или несколько элементов в массив, необходимо передать три или более аргумента, при этом второй аргумент должен быть равен нулю.

splice(position, 0, new_element_1, new_element_2, ...)

Аргумент position указывает начальную позицию в массиве, куда будут вставлены новые элементы.
Второй аргумент это ноль, он говорит методу не удалять элементы в месте добавления новых.
Третий, четвертый и все последующие аргументы - это новые элементы, которые добавляются в массив.
Например, у нас есть массив с названиями цветов в виде строк. Добавим новый цвет перед элементом с индексом 2.

const colors = ["red", "green", "blue"];

colors.splice(2, 0, "purple");
console.log(colors); // ["red", "green", "purple", "blue"]

На рисунке показан вызов метода colors.splice(2, 0, 'purple') из примера.



Замена
Замена это операция добавления в которой удаляются элементы в месте добавления новых. Для этого необходимо передать минимум три аргумента. 
Количество удаляемых и добавляемых элементов может не совпадать.

splice(position, num, new_element_1, new_element_2, ...)

position - указывает позицию (индекс) первого элемента для удаления
num - определяет количество удаляемых элементов
Третий, четвертый и все последующие аргументы - это новые элементы, которые добавляются в массив.
например, у нас есть массив языков программирования из четырех элементов.

const languages = ["C", "C++", "Java", "JavaScript"];

// Заменяем элемент с индексом 1 на новый
languages.splice(1, 1, "Python");
console.log(languages); // ["C", "Python", "Java", "JavaScript"]

// Заменяем один элемент (с индексом 2) на несколько
languages.splice(2, 1, "C#", "Swift", "Go");
console.log(languages); // ["C", "Python", "C#", "Swift", "Go", "JavaScript"]





Метод concat()
Объединяет два или более массива в один. Он не изменяет массив на котором вызывается, а возвращает новый. 
Порядок аргументов метода влияет на порядок элементов нового массива.

const oldClients = ["Mango", "Ajax", "Poly", "Kiwi"];
const newClients = ["Monkong", "Singu"];

const allClientsWithOldFirst = oldClients.concat(newClients);
console.log(allClientsWithOldFirst); // ["Mango", "Ajax", "Poly", "Kiwi", "Monkong", "Singu"]

const allClientsWithNewFirst = newClients.concat(oldClients);
console.log(allClientsWithNewFirst); // ["Monkong", "Singu", "Mango", "Ajax", "Poly", "Kiwi"]

console.log(oldClients); // ["Mango", "Ajax", "Poly", "Kiwi"]
console.log(newClients); // ["Monkong", "Singu"]
*/

/**
  |============================
  | Функции
  |============================
*/
/* 
Функция - это подпрограмма, независимая часть кода, предназначенная для многократного выполнения конкретной задачи с разными начальными значениями. 
Функции позволяют структурировать большие программы, уменьшают повторение и изолируют код.
Функцию можно представить как чёрный ящик, она получает что-то на входе (данные), и возвращает что-то на выходе (результат выполнения кода внутри неё).

Объявление функции (function declaration) начинается с ключевого слова function, за которым идёт её имя - глагол отвечающий на вопрос «Что сделать?» 
и пара круглых скобок.
Тело функции заключено в фигурные скобки {} и содержит инструкции которые необходимо выполнить при её вызове. 
Затем, когда необходимо, функция вызывается с помощью имени и пары круглых скобок.

// 1. Объявление функции multiply
function multiply() {
  // Тело функции
  console.log("Это лог при вызове функции multiply");
}
// 2. Вызовы функции multiply
multiply(); // 'Это лог при вызове функции multiply'



Параметры и аргументы
В круглых скобках после имени функции идут параметры - перечисление данных которые функция ожидает при вызове.

// Объявление параметров x, y, z
function multiply(x, y, z) {
  console.log(`Результат умножения равен ${x * y * z}`);
}

Параметры это локальные переменные доступные только в теле функции. Они разделяются запятыми. Параметров может быть несколько, или вообще не быть, 
тогда записываются просто пустые круглые скобки.
Параметры будут создаваться заново каждый раз при вызове функции, и их отдельные инкарнации никак друг с другом не связаны.

При вызове функции, в круглых скобках можно передать аргументы - значения для объявленных параметров функции.

// 1. Объявление параметров x, y, z
function multiply(x, y, z) {
  console.log(`Результат умножения равен ${x * y * z}`);
}
// 2. Передача аргументов
multiply(2, 3, 5); // Результат умножения равен 30
multiply(4, 8, 12); // Результат умножения равен 384
multiply(17, 6, 25); // Результат умножения равен 2550

Порядок передачи аргументов должен соответствует порядку объявленых параметров: значение первого аргумента будет присвоено первому параметру, 
второго аргумента второму параметру и т. д. Если параметров будет больше чем аргументов, то параметрам без значений будет присвоено undefined.



Оператор return используется для передачи значения из тела функции во внешний код. 
Когда интерпретатор встречает return, он сразу же выходит из функции (прекращает её выполнение), и возвращает указанное значение в то место кода, 
где функция была вызвана.

function multiply(x, y, z) {
  console.log("Код до return выполняется как обычно");
  // Возвращаем результат выражения умножения
  return x * y * z;
  console.log("Этот лог никогда не выполнится, он стоит после return");
}
// Результат работы функции можно сохранить в переменную
let result = multiply(2, 3, 5);
console.log(result); // 30

Оператор return без явно указанного значения возвращает специальное значение undefined.
При отсутствии return в теле функции, она все равно вернёт undefined.



Порядок выполнения кода
Когда интерпретатор встречает вызов функции (или метода), он приостанавливает выполнение текущего кода и начинает выполнять код из тела функции. 
После того как весь код функции будет выполнен, интерпретатор выходит из тела функции, возвращаясь в то место, откуда пришел и продолжает выполнять код, 
следующий после вызова функции.

function multiply(x, y, z) {
  console.log(`Результат умножения равен ${x * y * z}`);
}
console.log("Лог до вызова функции multiply");
multiply(2, 3, 5); // Результат умножения равен 30
console.log("Лог после вызова функции multiply");

// Последовательность логов в консоли
// "Лог до вызова функции multiply"
// "Результат умножения равен 30"
// "Лог после вызова функции multiply"



Параметры по умолчанию
Иногда необходимо объявить функцию, у параметров которой будут значения отличные от undefined, даже если для них не передали аргументы. 
Это делается очень простым и очевидным образом, достаточно указать значение по умолчанию прямо при объявлении параметров в подписи функции. 
При такой записи, если для параметра не передано значение аргумента, используется значение по умолчанию.

function count(countFrom = 0, countTo = 10, step = 1) {
  console.log(`countFrom = ${countFrom}, countTo = ${countTo}, step = ${step}`);
  for (let i = countFrom; i <= countTo; i += step) {
    console.log(i);
  }
}

count(1, 5); // countFrom = 1, countTo = 5, step = 1
count(2); // countFrom = 2, countTo = 10, step = 1
count(); // countFrom = 0, countTo = 10, step = 1




Псевдомассив arguments
Доступ к списку всех аргументов можно получить при помощи специальной переменной arguments, которая доступна только внутри функции и хранит все аргументы 
как псевдомассив.
Псевдомассив - коллекция, со свойством length и возможностью обратиться к элементу по индексу, но отсутствием большинства методов для работы с массивом.
Рассмотрим пример использования arguments в функции, которая умножает любое количество аргументов:

function multiply() {
  let total = 1;

  for (const argument of arguments) {
    total *= argument;
  }

  return total;
}

console.log(multiply(1, 2, 3)); //  6
console.log(multiply(1, 2, 3, 4)); //  24
console.log(multiply(1, 2, 3, 4, 5)); //  120





Преобразование псевдомассива
Обычно псевдомассив необходимо преобразовать в полноценный массив, так как у псевдомассива нет методов массива, например slice() или includes(). 
На практике применяют несколько основных способов.

1) Используя метод Array.from(), который создаст массив из псевдомассива.

function fn() {
  // В переменной args будет полноценный массив
  const args = Array.from(arguments);
}

2) Используя операцию ... (rest), она позволяет собрать произвольное количество элементов, в нашем случае аргументов, в массив и сохранить его в переменную. 
Собираем все аргументы используя операцию rest прямо в подписи функции.

function fn(...args) {
  // В переменной args будет полноценный массив
}
Операция rest более детально рассматривается дальше в курсе, здесь показано одно из ее возможных применений.





Паттерн «Ранний возврат»
Оператор if...else - это основной способ создания ветвлений. Тем не менее, сложные вложенные ветвления делают код запутанным для понимания.

Создадим функцию, которая обрабатывает снятие денег с личного счета в банке. Она получает сумму для снятия и текущий баланс счета, после чего, 
в зависимости от условия, выполняет тот или иной блок кода.

function withdraw(amount, balance) {
  if (amount === 0) {
    console.log("Для проведения операции введите сумму больше нуля");
  } else if (amount > balance) {
    console.log("Недостаточно средств на счету");
  } else {
    console.log("Операция снятия средств проведена успешно");
  }
}

withdraw(0, 300); // "Для проведения операции введите сумму больше нуля"
withdraw(500, 300); // "Недостаточно средств на счету"
withdraw(100, 300); // "Операция снятия средств проведена успешно"

Даже в таком простом примере есть группа вложенных условных операторов, среди которых не сразу можно выделить понять логику выполнения кода.

В функции может быть больше одного оператора return. Главное помнить, что выполнение функции прерывается когда интерпретатор встречает возврат, 
и весь код после него будет проигнорирован в текущем вызове функции.

Паттерн «Ранний возврат» - это способ использовать возможность досрочного возврата из функции с помощью оператора return. 
Используя этот приём мы получаем более чистый, плоский и понятный код, который легче рефакторить.

Выделим все проверки условий в отдельные операторы if, после чего добавим код, идущий в теле else. В идеальном случае, должен получиться плоский 
список условных операторов, идущих один за другим, а в конце блок, который выполнится только в том случае, если не выполнится ни один if.

function withdraw(amount, balance) {
  // Если  условие выполняется, вызывается console.log и выход из функции. Код идущий после тела if не выполнится.
  if (amount === 0) {
    console.log("Для проведения операции введите сумму больше нуля");
    return;
  }
  // Если условие первого if не выполнилось, его тело пропускается и интерпретатор доходит до второго if.
  // Если условие выполняется, вызывается console.log и выход из функции. Код идущий после тела if  не выполнится.
  if (amount > balance) {
    console.log("Недостаточно средств на счету");
    return;
  }
  // Если ни один из предыдущих if не выполнился, интерпретатор доходит до этого кода и выполняет его.
  console.log("Операция снятия средств проведена");
}

withdraw(0, 300); // "Для проведения операции введите сумму больше нуля"
withdraw(500, 300); // "Недостаточно средств на счету"
withdraw(100, 300); // "Операция снятия средств проведена"





Функциональное выражение
Функциональное выражение (function expression) - обычное объявление переменной, значение которой будет функция. Альтернативный способ объявления функции.

// Объявление функции (function declaration)
function multiply(x, y, z) {
  console.log(`Результат умножения равен ${x * y * z}`);
}

// Функциональное выражение (function expression)
const multiply = function (x, y, z) {
  console.log(`Результат умножения равен ${x * y * z}`);
};

Различие в том, что функциональное выражение нельзя вызвать до места его создания, только после, потому что это буквально объявление const переменной.

// ❌ Ошибка! Не работает вызов до объявления
multiply(1, 2, 3);

const multiply = function (x, y, z) {
  console.log(`Результат умножения равен ${x * y * z}`);
};

// ✅ Работает вызов после объявления
multiply(4, 5, 6);

A объявление функции можно вызвать до места её создания в коде.

// ✅ Работает вызов до объявления
multiply(1, 2, 3);

function multiply(x, y, z) {
  console.log(`Результат умножения равен ${x * y * z}`);
}

// ✅ Работает вызов после объявления
multiply(4, 5, 6);

ИНТЕРЕСНО
Не важно какой синтаксис использовать, главное чтобы код в проекте был однородным. То есть необходимо стараться не мешать объявления функции 
с функциональными выражениями.
*/

/**
  |============================
  | Стек вызовов
  |============================
*/
/* 
При вызове функции, внутри её тела могут вызываться другие функции, а в них другие и т. д. 
JavaScript однопоточный язык, то есть в одну единицу времени может выполняться только одна инструкция. 
Это значит, что уже вызванные функции, которые не закончили свое выполнение, должны ждать выполнения функций вызванных внутри себя, для того, 
чтобы продолжить свою работу.

function fnA() {
  console.log("Лог внуртри функции fnA до вызова fnB");
  fnB();
  console.log("Лог внуртри функции fnA после вызова fnB");
}

function fnB() {
  console.log("Лог внутри функции fnB");
}

console.log("Лог перед вызовом fnA");
fnA();
console.log("Лог после вызова fnA");

// "Лог перед вызовом fnA"
// "Лог внуртри функции fnA до вызова fnB"
// "Лог внутри функции fnB"
// "Лог внуртри функции fnA после вызова fnB"
// "Лог после вызова fnA"

Необходим механизм хранения списка функций, которые были вызваны, но еще не закончили свое выполнение и механизм управления порядком выполнения этих функций - 
и именно за это отвечает стек вызовов (call stack).

Стек
Стек - структура данных, которая работает по принципу LIFO (Last-In-First-Out), то есть последним пришёл - первым вышел. Последнее, что добавляется на стек, 
будет удалено из него первым, значит можно добавить или удалить элементы только из верхушки стека.

Представьте стек как массив у которого есть только методы pop и push, то есть можно добавить или удалить только элемент в конце коллекции.




Стек вызовов (call stack) - это механизм для отслеживания текущего местонахождения интерпретатора в коде, который вызывает несколько функций. 
Какая из функций выполняется на данный момент, какие функции вызываются изнутри выполняемой функции, какая будет вызвана следующей и т. д.

Когда скрипт вызывает функцию, интерпретатор добавляет её в стек вызовов и начинает выполнение.
Любые функции, вызванные выполняемой функцией, добавляются в стек вызовов и выполняются, как только происходит их вызов.
Когда выполнение функции завершено, интерпретатор снимает её со стека вызовов и возобновляет выполнение кода с той точки, где остановился до этого. 
То есть начинает выполняться функция, запись которой лежит следующей на стеке.

Stack frame (кадр стека, запись стека) - структура которая добавляется на стек при вызове функции. Хранит служебную информацию, например имя функции 
и номер строки, в которой произошел вызов.

function bar() {
  console.log("bar");
}

function baz() {
  console.log("baz");
}

function foo() {
  console.log("foo");
  bar();
  baz();
}

foo();

При выполнении этого кода сначала вызывается foo(), затем внутри foo() вызывается bar(), а затем baz(). Вызовы console.log() так же учитываются, ведь это функция. 




Переполнение стека вызовов
Стек вызовов не безграничный, ему отводится конечный объем памяти. Иногда в консоли можно увидеть ошибку "Uncaught RangeError: Maximum call stack size exceeded" - 
переполнение стека (stack overflow).

Это может произойти при неправильном использовании рекурсии или зацикливании вызовов функций, то есть, если идут бесконечные вызовы функций и результат 
не возвращается, то стек увеличивается. По достижению предела количества записей стека и возникнет такая ошибка и скрипт «падает».
*/
