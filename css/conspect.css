/**
  |============================
  | СЕЛЕКТОРИ
  |============================
*/
/* шпаргалка по комбинациям селекторов:
https://webref.ru/course/css-tutorial/selector-combine
*/
/* 
Группирование селекторов (А, B)
Селекторы потомка (A B)
Дочерние селекторы (A > B)
Смежные селекторы (A + B) (выбираются элементы, у которых есть общий родитель и они находятся рядом друг с другом
Братские селекторы (A ~ B)
Объединение селекторов: (.class-a.class-b) - Стили будут применены только к тому элементу, который содержит 
все перечисленные селекторы.
(Этот приём применим только для классов и атрибутов, потому что только их может быть больше одного. )
*/

/*  Не плутати з композицією класів в HTML:
<p class="value1 value2 value3">Random text content :)</p>
*/

/**
  |============================
  | ПСЕВДОКЛАСИ
  |============================
*/
/* 
---------------- СТАНУ
:hover
:focus
:active

---------------- СТРУКТУРНІ
:first-child 
:last-child
:nth-child(n) — это псевдокласс, который позволяет выбирать элементы по их порядковому номеру.
:not(selector)   например    .list-item:not(:last-child)  --  применить ко всем  item    кроме  :last-child
:nth-child(an + b) де a - період циклу. n - лічильник циклу. Починається з нуля та збільшується на одиницю на 
                кожній ітерації. b - зміщення. Довільне число. На практике используем для выбора парных или 
                непарных элементов. Пример:
      :nth-child(2n) - выбрать все парные элементы       2n - синоним even      :nth-child(even) - то же самое
      :nth-child(2n + 1) - выбрать все парные элементы  2n + 1 -  синоним odd   :nth-child(odd)  - то же самое
      */
/* Как отнять от бесконечности */
/**
  |============================
  | БЛОКОВА МОДЕЛЬ
  |============================
*/
/* Глобальний border-box */
*,
*::before,
*::after {
  box-sizing: border-box;
}
/* У нормалізаторі modern-normalize за умовчанням задано глобальний border-box. Отже, якщо його підключено 
до проєкту, то у своїх стилях box-sizing можна не вказувати. */

/* Глобальне скидання стилів margin, padding */
h1,
h2,
h3,
h4,
h5,
h6,
p {
  margin-top: 0;
  margin-bottom: 0;
}
ul,
ol {
  margin-top: 0;
  margin-bottom: 0;
  padding-left: 0;
}

/* Маржин елемента body */
/* За умовчанням у таблиці стилів браузера для margin елемента body задано значення 8px з усіх боків. 
У дизайні сучасних веб-сторінок цей маржин не використовується, тому його завжди обнуляють у правилі 
із селектором body. */
body {
  margin: 0;
}
/* Обнулення маржина body вже є певним «стандартом» сучасної розробки, то ж нормалізатор 
modern-normalize містить цей крок. */

/* Горизонтальне центрування блокових елементів */
.box {
  margin: 0 auto;
}

/* Контейнери <div> */
/* Контейнеру обов'язково задаються:
ширина по макету;
автоматичні горизонтальні маржини і
необов'язкові горизонтальні падінги, також згідно макету. */
.container {
  width: 480px;
  margin: 0 auto;
  padding: 0 15px;
}

/* Рядкові елементи (inline):
- ігнорують значення width і height, верхніх і нижніх 'margin', 'padding' і border.
- Верхні та нижні падінги, а також рамки рядкового елемента працюють дуже дивно — не збільшують розмір блоку, 
 але візуально відображаються. */

/* - У рядкових та рядково-блочних елементів є правий проміжок !!!!!!!!!! Це не margin або padding, 
а буквально порожнє місце - 1/4 розміру шрифту найближчого батьківського елемента. */

/**
  |============================
  | ЗОБРАЖЕННЯ
  |============================
*/
/* Зображення - особливий елемент тому, що в нього крім правого зазору є ще нижній зазор - 1/4 розміру шрифту 
найближчого батьківського елемента !!!!!!!!!!!!!!!!!!!! . */

/* Прибираємо нижній проміжок для всього проєкта */
/* Автоматично підлаштовування зображення під ширину батьківського елемента */
img {
  display: block;
  max-width: 100%;
}

/* Розташування зображення в контейнері фіксованого розміру.
Для того, щоб ця техніка працювала, необхідні два обов'язкові кроки. 
- контейнеру має бути явно задано фіксовану висоту. 
- зображення необхідно «вмістити» в контейнер, задавши img висоту та ширину 100%, і вказати object-fit. */
.thumb {
  height: 400px;
  width: 300px;
}
.thumb img {
  height: 100%;
  width: 100%;
  object-fit: cover;
}
/* Варианты object-fit:

fill       -	Значение по умолчанию. Содержимое замещаемого элемента полностью заполняет область контейнера тега,
используя его высоту и ширину.
contain	   - Содержимое элемента масштабируется, выравниваясь по центру с сохранением пропорций таким образом, 
чтобы полностью поместиться внутри контейнера.
cover	     - Содержимое элемента обрезается, выравниваясь по центру с сохранением пропорций таким образом, 
чтобы полностью заполнить область контейнера.
scale-down -	Содержимое элемента выбирает из двух значений none и contain то значение, которое даёт меньшие размеры.
none	     - Замещаемое содержимое не изменяет свои собственные размеры, чтобы поместиться и заполнить область контейнера.
initial	   - Устанавливает это свойство в значение по умолчанию.
inherit	   - Наследует значение свойства от родительского элемента.*/

/* скрытие части изображения за пределами  .thumb*/
.thumb {
  overflow: hidden;
}

/* Скрол  изображения */
/* overflow: | hidden | scroll | auto */
.thumb {
  overflow: auto;
}

/**
  |============================
  | FLEX BOX
  |============================
*/
/* шпаргалка 
https://tpverstak.ru/flex-cheatsheet/
*/
/* -------------------------------------    Container       ------------------------------------ */
/* 
За замовчуванням display: flex створює однорядковий контейнер, елементи розміщуються на одному рядку 
й за потреби стискаються!!!!!!. Властивість flex-wrap дозволяє перетворити однорядковий контейнер на багаторядковий. 

Властивість gap комбінує в собі значення властивостей row-gap і column-gap, які дозволяють окремо вказати 
розміри зазорів між рядками і стовпцями сітки. Використовуйте gap коли зазори однакові. В іншому випадку 
підійдуть row-gap і column-gap.
*/
.menu {
  display: flex;
  gap: 8px;
  flex-direction: column;
  justify-content: flex-start;
  align-items: center;
  flex-wrap: wrap;
}
/* або
display: inline-flex */
/* 
ДЛЯ КОНТЕЙНЕРА
flex-direction: row | row-reverse | column | column-reverse 
justify-content: flex-start | flex-end | center | space-between | space-around (1/2-1-1/2) | space-evenly (1-1-1)
align-items: stretch | flex-start | flex-end | center | baseline (вирівнювання одного рядку відносно крос лінії)
align-content: flex-start | flex-end | center | space-between | space-around | space-evenly | stretch (вирівнювання 
              всього контенту відносно крос лінії)
flex-wrap: nowrap | wrap | wrap-reverse ( дозволяє перетворити однорядковий контейнер на багаторядковий)

ДЛЯ ЕЛЕМЕНТІВ
max-width: или flex-basis: или width:
align-self: auto | flex-start | flex-end | center | baseline | stretch (дозволяє елементу змінити своє розташування 
на cross axis, перевизначивши собі значення властивості align-items від контейнера.)
*/

/*  -----------------------------------  flex-елементи:     -----------------------------

Flex-елементи — це діти flex-контейнера, елементи першого рівня вкладеності.
- не підкорюються стандартному потоку документа;
- втрачають свій тип (блоковий, рядковий, тощо) ;
- дотримуються правил позиціонованої Flexbox-моделі.*/

/* Властивість flex-basis визначає початковий розмір. 
Початковий розмір — це розмір до застосування властивостей flex-grow і flex-shrink 
Якщо вказані обидві властивості, flex-basis і width, то властивість width ігнорується.
Властивість flex-basis може визначати висоту, а не ширину елемента (Якщо головна вісь йде вертикально).
Властивості min-width і max-width працюють як обмежувачі розміру елемента навіть якщо у нього вказано flex-basis.
*/
/* Для создания СЕТКИ элементам флексбокса добавляем: */
.menu .li {
  flex-basis: calc((100% - 20px) / 3);
}
/* 
ПРОБЕЛЫ ОБЯЗАТЕЛЬНЫ!!!!
20px - общая длина зазоров между элементами
3 - количество планируемых столбцов
 */
/* 
Властивість flex-grow дозволяє елементу займати вільний простір.
Властивість flex-shrink визначає здатність flex-елемента займати менше місця, ніж його початковий розмір.
Дозволяємо зростання:*/
.menu .li {
  flex-grow: 1;
}
/* Забороняэмо стискання:*/
.menu .li {
  flex-shrink: 0;
}
/**
  |============================
  | Flexbox model default properties
  |============================
*/
.flex-container {
  display: flex;
  /* flex-direction: row; */
  /* justify-content: flex-start; */
  /* align-items: stretch; */
  /* flex-wrap: nowrap; */
}
.flex-element {
  flex-basis: calc((100% - 20px) / 3);
  /* flex-grow: 0; */
  /* flex-shrink: 1; */
}

/**
  |============================
  | Flexbox grid пример
  |============================
*/
:root {
  --items: 3;
  --indent-vertical: 30px;
  --indent-horizontal: var(--indent-vertical);
}
.card-set {
  display: flex;
  flex-wrap: wrap;
  row-gap: var(--indent-horizontal);
  column-gap: var(--indent-vertical);
}
.card-set-item {
  flex-basis: calc(
    (100% - var(--indent-vertical) * (var(--items) - 1)) / var(--items)
  );
}
/* В HTML присваиваем class="team-list card-set" */
.team-list {
  --items: 5;
  --indent-vertical: 10px;
  --indent-horizontal: 50px;
}
/* В HTML присваиваем class="gallery-list card-set" */
.gallery-list {
  --items: 4;
}
/**
  |============================
  | Як реалізувати приклеєний футер сторінки?
  |============================
*/
/* 
<div class="page-container">
	<header>Page header</header>
	<main>Main content</main>
	<footer>Page footer</footer>
</div>
*/
.page-container {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}
main {
  flex-grow: 1;
}
/* min-height: 100vh  -  мінімальна висота - 100% висоти вкладки браузера на екрані (viewport height — відсотки). */

/**
  |============================
  | Псевдоелементи
  |============================
*/
/* ::before - створює псевдоелемент перед всім вмістом елемента (на початку) ВСЕРЕДИНІ елементу. */
/* ::after - створює псевдоелемент після всього вмісту елемента (наприкінці) ВСЕРЕДИНІ елементу. */
.box {
  color: #03a9f4;
}
.box::before {
  /* стилі псевдоелемента before */
  content: '';
}
/* За замовчуванням псевдоелементи — це рядкові елементи. Для того, щоб задати псевдоелементу вертикальну 
геометрію, необхідно змінити його тип на блоковий або рядково-блоковий. 
Властивість content є обов’язковою, без неї браузер не створить псевдоелемент. Якщо за макетом текстовий контент
не потрібний, його значенням необхідно поставити порожній рядок та задати width та height: 
*/
.box::before {
  content: '';
  width: 100px;
  height: 2px;
}
/* Використання псевдокласів стану разом з псевдоелементами:
Застосувати стилі до псевдоелементу .box::before при ховері на елемент .box */
.box:hover::before {
  background-color: green;
}

/**
  |============================
  | Позиціонування
  |============================
*/
/* --------------------------------- Властивість position ------------------------------- */
/* Властивість position змінює тип позиціонування елемента.
position: static | relative | absolute | fixed | sticky    
Задаємо top, left або bottom і right (одначасно top + bottom, left + right працювати не буде.)

Позиціоновані елементи: 

position: relative; 
- При відносному позиціонуванні елемент залишається у потоці сторінки, сусідні елементи не займають 
його місце. Візуально він буде зміщений щодо його первісного положення. Він може перекривати сусідів.; 
Слід рахувати так:
top – сдвиг от «обычной» верхней границы (сверху) (позитивное значение сдвинет элемент вниз)
bottom – сдвиг от нижней границы (снизу) (позитивное значение сдвинет элемент вверх)
left – сдвиг слева (позитивное значение сдвинет элемент вправо)
right – сдвиг справа (позитивное значение сдвинет элемент влево)

position: absolute; 
Елемент вилучається з потоку сторінки. 
Щоб визначити точку відліку, браузер шукає найближчий елемент-предок, у якого властивість position має 
будь-яке значення крім static. 
Зазвичай, воно використовується у зв'язці з відносним позиціонуванням для декоративного позиціонування 
елементів. Тобто елемент «абсолютно» позиціонується «відносно» рамки свого предка, який є в потоці сторінки. 
Якщо такого предка не виявиться, то відлік буде починатися від рамки елемента <body>. 
Запис top: 0; right: 0; означає що рамка елемента співпаде з рамкою елемента відносно якого відбувається 
позиціонування по правому та верхньому краю.
Запис bottom: 20px означає відстань між нижньою межею відносно позиціонованого предка і нижньою межею 
абсолютно позиціонованого елемента.
Якщо позицілнуємо текст (<р>) не забуваємо прибрати маржин!

position: fixed; 
Такий елемент вилучається із потоку сторінки та позиціонується відносно в'юпорту.

position: sticky;
Поки елемент знаходиться у своєму контейнері, і контейнер не виходить з області видимості при вертикальному 
прокручуванні — елемент поводиться як relative.
Як тільки частина батьківського контейнера виходить із області видимості, елемент фіксується на сторінці 
до тих пір, поки хоча б якась частина контейнера присутня на екрані.
Якщо весь контейнер вийде з області видимості, то знову увімкнеться поведінка як при відносному позиціонуванні
— елемент зникне з екрану за контейнером.
Реалізація:
Липкому елементу необхідно задати позиціонування position: sticky.
У липкого елемента має бути задане положення, наприклад, top: 0.
Елемент-контейнер має бути більшим за висотою, ніж липкий елемент.
*/
.section-title {
  position: sticky;
  top: -5px;
}
/* ------------------------- Приклад позиціонування з використанням calc ------------------------ */
/* 
background-position: top: 50% right: calc(50% + 300px);
*/
/* ------------------------------------ Властивість z-index  ------------------------------------ */
/* властивість z-index, яке контролює глибину (порядок) позиціонованих елементів на сторінці по осі z від очей
користувача і до екрану. У якості значення може бути будь-яке ціле число, у тому числі негативне. 
Загальний предок позиціонованих елементів створює контекст (stacking context) — область, в якій властивість 
z-index елемента впливає на інші елементи z-index.

Що треба знати при використанні z-index:
Чим більше значення z-index всередині цього контексту, тим вище розташовується елемент.
Мінімальне значення z-index говорить про те, що інші елементи поза потоком будуть вище цього елементу. 
Якщо у двох елементів однакові значення z-index, вищим буде елемент, оголошений останнім у HTML-коді.*/

/**
  |============================
  | ДЕКОРАТИВНІ ЕЛЕМЕНТИ, АНІМАЦІЯ
  |============================
*/
/* ----------------------------------- Зображення фону --------------------------------- */
/*Елемент фону background-image: поширюється лише на область вмісту і падінг і ніколи на маржин.*/
/* Варто відразу задати колір фону та фонове зображення, яке завжди буде розташоване поверх фону.*/
.hero {
  background-color: #2a2a2a;
  background-image: url('');
  /* !!! файл ищет от текущего каталога, чтобы подняться на уровень выше, нужно написать две точки: ../ */
  background-repeat: no-repeat;
  /* background-repeat: repeat за замовчуванням */
  /* background-repeat: repeat | repeat-x | repeat-y | no-repeat; */
  background-position: center center;
  /* Задається окремо по осі Х та У. ЗАВЖДИ СПОЧАТКУ ПО Х а потім - по У. 
  Можна у px чи % або top, bottom, right, left, center.
  За замовчуванням задане значення left для x і top для y*/
  background-position: right 30px bottom 20px;
  /*                        ^^^^^     ^^^^^                         
/зміщення вліво від правого краю   зміщення вверх від нижнього краю*/
  background-size: cover;
}
/* background-size: auto | значення | cover | contain
  Значення задається окремо width та height.
  Якщо не вказати висоту, вона буде розрахована автоматично зі збереженням пропорцій.
  Значенням також можуть бути два зарезервовані слова: cover і contain. 
  Функція обох значень — максимально вмістити у контейнер фонове зображення, але різними способами.
  cover — за рахунок обрізання зайвого.
  contain — за рахунок утворення порожнього простору в контейнері. */

/* -------------------------------- Багатошаровий фон ---------------------------- */
/* Елементу можна задати кілька фонових зображень одночасно. Достатньо перерахувати їх у властивості 
background-image через кому. Для кожного зображення також можна задати значення інших властивостей фону, 
також через кому в кожній властивості. */
/* !!!!!!! Зображення, яке йде у переліку попереду, буде розташовано вище (зображення 1 у коді вище) !1!!!!! */
/*background-image: url(шлях до зображення 1), url(шлях до зображення 2);
  background-size: 100px, cover;
  background-position: top right, center;
  background-repeat: repeat-x, no-repeat; */

/* ---------------------------- Лінійний градієнт --------------------------  */
/* Градієнт — перехід від одного кольору до іншого.
background-image: linear-gradient(
	<напрямок>, 
	<колір-1>, 
	<колір-2>, 
	<колір-3>, 
	...)
Напрямок градієнта задається to top, to right, to bottom, to left і їх комбінаціями. За замовчуванням — to bottom. 
Напрямок також можна задати кутом нахилу в градусах — одиниця deg. 
Приклад:
  background-image: linear-gradient(90deg, red, blue);
  */

/* -------------------------- Властивість background -------------------------- */
/* Властивість background — це складена властивість одночасного завдання значень всіх розглянутих властивостей.
background: background-color background-image background-repeat background-position background-attachment (scroll)
Якщо компонент не вказано, використовується його значення за замовчуванням.
ПРИКЛАД:
background: url(шлях до зображення) repeat-x;
(Прозорий колір фону з картинкою, що повторюється по x, починаючи з верхнього лівого кута.)
*/
/**
  |============================
  | Приклад коду для стилізації просвічування фону через текст
  |============================
*/
/* 
.text-image {
  color: transparent;
  background-image: url(...);
  background-position: center right 200px;
  --webkit-background-clip: text;
  background-clip: text;
  background-attachment: fixed;
}
Свойство CSS background-clip определяет как цвет фона или фоновое изображение будут выводиться под границами блока.
Значения
border-box - Фон распространяется до внешнего края границы (но под границей в z-порядке).
padding-box - Фон распространяется до внешнего края отступа. Под границей фон не рисуется.
content-box - Фон закрашивается внутри (обрезается) поля содержимого.
text - Экспериментальная возможность - Фон закрашивается внутри (обрезается) текста переднего плана.
------- background-attachment -------------
Если указано background-image, CSS свойство background-attachment определяет, является ли позиция этого изображения фиксированной 
в области просмотра, или прокручивается вместе с содержащим его блоком (fixed или scroll). Scroll - по умолчанию
*/
/* ------------------------------------ Тіні ------------------------------------  */
/* Властивість box-shadow задає елементу одну або більше тіней. За замовчуванням розмір тіні збігається 
з розміром елемента, а її колір такий самий, як і колір його тексту. */
/* 
box-shadow: <x-offset> <y-offset> <blur> <spread> <color>; */
/* blur — радіус розмиття. Чим більше значення, тим сильніше розмита тінь. Необов'язкове значення.
spread — радіус поширення. Позитивне значення збільшує тінь, негативне — зменшує. Необов'язкове значення.
color — колір тіні. Можна використовувати будь-який формат запису кольору. Необов'язкове значення. */

/* На один елемент можна додати кілька тіней, вказавши їх значення через кому. Кожна попередня тінь зі списку 
розташовується на вищому шарі і визуально перекриває всі наступні. */

/* Синтаксис оголошення внутрішньої тіні аналогічний синтаксису звичайної тіні, але першим значенням 
необхідно вказати inset. */

/* ------------------------------------ Вбудований SVG -------------------------- */
/* Вбудовуємо в HTML: 
<svg
  width="20"
  height="20"
  viewBox="0 0 9 16"  --- min-x, min-y, width и height --- задают границы окна отображения элемента SVG
  Значением будет 4 цифры: min-x , min-y , width и height . В примере выше окно отображения будет 
  начинаться в координатах 0 по оси x и 0 по оси y, а по ширине и высоте будет 9 b 16 пикселей.
  fill="currentColor"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M6.66463 2.65667H8.1253V0.112667C7.8733 0.078 7.00663 0 5.9973 0C3.8913 0 2.44863 1.32467 2.44863 3.75933V6H0.124634V8.844H2.44863V16H5.29797V8.84467H7.52797L7.88197 6.00067H5.2973V4.04133C5.29797 3.21933 5.5193 2.65667 6.66463 2.65667Z"
  /> 
  */
/* CSS властивість fill 
Властивість fill керує кольором заливки. Якщо колір заливки не вказано, фігура буде залита поточним 
кольором тексту (за замовчуванням — чорним).  */
.icon {
  fill: #2a2a2a;
}
/* Змінюємо колір заливки при ховері. */
.icon:hover {
  fill: #03a9f4;
}

/* ----------------------------------- SVG-спрайти ----------------------------------- */
/* Алгоритм створення SVG-спрайт
- Відкрий макет у Figma, обери там всі іконки й експортуй їх в SVG-форматі на свій комп’ютер.
- Зайди на icomoon.io , натисни кнопку Import Icons зверху ліворуч та додай всі іконки.
- Натисни Generate SVG & More внизу ліворуч.
- Натиснути Download внизу ліворуч. 

В одному файлі можна описати безліч різних груп фігур, використовуючи елемент <symbol>, після чого, 
задавши кожному символу унікальний id, звернутися до будь-якого з них з HTML-документа.

Використання у HTML:
<svg>
  <use href="./шлях-до-svg-спрайту/имэя-спрайта.svg#ідентифікатор-символа"></use>
</svg>*/

/* ------------------------------------ CSS-переходи ------------------------------------ */
/*
Параметрами переходу:
transition-property: <властивість>
transition-duration: <час>
transition-timing-function: <функція розподілу часу>
transition-delay: <затримка> 

Для налаштування переходу необхідно:
- вказати початкові значення властивостей елементу
- задати transition елементу, до якого застосовується переход
- при події, наприклад :hover, задати нові значення властивостей (у псевдокласі).

transition-property задає властивості, до яких буде застосовано ефект переходу. Значенням може бути одна 
властивість або список властивостей через кому (для всіх властивостей має бути заданий кінцевий стан). 
За замовчуванням — all, анімуються всі можливі властивості.
Список властивостей, які можуть бути анімовані в майбутньому може змінитися. Тому обов'язково необхідно 
вказувати властивість, яку потрібно анімувати, інакше буде анімовано всі можливі властивості елемента, 
що призведе до несподіваних результатів.

transition-duration. Якщо тривалість переходу не вказана, зміна значень відбудеться миттєво, без анімації. 
Властивість transition-duration задає проміжок часу, протягом якого має здійснитися перехід. Значення 
властивості вказується в секундах або мілісекундах. Якщо різні властивості мають різні значення часу переходу, 
всі вони перераховуються через кому.

transition-timing-function задає функцію розподілу часу, тобто поведінку анімації. Значення властивості 
задається через формулу Безьє. Ключові слова:
ease — перехід починається повільно, швидко прискорюється, а потім знову сповільнюється в кінці.
linear — перехід має рівномірну швидкість.
ease-in — починається повільно, швидкість переходу збільшується до повного завершення переходу.
ease-out — починається швидко, уповільнюється протягом переходу.
ease-in-out — починається повільно, прискорюється, а потім знову сповільнюється.
За замовчуванням використовується значення ease.

transition-delay визначає затримку, після якої розпочнеться анімація переходу. За замовчуванням встановлено 0s.

Всі властивості переходу можна поєднати в одну складову властивість transition.
transition: [property] [duration] [timing-function] [delay]
transition: background-color 500ms linear, transform 500ms ease-in-out;
Можна перелікувати декілька властивостей:
transition: color 150ms ease-in-out 0ms, background-color 150ms ease-in-out 150ms;
*/

/* ------------------------------------ CSS-анімація ------------------------------------ */
/*На відміну від переходів, анімації не потрібен обов'язковий ініціатор (подія), її можна повторити 
нескінченну кількість разів, і між початковим та кінцевим станами може бути будь-яка кількість станів.

Анімація оголошується директивою @keyframes. Директива описує набір кадрів (frames, станів) анімації. 
В анімації має бути як мінімум два кадра: початковий і кінцевий.

@keyframes ім'яАнімації {
  0% {Властивості що змінюються}
  ---Довільна кількість проміжних кадрів---
  100% {Властивості що змінюються}
}

Щоб використати вже оголошену анімацію, потрібно вказати її ім'я як значення для властивості animation-name
та встановити тривалість (animation-duration). За замовчуванням анімація відбувається один раз, і фінальні 
значення анімованих властивостей не зберігаються. Елемент повертається до свого початкового стану.
.box {
  animation-name: changeBgColor;
  animation-duration: 3000ms;
}
animation-timing-function встановлює функцію розподілу часу для анімації.
animation-iteration-count встановлює кількість повних повторень (n разів або infinite - нескінченно)
animation-delay встановлює затримку перед початком анімації в секундах або мілісекундах
animation-play-state дозволяє призупинити відтворення анімації. За замовчуванням встановлено значення running. 
Якщо встановити значення paused, наприклад при :hover, анімація буде призупинена поки курсор миші знаходиться 
над елементом.
animation-fill-mode визначає, що відбувається зі стилями елемента до початку анімації та після її завершення

animation-fill-mode: none | forwards | backwards | both 
none — стилі анімації впливають на елемент тільки під час анімації. До та після анімації елемент знаходиться у своєму початковому стані. Це значення за замовчуванням.
forwards — стилі, застосовані в кінці анімації, застосовуються до елемента після завершення анімації.
backwards — початкові стилі анімації будуть застосовані ще до старту анімації (незалежно від animation-delay).
both — поєднує forwards і backwards, стилі застосовуються до та після анімації.

animation-direction контролює напрямок відтворення анімації від початкового до кінцевого кадру, або, навпаки
normal — анімація відтворюється від початкового до кінцевого кадру, а потім скидається в початковий стан). Це значення використовується за замовчуванням.
reverse — анімація відтворюється у зворотному напрямку, починаючи від кінцевого кадру до початкового, а потім одразу повертається до кінцевого кадру
alternate — спочатку відтворення здійснюється від початкового і до кінцевого кадру, після чого відбувається зміна напрямку при кожному наступному повторенні.
alternate-reverse — спочатку відтворення здійснюється від кінцевого і до початкового кадру, після чого відбувається зміна напрямку при кожному наступному повторенні.

Складова властивість animation
animation: animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction;*/

/* ------------------------------------ 2D-трансформації ------------------------------------ */
/* Властивість transform відповідає за застосування однієї або більше трансформацій елемента.
transform: none | <тип трансформації> <тип трансформації> ...;

---------- Масштабування
Функції scaleX(tx), scaleY(ty) і scale(tx, ty) масштабують блок по ширині та/або висоті, не впливаючи 
на геометрію навколишніх елементів.
*/
.box {
  transform: scale(1.15);
}
/* 
---------- Поворот 
Функція rotate(кут) повертає елементи на задану кількість градусів (одиниця deg) або обертів (turn).
*/
.box {
  transform: rotate(45deg);
}
/* 
---------- Зміщення 
Функції translateX(tx), translateY(ty) і translate(tx, ty) переміщають елемент у Х та У напрямках щодо початкового положення.
Позитивні значення X зміщують елемент праворуч, негативні - ліворуч.
Позитивні значення Y зміщують елемент вниз, негативні – вгору.
Значення можуть бути у пікселях чи відсотках.*/
.box {
  transform: translateY(-100%);
}
/* ---------- Викривлення  
Функції skewX(кут), skewY(кут) і skew(x-кут, y-кут) використовуються для викривлення (нахилу, деформування) 
сторін елемента щодо координатних осей. Якщо для skew() вказано тільки одне значення, друге буде 0, 
тобто це буде аналог skewX().
*/
.box {
  transform: skew(30deg);
}
/* 
------------------------------------- Центрування елемента ---------------------------------
Ставимо абсолютно позиціонований елемент точно по центру блоку, щодо якого він позиціонується.
<div class="parent">
  <div class="box"></div>
</div>

.parent {
	position: relative;
}
.box {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
*/
/* 
--------------------------------------- Декоративний оверлей --------------------------------
<div class="box">
  <div class="overlay"></div>
</div>
1. Спочатку абсолютно позиціонуємо div.overlay щодо div.box і розтягуємо його на всю ширину і висоту div.box.
.box {
  position: relative;
}
.overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
2. Зміщуємо div.overlay ліворуч на 100% його ширини
.overlay {
.....
  transform: translateX(-100%);
}
3. При ховері по div.box, повертаємо div.overlay у вихідне положення.
.box:hover .overlay {
  transform: translateX(0);
}
4. Задаємо div.box властивість overflow: hidden, щоб сховати div.overlay, коли той зміщений за межі div.box.
.box {
......
  overflow: hidden;
}
5. Додаємо div.overlay перехід для анімації властивості transform
.overlay {
.....
  transition: transform 250ms ease-in-out;
}
*/
/**
  |============================
  | МОДАЛЬНЕ ВІКНО
  |============================
*/
/* Розмітка модального вікна складається з:
- кнопки відкриття модального вікна;
- бекдропа (дів);
- розмітки модалки, що дівом вкладена в бекдроп;
- кнопки закриття модалки, вкладеної в розмітку модалки.

<div class="backdrop is hidden">
<div class="modal">
<button type="button">Закрыть</button>
<p>Lorem</p>
</div>
</div> 

Клас is hidden
.backdrop.is-hidden {
  visibility: hidden;   -- невидимість для читалок                             це робить елемент невидимим
  oppacity: 0;          -- непрозорість (0 - повністю прозорий)             -  у т.ч. для читалок та з ним
  pointer-events: none; -- відсутність взаємодії з мишю, фокусом, ховером      неможливо взаємодіяти
}
.backdrop {
  position: fixed;
  top: 0px;
  left: 0px;
  height: 100vh;
  width: 100vw;
  background-color: var(- прозрачный фон);
  opacity: 1;
  transition: opacity 250ms cubic-bezier(0.4, 0, 0.2, 1),
  visibility 250ms cubic-bezier(0.4, 0, 0.2, 1);
*/
/**
  |============================
  | Елементи form
  |============================
*/
/* 
Семантично — це контейнер для групи пов'язаних елементів.
В елементі form немає обов'язкових атрибутів. Наведемо в прикладі кілька корисних необов'язкових
name — ім'я форми, що є унікальним на поточній веб-сторінці. Використовується як на сервері, так і на клієнті.
autocomplete — визначає, чи може браузер автоматично заповнювати значення всіх елементів форми. Два значення off і on.
novalidate — атрибут-прапор, не має значення. Говорить браузеру не перевіряти валідність введених даних під час 
             відправки форми. Якщо атрибут не вказано, виконується вбудована у браузер валідація.  */
/* -------------------------------- Button -------------------------------- */
/* 
Кнопка не успадковує багато стилів оформлення тексту. Основні — це сімейство шрифтів і колір тексту. 
Рекомендується встановити глобальний стиль тегу button. Інші властивості та їх значення варто брати з макета.
HTML
<button type="submit">Submit feedback</button>
CSS
button {
	font-family: inherit;
	color: currentColor;
}
*/
/* -------------------------------- input -------------------------------- */
/* Тип поля визначається атрибутом type. 
Значення атрибуту type за умовчанням: text. Його використання створює однорядкове текстове поле.
За умовчуванням поле введення є рядковим елементом, який не успадковує сімейство шрифтів. Отже, 
до глобальних стилів можна додати правило для всіх полів вводу.
HTML
<form>
  <input type="text" name="username" />
  <button type="submit">Submit feedback</button>
</form>
CSS
input {
	font-family: inherit;
}
*/
/* -------------------------------- label -------------------------------- */
/* 
Елемент label пов'язує опис (мітку) з інтерактивним елементом форми. Текст і елемент пов'язані не тільки 
візуально, але й за логікою. Наприклад, скрінрідер оголосить текст мітки, коли користувач поставить фокус 
на пов'язаний елемент. При натисканні на мітку пов'язаний елемент автоматично отримає ефект фокусування.
Якщо елемент форми вкладається в label, зв'язок створюється браузером автоматично. Клік за текстом 
«Username» поставить фокус у поле введення:
<form>
  <label>
    Username
    <input type="text" name="username" />
  </label>
Якщо елемент форми не вкладено в label, необхідно явно зв'язати їх через:
атрибут id елемента та
атрибут for мітки
<label for="full-name">Name</label>
<input id="full-name" name="Full-Name" type="text"/>
*/
/* -------------------------------- label НЕ ПУТАТЬ С aria-label -------------------------------- */
/* 
Aria-label — помогает присвоить компоненту заголовок, который видим исключительно программам чтения с экрана.
Приминимо, например, для ссылок, кнопок, которые не имеют текстового содержания, а только графический элемент, например, иконка.
Ссылка в виде иконки будет прочитана скринридером, что есть хорошо для людей с потребностями.
Еще пример - кнопка редактирования в виде карандашика
 */
/* -------------------------------- Атрибут placeholder -------------------------------- */
/* 
Дозволяє відображати текст-підказку про дані, які необхідно ввести в поле. Текст-підказка відображається, 
коли елемент input пустий та зникає при введенні тексту від користувача.
Атрибут placeholder можна використовувати в будь-якому елементі форми, де є текстове введення.
<input type="text" name="username" placeholder="Jacob Mercer" />

Для оформлення тексту підказки використовується псевдоелемент input::placeholder.
input::placeholder {color: blue;}

Змінити стилі тексту підказки при наведенні миші або фокусі поля введення можна селекторами стану.
input:hover::placeholder, input:focus::placeholder

Псевдоклас :placeholder-shown дозволяє налаштовувати властивості поля вводу під час відображення 
тексту-підказки. Слід пам’ятати, що як тільки користувач ввів хоча б один символ, підказка зникає.
input {border: 1px solid orange;}
input:placeholder-shown {border-color: blue;}
*/
/* ----- Атрибут autofocus ----- */
/* 
За наявності цього атрибута, поле вводу автоматично отримує фокус при завантаженні. 
Отже, в ньому відразу можна буде набирати текст. За замовчуванням цього атрибута немає в жодному полі. 
*/
/* -------------------------------- Псевдоклас :focus-within -------------------------------- */
/* 
Застосовується до елемента, щойно він сам або елементи всередині нього отримують фокус. Це дозволяє 
застосувати стилі на: мітку, форму, окреме поле форми при взаємодії користувача з полями форми.
.form:focus-within {
  border-color: #2196f3;
}
.form-label:focus-within {
  color: #2196f3;
}
*/
/* -------------------------------- Елемент textarea -------------------------------- */
/* 
Парний тег, який створює багаторядкове поле для вводу великої кількості тексту. 
<textarea name="" rows="" cols="" placeholder=""></textarea>
За замовчуванням елемент textarea можна розтягувати по горизонталі і вертикалі. Для того щоб контролювати 
можливість зміни розміру користувачем, CSS має властивість resize: both | horizontal | vertical | none
*/
/* -------------------------------- Елемент select -------------------------------- */
/* 
Елемент select — це випадаюче меню (або, як його ще називають, комбобокс), що дозволяє вибрати одну 
з декількох опцій (варіантів відповідей).
<select name="size">
  <option value="xs">Extra Small</option>
  <option value="s">Small</option>
  <option value="m" selected>Medium</option>
  <option value="l">Large</option>
</select>
Текст усередині елемента option відображається в браузері, а значення атрибута value буде використано 
при відправленні форми.
За замовчуванням вибрано перший елемент option зі списку. Це можна змінити, задавши для option атрибут selected.

Якщо потрібно згрупувати опції, використовується тег optgroup. Текст заголовка групи в атрибуті label
<select name="month">
<select name="month">
  <optgroup label="Summer">
    <option value="s6">June</option>
    <option value="s7">July</option>
    <option value="s8">August</option>
  </optgroup>
  <optgroup label="Autumn">
    <option value="s9">September</option>
    <option value="s10">October</option>
    <option value="s11">November</option>
  </optgroup>
</select>
*/
/* -------------------------------- Поле вводу пошти -------------------------------- */
/* 
	  <input type="email" name="email" />
*/
/* -------------------------------- Поле вводу пароля -------------------------------- */
/* 
	  <input type="password" name="pwd" minlength="5" maxlength="12" />
Атрибути minLength і maxLength не обов'язкові.
*/
/* -------------------------------- Поле вводу телефону -------------------------------- */
/* 
    <input type="tel" name="phone" />
  */
/* -------------------------------- Поле вводу чисел -------------------------------- */
/* 
<input type="number" name="age" value="0" min="18" max="120" />
За допомогою атрибутів min і max, що визначають діапазон введення.
За замовчуванням числові поля приймають лише цілі числа. Цю поведінку можна змінити за допомогою атрибута step.
Цей атрибут вказує крок зміни числа. За замовчуванням значення кроку дорівнює 1.
Відлік іде від першої введеної одиниці, тобто при введенні 0,3 - 0,8, 1,3, 1,8
 */
/* -------------------------------- Поле вводу дати та часу -------------------------------- */
/* 
<!-- Для вибору лише дати -->           <input type="date" />
<!-- Для вибору лише часу-->            <input type="time" />
<!-- Для вибору дати і часу -->         <input type="datetime-local" /> 
*/
/* -------------------------------- Радіокнопка -------------------------------- */
/* 
- Кожній радіокнопці в групі задається однакове значення атрибута name, інакше браузер не знатиме, що це група.
- У радіокнопки не можна вводити дані. Тому кожній з них необхідно вказати значення в атрибуті value. 
Це значення, яке буде передано на сервер, коли користувач відправить форму.
- Атрибут checked вказує, який перемикач буде обраний (позначений) за замовчуванням. У групі радіокнопок 
в стані checked може бути тільки один елемент. За замовчуванням перший.
<label>
    <input type="radio" name="color" value="red" checked />
    Red
  </label>
  <label>
    <input type="radio" name="color" value="white" />
    White
  </label> 
  */
/* -------------------------------- Чекбокс -------------------------------- */
/* 
<p>What are your hobbies?</p>
- Кожному чекбоксу в групі задається однакове значення атрибута name, інакше браузер не знатиме, що це група.
- У чекбокси не можна вводити дані, тому кожному з них необхідно вказати значення в атрибуті value.
- Атрибут checked вказує, який чекбокс буде обраний за замовчуванням. У групі чекбоксів в стані checked 
може бути скільки завгодно елементів. За замовчуванням немає жодного.  
<label>
    <input type="checkbox" name="hobby" value="music" checked />
    Music
  </label>
  <label>
    <input type="checkbox" name="hobby" value="sports" checked />
    Sports
  </label> 
  */
/* -------------------------------- Псевдоклас :checked -------------------------------- */
/* 
Псевдоклас :checked застосовується до радіокнопок, чекбоксів, опцій випадаючого меню в селектах
Він дозволяє додати стилі тільки до зазначених полів (інтерактивів).
*/
input:checked {
  box-shadow: 0 0 0 2px orangered;
}
/* -------------------------------- Селектор атрибута -------------------------------- */
/* 
Cтруктура селектора атрибута — це селектор → ім’я атрибута → значення атрибута. selector[attribute_name="..."]
input[type="checkbox"] {
}
Тоді селектор чек-боксів у вибраному стані виглядатиме так.
input[type="checkbox"]:checked {
	box-shadow: 0 0 0 2px orangered;
}
*/
/* -------------------------------- Селектор X + Y -------------------------------- */
/* Цей селектор вибирає тільки той елемент Y, який в HTML-розмітці слідує відразу ж за X 
Поєднуючи селектор X + Y та псевдокдас :checked, можна зробити так, щоб при виборі чек-боксу 
текст мітки вибраного змінював колір.
<input type="checkbox" name="hobby" value="music" id="music" />
<label for="music">Music</label>
input[type="checkbox"]:checked + label {
  color: blue;
}
*/
/* -------------------------------- Обов'язкові поля -------------------------------- */
/* Логічний атрибут required позначає поле форми як обов'язкове для заповнення. Під час надсилання форми 
браузер виведе повідомлення підказку, якщо поле порожнє. Зовнішній вигляд повідомлення залежить від браузера 
і не може бути змінений із CSS. 
<input type="email" name="email" required />
Щоб зробити групу радіокнопок або чекбоксів обов'язковою, необхідно задати атрибут required кожному 
елементу групи.
*/
/* -------------------------------- Атрибут disabled -------------------------------- */
/* Атрибут disabled дозволяє зробити інтерактивний елемент неактивним. Такі елементи не отримують ефекту 
фокусу, а також ігнорують кліки миші. 
<button type="button" disabled>Disabled button</button>
Для стилізації неактивного елемента є псевдоклас: disabled, який застосовується до елемента з атрибутом disabled.
button:disabled {
  background-color: lightgray;
  cursor: not-allowed;
}
*/
/* -------------------------------- Угруповання полів -------------------------------- */
/* 
Елемент fieldset — це контейнер для групування декількох пов'язаних елементів у формі, а вкладений legend 
виконує роль заголовка групи. 
Пов'язані радіокнопки та чек-бокси завжди повинні бути згруповані. Інші типи полів групуються за потребою.
<form>
  <fieldset>
    <legend>Заголовок групи</legend>
    <!-- Група інтерактивних елементів -->
  </fieldset>
</form>
За замовчуванням елемент fieldset має маржини, падінги і рамку. Їх можна скинути глобально або точково 
для певної форми, залежить від завдання.
fieldset {
  padding: 0;
  margin: 0;
  border: none;
}
*/
/**
  |============================
  | Таблиці
  |============================
*/
/* 
<table> — тег-контейнер для всього вмісту. Він показує де таблиця починається і де закінчується.
<tr> — рядок таблиці (table row). Не може бути порожнім, повинен містити хоча б одну клітинку.
<td> — клітинка таблиці (table data). Можна використовувати лише всередині рядка. У кожному рядку таблиці 
має бути однакова кількість клітинок.
<th> (table header) — спеціальний семантичний тег клітинки-заголовка. За замовчуванням текст 
усередині <th> виділяється жирним шрифтом та центрується.
Для уточнення типу клітинки-заголовка (заголовок стовпця або заголовок рядка) використовується атрибут для th -
scope="значення":
атрибут col - заголовок стовпця;
атрибут row - заголовок рядка.
атрибут colgroup - заголовок групи стовпців
атрибут rowgroup - заголовок групи рядків

Структурні теги
<thead> — хедер таблиці огортає групу рядків таблиці в області заголовка.
<tbody> — тіло таблиці огортає основну групу рядків таблиці з даними.
<tfoot> — футер таблиці, позначає групу рядків з підсумками.
Елементи <thead>, <tbody> і <tfoot> не впливають на візуальне відображення таблиці та не є обов'язковими. 
За винятком того, що <tbody> є обов'язковим, якщо є <thead> або <tfoot>

<caption> - заголовок таблицію. Цей тег розташовується всередині таблиці, першим елементом.
<table>
  <caption>
    Example breakfast template
  </caption>
  <!-- Розмітка таблиці -->
</table>

Для об'єднання клітинок використовують атрибути:
colspan — це число клітинок праворуч, що вимагають об'єднання.
rowspan — це число клітинок знизу, що вимагають об'єднання.
Пусті клітинки після об’єднання видаляються!!!.
*/
/**
  |============================
  | Адаптивність та респонсивність
  |============================
*/
/* 
Респонсивна (responsive) веб-сторінка має кілька варіантів відображення, переходи між ними плавні, 
елементи і контейнер тягнуться, як гумові. При зміні розміру в'юпорта блоки плавно стискаються або 
розтягуються, а коли настає точка перелому, змінюють своє розташування так, щоб оптимально зайняти 
весь вільний простір по горизонталі.

Адаптивна (adaptive) веб-сторінка має кілька варіантів відображення. На відміну від респонсивної 
сторінки — це буквально різні стани. Дизайн змінюється ривками в жорстко заданих точках перелому 
і не тягнеться між ними.

Мобільні браузери відображають сайт у віртуальному в'юпорті (layout viewport). Ширина віртуального 
в’юпорта залежить від виробника пристрою. Найчастіше значення ширини віртуального в’юпорта за замовчуванням 
дорівнює 980px

Фізичний в’юпорт (visual viewport) — це величина, що дорівнює ширині фізичного екрану пристрою. 
У мобільних пристроях розмір фізичного в’юпорта за замовчуванням не збігається з віртуальним. 
Віртуальний в’юпорт ширший за фізичний екран пристрою.

Сторінки, адаптовані для перегляду на різних пристроях, повинні містити в розділі <head> мета-тег 
viewport. Він повідомляє браузеру, яким чином потрібно контролювати розміри та масштаб в'юпорта.

<meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Мета-тег viewport важливий для адаптивних сторінок</title>
*/
/**
  |============================
  | Медіазапити
  |============================
*/
/* 
Медіазапит оголошується директивою @media, за якою може слідувати:
тип пристрою (media-type)
тип медіафункції (media-feature)

@media media-type та/або (media-feature) {
Набір CSS-правил, які потрібно застосувати, якщо умова перевірки медіатипу та функції істинна
}
ПРИКЛАД
"якщо сторінка відображається на екрані шириною 900 пікселів і більше, необхідно застосувати CSS-правило"
@media screen and (min-width: 900px) {
  body {
..............................
  }
}
Умова медіазапиту може бути складною або простою. Усе залежить від того, що вимагає ситуація. 
У більшості випадків достатньо вказати медіатип пристрою (найчастіше screen), і перевірити ширину в'юпорта.
@media screen and (min-width: 400px) {
}
*/
/**
  |============================
  | Медіафункції
  |============================
*/
/* ---------------------------- Функція min-width ---------------------------- */
/* 
Функція min-width визначає мінімальну ширину області перегляду. У разі, якщо екран відповідає значенню 
в min-width, будуть застосовані вкладені CSS-правила.
@media (min-width: 800px)
800px — це точка перелому (breakpoint)
*/
/* ---------------------------- Функція max-width ---------------------------- */
/* 
Медіафункція max-width визначає максимальну ширину в'юпорта, до якої включно будуть застосовуватися 
вкладені CSS-правила.
@media (max-width: 600px)
 */
/*
  |============================
  | Медіатипи
  |============================
*/
/* 
Медіатип використовується для опису типу пристроїв, на яких може відображатися веб-сторінка. 
Взагалі є три типи, які підтримуються всіма сучасними браузерами:
1. @media print - дозволяє визначити стилі, що будуть застосовані при відправці на друк.
2. @media screen -  визначає стилі, що будуть застосовані тільки для пристроїв з фізичним екраном: 
смартфони, планшети, монітори, телевізори тощо. Тобто все, що не охоплює тип print.
Можна не зазначати окремо медіатип screen, якщо:
Стилі пишуться лише для екранів (немає окремих стилів для друку)
Стилі збігаються зі стилями для друку.
3. @media - Якщо не вказати тип носія, за замовчуванням буде використано значення all
*/
/*
  |============================
  | Логічні оператори
  |============================
*/
/* 
Медіазапити підтримують логічні оператори and, or, not. Завдяки логічним операторам можна комбінувати умови медіазапиту.
Логічний оператор and (І) — передбачає виконання всіх умов для того, щоб твердження було істинним.
Логічне or (АБО) — передбачає хоча б одну умову з набору, щоб твердження було істинним.
Логічне not (НЕ) — передбачає інверсію, тобто твердження буде істинним від зворотного, коли умова НЕ виконана.
Якщо оператор не вказано, використовується значення за замовчуванням — only.
*/
/**
  |============================
  | Оператор and
  |============================
*/
/* 
Оператор and (буквально «і») використовується:
- між типом носія та медіаумовою,
- для зв'язування декількох медіафункцій з перевірками значень — тобто визначення проміжку між двома точками 
перелому. На практиці цей оператор використовується найчастіше.

@media screen and (min-width: 400px) and (max-width: 800px) {
  body {
    background-color: red;
  }
}
----------------400px********************800px----------------*/
/**
  |============================
  | Оператор or
  |============================
*/
/* 
Оператор or («АБО») дозволяє вказати набір виразів, при виконанні хоча б одного з яких виконається і 
медіазапит. Логічний оператор or у коді записується у вигляді коми (,). Скажімо, необхідно застосувати 
однакові стилі в проміжку до 600px або після 900px. 
@media screen and (max-width: 600px), (min-width: 900px)
********************600px----------------900px********************
/**
  |============================
  | Оператор not
  |============================
*/
/* 
Оператор not (буквально «НЕ») дозволяє зробити заперечення, тобто скасувати медіазапит. Використовується вкрай рідко.
Ключове слово not додається на початок медіазапиту і застосовується до всього запиту цілком. 

Запишемо умову, за якої стилі повинні застосовуватися скрізь, окрім друку.
@media not print {
  ***
}
Наступний медіазапит виконається, тільки якщо сторінка буде відкрита на пристрої з екраном, 
а ширина перегляду буде більше 500px.
@media not screen and (max-width: 500px)
Зверни увагу! У прикладі, наведеному вище, логічний оператор not застосовується до обох умов у виразі 
screen and (max-width: 500px). Це особливість синтаксису, про яку треба пам’ятати.
*/
/**
  |============================
  | Підхід «Mobile First»
  |============================
*/
/* 
Сучасним стандартом є підхід Mobile First, що вимагає починати створення сайту із мобільної версії.
При Mobile First підході в медіазапитах, у більшості випадків, використовується медіафункція min-width:
selector {
   Базові стилі 
}
@media (min-width: ширина-планшета) {
  selector {
     Стилі планшета 
  }
}
@media (min-width: ширина-десктопа) {
  selector {
     Стилі робочого столу 
  }
}
Тим не менш, бувають випадки, коли використання медіафункції max-width робить код більш чистим і читабельним.
Наприклад, коли особливі стилі використовуються тільки в конкретному діапазлні:
@media (max-width: 767px) {
  .box {
    border: 1px solid black;
  }
}
@media (min-width: 768px) and (max-width: 1023px) {
  .box {
    box-shadow: 2px 2px 4px 2px black;
  }
}
*/
/**
  |============================
  | Адаптивна сітка
  |============================
*/
/* 
<div class="container">
  <div class="element">1</div>
  <div class="element">2</div>
  <div class="element">3</div>
  <div class="element">4</div>
  <div class="element">5</div>
  <div class="element">6</div>
</div>
Базові стилі
.container {
  display: flex;
  flex-direction: column;
  gap: 5px;
  max-width: 1170px;
  min-width: 320px;
  margin: 0 auto;
}
Мінімальна та максимальна ширина контейнера визначається за макетом – це ширина мобільної та десктопної 
версії вмісту сторінки.
-------- Перша точка перелому --------
У першій точці перелому 768px необхідно поставити елементи горизонтально так, щоб вони поміщалися по два 
рядки. Для цього змінюємо напрямок головної осі і робимо контейнер багаторядковим. Для елементів задаємо 
розмір за знайомою вже нам формулою з техніки створення сіток.
@media (min-width: 768px) {
  .container {
    flex-direction: row;
    flex-wrap: wrap;
    gap: 10px;
  }
  .element {
    flex-basis: calc((100% - 10px) / 2);
  }
}
-------- Друга точка перелому --------
Останнім кроком буде зміна зазору, кількості та розміру елементів для точки перелому 1024px згідно з макетом.
@media screen and (min-width: 1024px) {
  .container {
    gap: 15px;
  }
  .element {
    flex-basis: calc((100% - 30px) / 3);
  }
}
*/
/**
  |============================
  | Адаптивна графіка
  |============================
*/
/* 
------------------ Процес ретинізації ------------------
Для растрової графіки достатньо підготувати тільки 1x і 2x версії. Більшість людей з хорошим зором не 
помітять різницю між 2x і 3x зображенням, але вага останнього буде значно більшою, що негативно 
позначиться на швидкості його завантаження.
Процес підготовки складається з:
- Експорту зображень у N-разів більше від розміру оригіналу
- Збереження великих зображень з відповідними префіксами @2x і @3x. Для оригіналу префікс не потрібний.
Приклад: icon.png, icon@2x.png, icon@3x.png

------------------ Респонсивні зображення ------------------
Респонсивні зображення — це термін для опису набору прийомів, використовуваних в HTML і CSS, за 
допомогою яких контентні і фонові зображення виглядають однаково добре на пристроях з різними 
розмірами і щільністю екрана.
Найпростіший спосіб реалізувати респонсивність — це зробити зображення гумовим:
img {
  display: block;
  max-width: 100%;
}
Для того щоб браузер вибирав зображення, необхідно використовувати елемент img з атрибутом srcset.
<img srcset="./img/photo.jpg 1x, ./img/photo@2x.jpg 2x" />
Атрибут srcset визначає список версій зображення в різних розмірах. Після шляху до зображення додається 
дескриптор x, який вказує браузеру, для якої щільності екрана підходить саме ця версія зображення. 
Список оголошень розділяється комою.
Наявність зображення для екраныв стандартної щільності є обовязковоюю.
Вказання srcset не відміняє необхідності вказання src
Переліковуємо значення srcset в одних "", розділяючи комою:
<img src="https://picsum.photos/id/85/300/200"
     srcset="https://picsum.photos/id/85/300/200 1x, https://picsum.photos/id/85/600/400 2x" />

------------------ Ретинізація фонового зображення ------------------
Для ретинізації фонового зображення необхідно встановити розмір фону елемента рівним розміру самого елемента.
.box {
  width: 200px;
  height: 300px;
  background-image: url('photo.png');
  background-size: 200px 300px;
}
Якщо елемент не має фіксованої ширини і висоти, тобто залежить від ширини батька, розмір фону можна 
задати значенням cover.
.box {
  background-image: url('photo.png');
  background-size: cover;
}

На якість відображення фону також впливає щільність пікселів екрана.
Щоб визначити щільність пікселів екрана CSS, є медіафункції: resolution, min-resolution і max-resolution.
они дозволяють перевірити точний збіг і мінімальне/максимальне значення щільності пікселів пристрою.

Значення медіафункцій перевірки щільності пікселів — це одиниця dpi (dots per inch), тобто 
кількість фізичних пікселів на дюйм екрана.
На екранах стандартної щільності пікселів в одному дюймі 96 точок. Тому для перевірки екранів 
із щільністю 2 і більше вказуємо значення 192dpi (96x2).

Усередині медіазапиту з перевіркою щільності пікселів перевизначаємо шлях до фонового зображення.
 Базові стилі і 1x зображення 
.box {
  width: 200px;
  height: 300px;
  background-image: url('photo.png');
  background-size: 200px 300px;
}
 Перевизначаємо шлях до зображення якщо щільність екрана як мінімум 2x
@media (min-resolution: 192dpi) {
  .box {
    background-image: url('photo@2x.png');
  }
}
*/
